Binary files mruby-1.0.0/bin/mirb and mruby-1.0.0-seaos/bin/mirb differ
Binary files mruby-1.0.0/bin/mrbc and mruby-1.0.0-seaos/bin/mrbc differ
Binary files mruby-1.0.0/bin/mruby and mruby-1.0.0-seaos/bin/mruby differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/HEAD	2014-06-21 11:56:38.194631106 -0700
@@ -0,0 +1 @@
+ref: refs/heads/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/config mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/config
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/config	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/config	2014-06-21 11:56:38.194631106 -0700
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = https://github.com/iij/mruby-digest.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/description mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/description
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/description	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/description	2014-06-21 11:56:37.277965704 -0700
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/applypatch-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/applypatch-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/applypatch-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/applypatch-msg.sample	2014-06-21 11:56:37.277965704 -0700
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/commit-msg" &&
+	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
+:
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/commit-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/commit-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/commit-msg.sample	2014-06-21 11:56:37.277965704 -0700
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/post-update.sample mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/post-update.sample
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/post-update.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/post-update.sample	2014-06-21 11:56:37.277965704 -0700
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/pre-applypatch.sample mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/pre-applypatch.sample
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/pre-applypatch.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/pre-applypatch.sample	2014-06-21 11:56:37.277965704 -0700
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
+:
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/pre-commit.sample mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/pre-commit.sample
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/pre-commit.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/pre-commit.sample	2014-06-21 11:56:37.277965704 -0700
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/pre-push.sample mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/pre-push.sample
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/pre-push.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/pre-push.sample	2014-06-21 11:56:37.277965704 -0700
@@ -0,0 +1,54 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+IFS=' '
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/pre-rebase.sample mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/pre-rebase.sample
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/pre-rebase.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/pre-rebase.sample	2014-06-21 11:56:37.277965704 -0700
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up-to-date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+exit 0
+
+################################################################
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/prepare-commit-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/prepare-commit-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/prepare-commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/prepare-commit-msg.sample	2014-06-21 11:56:37.277965704 -0700
@@ -0,0 +1,36 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples.  The first comments out the
+# "Conflicts:" part of a merge commit.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+case "$2,$3" in
+  merge,)
+    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
+
+# ,|template,)
+#   /usr/bin/perl -i.bak -pe '
+#      print "\n" . `git diff --cached --name-status -r`
+#	 if /^#/ && $first++ == 0' "$1" ;;
+
+  *) ;;
+esac
+
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/update.sample mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/update.sample
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/hooks/update.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/hooks/update.sample	2014-06-21 11:56:37.277965704 -0700
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to blocks unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/index and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/index differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/info/exclude mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/info/exclude
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/info/exclude	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/info/exclude	2014-06-21 11:56:37.277965704 -0700
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/logs/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/logs/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/logs/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/logs/HEAD	2014-06-21 11:56:38.194631106 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 a866d9587b92a6c2803251ddd34f45fe9b4916e0 Daniel Bittman <danielbittman1@gmail.com> 1403376998 -0700	clone: from https://github.com/iij/mruby-digest.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/logs/refs/heads/master mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/logs/refs/heads/master
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/logs/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/logs/refs/heads/master	2014-06-21 11:56:38.194631106 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 a866d9587b92a6c2803251ddd34f45fe9b4916e0 Daniel Bittman <danielbittman1@gmail.com> 1403376998 -0700	clone: from https://github.com/iij/mruby-digest.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/logs/refs/remotes/origin/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/logs/refs/remotes/origin/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/logs/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/logs/refs/remotes/origin/HEAD	2014-06-21 11:56:38.194631106 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 a866d9587b92a6c2803251ddd34f45fe9b4916e0 Daniel Bittman <danielbittman1@gmail.com> 1403376998 -0700	clone: from https://github.com/iij/mruby-digest.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/01/0aeca4133b5b4bb9ff03a657a78f866392d1f8 mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/01/0aeca4133b5b4bb9ff03a657a78f866392d1f8
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/01/0aeca4133b5b4bb9ff03a657a78f866392d1f8	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/01/0aeca4133b5b4bb9ff03a657a78f866392d1f8	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1,3 @@
+xA
+Â0E]ç³Ê$i:ˆè1\NÒ©¦%¶„tÑÛ[ÄøWoñü¸äœ*K§ZDÀR4Alnèz¶hz'È:´:ò±èôØv¤E­\ä]Aã0RË4
+Q	ƒÇ¸·Fã!;ëÙ	µ!*Şêk)pŸSaxl9íœ.ûn)MÍ´^A[çé´·pF¨â÷d•?sµ­W\ÂSrSxõ£ªL
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/01/7746141d9fb1f70501a440de62e73f99bbd9e9 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/01/7746141d9fb1f70501a440de62e73f99bbd9e9 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/05/e915c8643077e710eec2c48c738adb6e472d0e and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/05/e915c8643077e710eec2c48c738adb6e472d0e differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/09/fa3368f5e8dee06dff29c38dfc1cf78d019afc and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/09/fa3368f5e8dee06dff29c38dfc1cf78d019afc differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/0d/e5ab7d88d36993ebaf390264cc7f229d3b2797 mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/0d/e5ab7d88d36993ebaf390264cc7f229d3b2797
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/0d/e5ab7d88d36993ebaf390264cc7f229d3b2797	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/0d/e5ab7d88d36993ebaf390264cc7f229d3b2797	2014-06-21 11:56:38.184631120 -0700
@@ -0,0 +1,3 @@
+xM
+Â0…]ç³KşÚf@Dár’5èPˆÉ¢··BO ¼Åã}ğ½´ˆä
+ûC-ÌàÇ¸¥wÈC@=Zo¦§ ×†bòl,?PQ«Ï¥Àí•Á½I^IÎëŞ:úë,”ß]ZäÆõÚ`GZ«mİ®+ÿ!Açv‰’ÒâzšòÌŸª¾Ş@y
\ No newline at end of file
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/10/df74a7fe77bf70b9067a83210ac5539a5e74bc mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/10/df74a7fe77bf70b9067a83210ac5539a5e74bc
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/10/df74a7fe77bf70b9067a83210ac5539a5e74bc	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/10/df74a7fe77bf70b9067a83210ac5539a5e74bc	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1,2 @@
+xÎMj1@á¬}
+íAÿ„Ğ£K-%Nğ$¸ÅÜ¾!ôİ½Í/?Z«&G‡ÑEÀ©jƒw¢Øb‹x‹’]N“‰Âİ<›'wY¤A‹z!VRLÈ¢‹ÇMÙKD¢\¼ám\¾îµ3|o­îÜNû_}Öz;r9Şg ëg?J>pF4ù=9äŸÜp)Ğúr‘C~ôm]¥›_ó$M¦
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/15/b9cec15da85054ad93720de5a4b4813dd16d23 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/15/b9cec15da85054ad93720de5a4b4813dd16d23 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/16/35fd1b45b06b77a5b9bbc063f116679fc8d82d and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/16/35fd1b45b06b77a5b9bbc063f116679fc8d82d differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/1a/0efb49f85afd91af9cf068774b35b1f07233bb mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/1a/0efb49f85afd91af9cf068774b35b1f07233bb
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/1a/0efb49f85afd91af9cf068774b35b1f07233bb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/1a/0efb49f85afd91af9cf068774b35b1f07233bb	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1 @@
+x­Ï½jÃ0àÎzŠ»‡9ú5„’Ò9ÚtW×râÆ²Œ~¿}M¡oĞá,ßp8‡bcÁõKIŞC§¥äÂÊÎ‘dQr¢qdoJAZ+¶`òsİJe{¯9Y-7—ÆIÓ÷ZŞY!•â4tŠˆa-˜àüvıü:_®øXc®OÇ€%×K¼¥ÓìK3æ-Ísİd_¤æ{y…V(#Zc•€ï8gô;¼ø¬dïœïBªn½Mı0á=C‰0ºÃöa?QZ—ÙÉcÔ
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/1d/52630782f69a074fb8c920ee982787712e4e0e and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/1d/52630782f69a074fb8c920ee982787712e4e0e differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/1f/033a16642f8100387dc3ed035b8a51e806f05d and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/1f/033a16642f8100387dc3ed035b8a51e806f05d differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/21/f8afe00fd50a10668f27bfa7b6debcc7fa672c and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/21/f8afe00fd50a10668f27bfa7b6debcc7fa672c differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/28/fd626887216fa6b0212f6cf7ad755362dcca0e and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/28/fd626887216fa6b0212f6cf7ad755362dcca0e differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/29/2b4b7668224a84e3a34dd0c329c73c1e1241e3 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/29/2b4b7668224a84e3a34dd0c329c73c1e1241e3 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/30/52ffdd982605bbed19a5268d2f750f98ab6cf1 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/30/52ffdd982605bbed19a5268d2f750f98ab6cf1 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/33/c640d6a20af0951e9c81c12900d8fdd149ec10 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/33/c640d6a20af0951e9c81c12900d8fdd149ec10 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/33/cd5aea685746259711b703a3f245b2e3d70e13 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/33/cd5aea685746259711b703a3f245b2e3d70e13 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/35/567e839f6d4f47e85854413d93abec2b5603e3 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/35/567e839f6d4f47e85854413d93abec2b5603e3 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/37/b04425e205ccb2d026bfbb6d5351a1660f93ce and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/37/b04425e205ccb2d026bfbb6d5351a1660f93ce differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/37/c2be3bb5d68a30285e0a1b41caaaac51f4671e and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/37/c2be3bb5d68a30285e0a1b41caaaac51f4671e differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/3f/b409e65dd43573ad74b95cd0b88f35376fe4b3 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/3f/b409e65dd43573ad74b95cd0b88f35376fe4b3 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/47/8528a6534559e2073c64a520788b46ef89009e and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/47/8528a6534559e2073c64a520788b46ef89009e differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/47/b47b539e68907242c9c8bd801401abc4e12ef9 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/47/b47b539e68907242c9c8bd801401abc4e12ef9 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/49/31fac24f5444da2fa9ba718401e6a44c2aba10 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/49/31fac24f5444da2fa9ba718401e6a44c2aba10 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/4f/a7283435a1506d345fa16410a8fa41194d2ac1 mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/4f/a7283435a1506d345fa16410a8fa41194d2ac1
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/4f/a7283435a1506d345fa16410a8fa41194d2ac1	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/4f/a7283435a1506d345fa16410a8fa41194d2ac1	2014-06-21 11:56:38.191297778 -0700
@@ -0,0 +1,2 @@
+x]?kÃ0Å;ëSxp2DJ¡¤CÉØ,¥{-YûŠşI&	äÃW²q½AœŞOÜ»'e¼‚ç×·'&uİiê1&¶_‹±ªr1Ic@]ÁÕ£v µ†Î»ÏrÉC«&2ú§èÔó ZÖ¶m™Ì_ùâ£pîğÚÃ­¼»1¹*àœÃ&:·¥]Ô»è)Áşê!¥1Š¦É÷aR¼ó¶!úm×ç™Õ.æs¼H;¼/s˜c
+q<¼ğ%ò¦.[Ö[öˆ¼ü£ëÀOêĞEdßEˆş”Î2 äŞ,@Ãä4HB”WÁŸfâõä¤ÉßšÍsä?£ƒH
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/4f/ffc740654167e3d3de530ec4c82f6e7eaf7499 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/4f/ffc740654167e3d3de530ec4c82f6e7eaf7499 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/51/5b9a6a4a2d7b17c090d7d38854ff5cf22b6c53 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/51/5b9a6a4a2d7b17c090d7d38854ff5cf22b6c53 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/55/ef3162f52f87270ee4cd2f29675df0e0bb134b and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/55/ef3162f52f87270ee4cd2f29675df0e0bb134b differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/56/9776007b197f584508c61dbc1f856e44c89fb7 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/56/9776007b197f584508c61dbc1f856e44c89fb7 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/57/b5f07da2fc405e0aaf20b635e057b90cb0d710 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/57/b5f07da2fc405e0aaf20b635e057b90cb0d710 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/5b/2f9f4c45eb4bf0f293473223011bcc06c5dbd6 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/5b/2f9f4c45eb4bf0f293473223011bcc06c5dbd6 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/5f/19e2396ca0fff09467a03ca42aef3f978b7db5 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/5f/19e2396ca0fff09467a03ca42aef3f978b7db5 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/61/04efb422edf61db21d0c40472b851deea744bc and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/61/04efb422edf61db21d0c40472b851deea744bc differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/61/458de60c86466547b47ddbc109834550cf95cc mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/61/458de60c86466547b47ddbc109834550cf95cc
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/61/458de60c86466547b47ddbc109834550cf95cc	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/61/458de60c86466547b47ddbc109834550cf95cc	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1,2 @@
+x¥M
+Â0F]ç³J~&M"z—“dRK-!]ôöVğî>ŞƒÇ—R¦ı©Ufˆ9Ë@JúL	Ct˜‚VŞq¤À–Éä”8iÅb¥Êï¼%;˜Œì]Ÿ3šˆJö˜£DÕ“Õh—œ´µçRá>O•à±•i§BpÙ«£¯¸…¦W—re¬Ó¾´‚³ôRŠƒWÿÛš¨1”F.]¥™ÅœdQÏ
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/66/39a20fb4e01df97f3bd65c268a357684ee3798 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/66/39a20fb4e01df97f3bd65c268a357684ee3798 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/75/ffcca24c17a67cf6be4e9ce1a06651b4a42723 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/75/ffcca24c17a67cf6be4e9ce1a06651b4a42723 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/76/1bd1b7d4362849c1cc0f4bb7df799f92fa60b6 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/76/1bd1b7d4362849c1cc0f4bb7df799f92fa60b6 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/77/79f54b921b4c195517bdecc795cf90c38890b2 mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/77/79f54b921b4c195517bdecc795cf90c38890b2
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/77/79f54b921b4c195517bdecc795cf90c38890b2	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/77/79f54b921b4c195517bdecc795cf90c38890b2	2014-06-21 11:56:38.184631120 -0700
@@ -0,0 +1,3 @@
+xRËjÃ0ì9_±½¹tè©-1¡J/¥‡~€‘­µ­F•Œ¥Ğ´__Y+ç&£Ç³3«-•)áşöîJÖğQ~aåXe´u…ÀZjkxx‘Z·ø6b«â	 RÜZxâà?Ï‹ªf"Ğ3Á¿	Ğ½Æ¶íü5‰‚Zì‹ÔRaÖq×“xõf:ÔÄb=rAÜ#­w³=%î‘­<ÏŒk±ù~…3ÛH-
+S¯áÓõR71rô Ï‰qTaŸK&qÚ€1Õ¸í>İ¤ØãyJş®£—äô\	‰@xÛ-º‘ÖÁOØp%¹…ºq-P”‚NØÊ?<:SXØ/K¢«P(¯ëÑğ½½?>õSÃ·„ş.cµñÕB
+?‰Ù›?–É]áK+$•àı ƒ‡axøÿŒà'
\ No newline at end of file
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/78/b4c90fb631bb3c1430f4bfe95b245eed27be1b mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/78/b4c90fb631bb3c1430f4bfe95b245eed27be1b
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/78/b4c90fb631bb3c1430f4bfe95b245eed27be1b	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/78/b4c90fb631bb3c1430f4bfe95b245eed27be1b	2014-06-21 11:56:38.191297778 -0700
@@ -0,0 +1 @@
+xuPÁN1õ<_1ô@{ÑhH ‘@¼€$OĞv‡İjwKÚ®BŒÿnwW"kbí´ïÍ›×'•xsw‘»Rû‰NÉ@·‹ºğAƒòˆ¹“)å¶Û­>ƒTTÆ„±p÷¬”LÙœkıÊÏEYÄ@í±¿wQæw^~Î—ëñËf¹X¬¾bK=§œ©Ì¶¹£Ñ?ôÇéü™	ô;JÚ$pâpúô0M7qØ	®¤0.uÑ˜lwœ¹8·Êé ò½!îëƒ9YQgôƒT÷êo0©ƒæ“[Ö„zÕ«€ŞuÊèğ=	Î´¢Â¬2íÑÛ]ø0Ö¦,‹„†Œ0Ú¡Ó;r¹G»«ëtªašÀ7ñË¦ú
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/79/ef20723b1ed143376aae3d293dc698434fada9 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/79/ef20723b1ed143376aae3d293dc698434fada9 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/7b/e23b4d3d125644547c2df09f51227fcdc7ba9f and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/7b/e23b4d3d125644547c2df09f51227fcdc7ba9f differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/7b/eaf76f758450393c4c2e73524248245b9eb3ff and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/7b/eaf76f758450393c4c2e73524248245b9eb3ff differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/7c/3a6395e5e29e3f812396534c35165ced20708a mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/7c/3a6395e5e29e3f812396534c35165ced20708a
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/7c/3a6395e5e29e3f812396534c35165ced20708a	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/7c/3a6395e5e29e3f812396534c35165ced20708a	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1 @@
+xAnÃ E»æ³6˜‘¢ª×hw6RÀ!‰ÜÓ—^¡»¯ÿß—^ØKÉ´•o½1N¸LNGVVRZ4jÂ%*šcĞJG§Ğ&­Å×‰-%Îzã<ÏŠ¥2>øh“‘ÇQ	zômoğ½Q]á+Ãåç/ùêçZ(_Ïa/ &4ˆ“3NÒI)F;;ÿã*—ıÉğ¨•ßïÔx¿†vÜú¯+tj+÷<Œ"µW®â3ªT…
\ No newline at end of file
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/84/ff66fdf5e1af1f080aefb5087412c5e7011cd5 mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/84/ff66fdf5e1af1f080aefb5087412c5e7011cd5
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/84/ff66fdf5e1af1f080aefb5087412c5e7011cd5	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/84/ff66fdf5e1af1f080aefb5087412c5e7011cd5	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1,3 @@
+xÎA
+Â0@Q×9Åì…2é˜&=†Ëifªi‰-!]x{A<»¿yğÓZJnĞ“?´ª
+vB"¶Ãpê§`)xI¤‚äÆÀÎjÀaB'fãª¯„mâHÉ@”zvA¢·ÕêİÉ'rÄğŞk…Û’+Ã}/ùÍ…áüşÕ5ç¹céæí–\ˆõpÄˆhÒw²éŸÜì›pS(u|hé*/j>˜Kb
\ No newline at end of file
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/85/94af926b2a784903d54f539232e556ca8297eb mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/85/94af926b2a784903d54f539232e556ca8297eb
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/85/94af926b2a784903d54f539232e556ca8297eb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/85/94af926b2a784903d54f539232e556ca8297eb	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1,2 @@
+x¥KŠÃ0Dg­Sô>`$u[BrŒY¶İ-ÇdBYøöã@n]Q¯xÔ¼Õºvğ¾zS…˜µx=NNÅbÌŠâ3Êr"¤ÂÂÙüqÓGÉ#ÚèR‰2Ó(Ç hTBÈ
+%—BÒ’‹~öÛÖàz_ÃÏ³®;W†ïı~ËRyıæ­Áá}ôœl¶ÖíqµëGÃ"PÛ´hßÕüT4O 
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/85/a9915e85121bc23d3ffebd0c3967eebe4a05b5 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/85/a9915e85121bc23d3ffebd0c3967eebe4a05b5 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/8c/7d9c5990b11f53e91ece67b4ba71721785b341 mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/8c/7d9c5990b11f53e91ece67b4ba71721785b341
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/8c/7d9c5990b11f53e91ece67b4ba71721785b341	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/8c/7d9c5990b11f53e91ece67b4ba71721785b341	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1,2 @@
+xÎKjÃ0€á®uŠÙŒ£B‰!›ì
+ÍFTJql™ÒÛr„îşÍZæ¹u°^¿õ­È”%¹è©°åQP²˜èHB´¡cV«låÑ!	³¹!R	d]ºÙÆè}Š#çäĞrÉÖ[%{¯Ë×e^~÷ïŸRe8öç+N­İÉÃ}}ã˜5z4´Vé5ÙË?¹JÒS…}…ŸÖ+œ§ëÓÇR•ÇWyêN§
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/93/97c9f82de160af7292a97d1a4dc212d8196f22 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/93/97c9f82de160af7292a97d1a4dc212d8196f22 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/94/5b2e033e243fd0f9909e77ffea4c907f441a48 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/94/5b2e033e243fd0f9909e77ffea4c907f441a48 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/94/b628c50b6a0bc5899c1be649ead02abb8bf333 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/94/b628c50b6a0bc5899c1be649ead02abb8bf333 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/95/23e50478994b8daf3e94e8bc00543fdec12907 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/95/23e50478994b8daf3e94e8bc00543fdec12907 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/96/4403849bc63c8a40cc1aaff4d7ba225673c665 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/96/4403849bc63c8a40cc1aaff4d7ba225673c665 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/99/68302e903d4dbdc9af283d9ac5a71a7210de82 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/99/68302e903d4dbdc9af283d9ac5a71a7210de82 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/a0/789da9d615027317fdf004b99234ae5cd25611 mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/a0/789da9d615027317fdf004b99234ae5cd25611
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/a0/789da9d615027317fdf004b99234ae5cd25611	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/a0/789da9d615027317fdf004b99234ae5cd25611	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1 @@
+x¥KNÄ0DYç-±Î`Ç	!kÀjÔîØ™hìqpœEnO@Ì	Ø•^=•TTrkZœ–’	+'-È¢dD1F9Ã ´¤µê¬áÖ@s©ì4#«åÁ¥ñÒŒ£'ÎœR)FÑ)¢»Ï‘…è¥‹VaÇè(2m‘^(Ï#3ƒŞw¸µK©ğv+Âç–ç3Âóş—NøS¼Nçt¢’_€e„ÒNXè™e¬;èq­…t¡N–-%¨ákkƒG±–ÛºåÒJ_Ÿè‚·)œÓNë¹•sšıÚuï¿rİü~o¡•;8ˆÇÍ>Qİ—V¾¨ ù
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/a4/5a936edadd9fccff92bc01b82756e7c01d8ce5 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/a4/5a936edadd9fccff92bc01b82756e7c01d8ce5 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/a8/66d9587b92a6c2803251ddd34f45fe9b4916e0 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/a8/66d9587b92a6c2803251ddd34f45fe9b4916e0 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/b2/1d1286d7e7b16fb7faff90317e8edd12b974e4 mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/b2/1d1286d7e7b16fb7faff90317e8edd12b974e4
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/b2/1d1286d7e7b16fb7faff90317e8edd12b974e4	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/b2/1d1286d7e7b16fb7faff90317e8edd12b974e4	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1,2 @@
+xKNÄ0DYç-±D€?±ã–â¬à»=‰fbş0šÛFâ¬jQ¯T>oÛÚ@s×
+3 ÆÉct*°´‚â¤PNAÒ¼’*8‰6*5œ©pji§…ÀÑ‘ÃÙ¸™GÉBšÙÏÁF#fŞË€òŸ¼&«Ñ°a…¬£“J£5zôÚHk<%&áh Ş–\à3oùÚ+|ĞB…à¥Şò­öÒ·Wû^ °£€‡=Åào—ÿk<¼s90œûé…¿:×÷bÉ„ü{¹×çê®†Â[şfè)±çZ©\áñäËõÜ2\NĞh—µ5 P¹¬én!s`
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/b2/cf209d80f296a141e1a4ef1a41954fa8f8dedc and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/b2/cf209d80f296a141e1a4ef1a41954fa8f8dedc differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/b6/6a771f446e9623cf2d98b55cb87dc3427ed252 mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/b6/6a771f446e9623cf2d98b55cb87dc3427ed252
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/b6/6a771f446e9623cf2d98b55cb87dc3427ed252	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/b6/6a771f446e9623cf2d98b55cb87dc3427ed252	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1,2 @@
+x¥A
+Â0E]ç³Ê4m:ˆè1\É$™hÑ´%¦‹ŞŞ¼»Çğø~Ji( [{(Y9‘ëè[4‚ÌQ£ëš7gÑ;T£š9ËX öÆéY·ÚRí½&ÑïK¥|l/å9e¸¾†Ìp[Ò°rb8­?ªx—Gâá]ù)¡n:2hLİÁ-¢ÚÖíj‘¿"j™¼Œ÷"ŸRe§¾ÛzQU
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/ba/95a583f4e976ff43c41064fc0416a524387d73 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/ba/95a583f4e976ff43c41064fc0416a524387d73 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/bc/ab2faaeeb35c520545a0dc6dba8c45f5385c1a mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/bc/ab2faaeeb35c520545a0dc6dba8c45f5385c1a
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/bc/ab2faaeeb35c520545a0dc6dba8c45f5385c1a	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/bc/ab2faaeeb35c520545a0dc6dba8c45f5385c1a	2014-06-21 11:56:38.191297778 -0700
@@ -0,0 +1,2 @@
+x5Œ±
+Â0Eóo{:XpĞ!ÔY:tQ Iú0MÂKªúñ¶B§çñÑÀáxÚ´×ÁŒZ_¨×ú–ÈòƒmW8†*Ğw‹½Ì÷Şñ“rÁ¸S­I,[y¶2Á°mî¸ân(¯(yÁÿ8ú‰$£Z%ÏáM2'ŒtÂ”¡®­Œ©DTœúŞÔ6ü
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/bd/b4591024f296c5364d5021bf3530bfc05c5b77 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/bd/b4591024f296c5364d5021bf3530bfc05c5b77 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/bf/bab9ff298c8c9be43bf1eff5b278df0ea4627c and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/bf/bab9ff298c8c9be43bf1eff5b278df0ea4627c differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/cb/01e8c8adee7a3e868b9a9aa0a0369e75ed4fcc and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/cb/01e8c8adee7a3e868b9a9aa0a0369e75ed4fcc differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/cc/628eae1312db001af30e0367d2a6af83b725e1 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/cc/628eae1312db001af30e0367d2a6af83b725e1 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/cf/f0ba109fad4bc74db2197ecabe5ea3fdded21e and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/cf/f0ba109fad4bc74db2197ecabe5ea3fdded21e differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/d0/1c8692a4856a5145d957b1e516f19416c50429 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/d0/1c8692a4856a5145d957b1e516f19416c50429 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/d6/dac3b56e727844a4ada1b36a9b269741645b8d and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/d6/dac3b56e727844a4ada1b36a9b269741645b8d differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/d8/da1ca93f3d633c2a58d9717ae1eb9547c35e8d mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/d8/da1ca93f3d633c2a58d9717ae1eb9547c35e8d
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/d8/da1ca93f3d633c2a58d9717ae1eb9547c35e8d	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/d8/da1ca93f3d633c2a58d9717ae1eb9547c35e8d	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1 @@
+xÎMJ1@a×9Eí…¡ò×é=†«¦’T™13CL/úö‚xwoóÁ+÷ŞÛèiˆjIœ§¥0ª*RX£/‹z¥´æTs4r›À˜VªLu±]ò6iUÄ‰œ,±Tkïóó>àıÚÃÇŞÛÁáåø«·Ö.'®§Ëã¬+Fà	Ñ”ßÉ)ÿä†k…>òÖÇ­¶³|Ïí,}Óvã/óîüP|
\ No newline at end of file
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/d9/530718f7dc45d9846e7e43eb40d481868ef9fe mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/d9/530718f7dc45d9846e7e43eb40d481868ef9fe
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/d9/530718f7dc45d9846e7e43eb40d481868ef9fe	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/d9/530718f7dc45d9846e7e43eb40d481868ef9fe	2014-06-21 11:56:38.184631120 -0700
@@ -0,0 +1,4 @@
+x¥»
+1E­óÓK6¯É€ˆ‚–6v–“—.W–láß»‚`w¸.'µ”ÁU›rëÑI‰¡',Ö+}t}
+±/ŞºlLôTŠOùÙ@¦l9`ò>iG¤sà¢I*gbÄ¢%
+Ûmœ`&†Ë\‡7W†ÍûGÅîZyxtq¬[èõÒ¢H+kIRŠe]R[şëDÌ¯Ä-Ãù¸?œ]Mâ/ÒNW
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/d9/566a2a64aae776e485efb8c5818f484a056c92 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/d9/566a2a64aae776e485efb8c5818f484a056c92 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/e2/afed26b893147deffd79378727c1ede80e3059 mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/e2/afed26b893147deffd79378727c1ede80e3059
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/e2/afed26b893147deffd79378727c1ede80e3059	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/e2/afed26b893147deffd79378727c1ede80e3059	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1 @@
+xK‚0@]sŠÙ›ÚRš£‰,İø9À0„`Yx{Gp÷6/ïÉ4}‚ÂØMZTÁ)-Æ’äƒ#R‘PcÕÆH6¨f3/úLP‰A\ØµÎh -}cöäò•kŒ¥Œ×ÔMÜ¦qz¯®ÜñÂ°K¯ú~È9æÃ¼2Ş“±Ö!lñÛÍä7™ôO=»Ï‘“Â¥>Îu>ÆîVI
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/e7/44552b488c8da803be8e109d41ef27a7bfc455 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/e7/44552b488c8da803be8e109d41ef27a7bfc455 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/e8/319d020cecc30af526c12f40d134f72dadad7b mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/e8/319d020cecc30af526c12f40d134f72dadad7b
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/e8/319d020cecc30af526c12f40d134f72dadad7b	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/e8/319d020cecc30af526c12f40d134f72dadad7b	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1,2 @@
+x¥A
+Â0E]÷³J’‰“DOár’l¬Ä(ôöVğî>ï?>?M¥äÆúU«"`‚‰6:"oŒeoí0¨„&$‡I‹6Vv®ro Q¥Eu8D»ˆD&Æ€ŠPŸ-¤\<[O¢:~µëTápË•áô*yæÂ°©ço±¿ÎcŸ¦²6ÎkG°VA©n¡ËÕ&tÇ*ÜúVùŸı\ÆWõOƒ
\ No newline at end of file
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/eb/0c82273db434d662bb930631fd1e607bf486e0 mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/eb/0c82273db434d662bb930631fd1e607bf486e0
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/eb/0c82273db434d662bb930631fd1e607bf486e0	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/eb/0c82273db434d662bb930631fd1e607bf486e0	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1,2 @@
+x1NÄ0E©}Š‘(‘`l'q,!DA»p™df7ÂY/´·'Z‰Pıâÿÿ¤7åu]*xïïjV&ª.Ó8E–Î³ZQíÙ…qVê&s¡"ç
+ììlİ8ÌAÛA9(©Fô6È(óŞqt{E×G	3©'§~#czµBDtä¬EŠ†Z=åŸyÍ×öµÀ¨<o·|İZ©g©/`}0b°<ì‰fº)Uù×Ù¤.-%(òİd«pï@K^aJË®ŸVÚvº1mx?¼Ù!ŸÓú¡%'ùZïkk
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/eb/e896cbb8bce57578ba153bd8e4fb055436483d and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/eb/e896cbb8bce57578ba153bd8e4fb055436483d differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/ec/c9e3630636814325c8fe6ebd6ac6b0e439e410 mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/ec/c9e3630636814325c8fe6ebd6ac6b0e439e410
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/ec/c9e3630636814325c8fe6ebd6ac6b0e439e410	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/ec/c9e3630636814325c8fe6ebd6ac6b0e439e410	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1,2 @@
+xÎAn1@Ñ®s
+ïXTy’LbW¨êàvÆš…P©·GâìşæI¿Ôm[;ø@½™Á8O>Ìä—Ä‚9.J…=š1ùL9Ş¢¡¹›4ûíÀQ“§2¡&A-1—Q-E6™Ñ‹*éBpòèçÚàX·úÿ¸®p³4}¿¿âg]/ƒÌÃåöcàD1L”áÑ•×d·7¹k¶Õ?ƒ“4•“Áîk7¸'4QJ¢
\ No newline at end of file
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/f0/259e7daf3a2f3eff0b0575f17a79002a2110a9 mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/f0/259e7daf3a2f3eff0b0575f17a79002a2110a9
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/f0/259e7daf3a2f3eff0b0575f17a79002a2110a9	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/f0/259e7daf3a2f3eff0b0575f17a79002a2110a9	2014-06-21 11:56:38.181297791 -0700
@@ -0,0 +1,2 @@
+xAÂ09ûsGBãØx¤â€Äi÷ÀÆÎ¬M
+†÷¯ß°Ç®Vµ:¯ËRwmS"Ç2`I^ÑN…ÇâÒD!Å…‘¢Wu#Gó”MŠd.ˆì£DN!&õ¶›!å®•€I{9±5òn÷uƒŸšá"sÚTÚ¾=ßNy®}Œy]`ÁÑtÚ?6ıŸmŞ/…ë÷ÙB- ©³¤YÍçK=
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/f2/8a840168a61c6467f231dcf112a505be849243 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/f2/8a840168a61c6467f231dcf112a505be849243 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/f8/46494046d4fca43afd5ee114fdfde5bc1ff117 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/f8/46494046d4fca43afd5ee114fdfde5bc1ff117 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/f8/5bde8a242971cc27e2cabaf07d97397dd07cf4 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/f8/5bde8a242971cc27e2cabaf07d97397dd07cf4 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/fa/c9f00948a89b58be41e015bcbd6f50be009d91 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/fa/c9f00948a89b58be41e015bcbd6f50be009d91 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/fb/b8c5e4c3fe83b3da085c808186f9ec106eb2d3 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/fb/b8c5e4c3fe83b3da085c808186f9ec106eb2d3 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/fd/13fa43adef8a166e04e5d31a7c7dc5525be443 mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/fd/13fa43adef8a166e04e5d31a7c7dc5525be443
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/fd/13fa43adef8a166e04e5d31a7c7dc5525be443	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/fd/13fa43adef8a166e04e5d31a7c7dc5525be443	2014-06-21 11:56:38.184631120 -0700
@@ -0,0 +1,10 @@
+x½X[O#7î3¿Â›T…•*äÛøA+ Ğí­´ÛªTJ…ì±iC‚’A›íC{íL&d'¶¨+±“ññå;ç|>—±£‰EÅü«n÷ ‹úÃ;?«Ğ/ğßÁÁ0 ŸíŸ¾¬ËÉxVİ:†cï¾?êåio2³™ŸVG‡yäğ-rE‹ËL@§§èzâFD~ì>[×ë›™__G›=.âfÛ·èıÇfOĞ)G	‘õwÃqúU£[ìKÒğÔÏÊ'~šT?><üƒWŞ]N§“):ıEìñ_Ú3¿DUòPƒ±e5ÌÙ ôu¿hÀföz0Øl·Ce˜‹fO~šìÜ¾W#~¨O‰öŞ
+ìØ%*´ï™eG‡Ó'û	fÀ¾›Áü²8Ì	û~]æWâ›ÛÁ¼>˜k9˜ŸãÁ\Áh_æggğ¼ê4ÇwŸ³(Û GÀˆ6®Dİûù6€Kñ3Œ…òs„Qî}TÁY--VŞic\XÔ‚¨ûôèLµÂRìªí1ÕDrÇyf}v"‰k '{½
+Dÿ¼M±¶b+HjJb™gÎbA™ö`9®ˆT^à@vìä¤g6Ën7mF´èäu¦ôxÊ›Ÿ"ˆGÏÍl›×†nm¾
+V÷KŞÜÜ4Øç1¬yº†×‰w C!Bsºç<¶eŞû_Ï_ìw>…mÓ«¦Ì"æÔ"–DÁŒv\çn­à‡j:ß5ºmWë5¨jG“ò¯Û‘ßU÷›Ï]O|»ÃjŞ>O89tÀE\sÏ"š%uşK¤j£NFò¦Q­å&®ÁIlqPoÒ[wùš@B„äLû5/rÔTWƒ9†(zNá	²Kˆ¤
+*ˆ¯
+Ş`Ö•:ÿ'ß‚.şöĞÃÔV1»§‡Ç*'SŸÏzvÔ:²:ûÿ3Ÿ¶(tİ‰x¦ôbmÔu¼$µ;Î,Yÿöi¬AÕ–2º[SFw™^ì)¨`PgŸ€ĞZ˜Ÿ­èVMnS)´¥„,ÒÀüF-u¬İ$Z9Nœ*VcUŸ×
+c­•/ƒâTúJ$_½Ø|î8­[øÿËA=šÉºV¢Şûë>8°~C³¨±jƒœµ†ó¼˜ÃÛî*B‰T;m%Á¶,°"HŠºdXÒaZâR…`ˆ–ù~Î†„0—‹’p³NŞ‘V¢`·>qÖmˆò{Â1‰åôÄx¡}0k@Í dV¥,ÓÛ:·_¨-rX÷ Ñ^Á¼:YM˜"š‡àµ—¥²V8©ñ®´ĞE¬ÿ”Ó¥Ø
+á™5…1ÔK…‹Â¼’ç˜Šék½=êõ@Wí¥+ÌÛ¡«`…šyh)Zl¹–ÎH*U%Õ„{«.¨ä\Š Çœ	œK%¤Æ¡Ø+ÎÀóœhË¦Ôc¡_É¡›l¢½lóvØ‚SÆ±rRRf˜SØ ²ÂÜºMŒÒ|I$aL	#­‚W
+4Z(†¥ÑXI©Jã(ÁN/\ğZCQBé"èPÂeñ¡,!hÎ PX(ìş¶Z§ÿ»ë³‹&(ÕÙ8îİ¦É9ooØ):ĞÀ˜Î·¨sof÷è/ÿ	~×'Æ€‘[9¨$ú(–ĞÏ]A	8ÍÛåÅ›«ßó¨DÎ‹F€„°m]S¶ø°-å{Âb_rÆ\pZbïKJ¸(dlì.¨˜Ñ%ïˆ«»©;I !ÖV:\³R¢ójã²ç’ÿ±§I®ÖÔñW³ŞøFF$]İñêV±’ØV§³3ã¶–ˆ{şl¯x:¹~áÛîÚ7¨^/¿(UÚ¾$ù¶f~o`Ë&®|«hI’×bk>jSÃÿbÄùËÍñRÅ'ŸVE<·I
+RzÎœ·†SPj8åÒÅ,Ñ†”©ö‰®‰ÿğ*Ù;
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/fe/5f2b67910e9d9343069b2c44f8b1b71c9f4a3a and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/fe/5f2b67910e9d9343069b2c44f8b1b71c9f4a3a differ
Binary files mruby-1.0.0/build/mrbgems/mruby-digest/.git/objects/ff/e2272848e47cd1ec92701b6d74e088d3dd4491 and mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/objects/ff/e2272848e47cd1ec92701b6d74e088d3dd4491 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/packed-refs mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/packed-refs
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/packed-refs	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/packed-refs	2014-06-21 11:56:38.194631106 -0700
@@ -0,0 +1,2 @@
+# pack-refs with: peeled fully-peeled 
+a866d9587b92a6c2803251ddd34f45fe9b4916e0 refs/remotes/origin/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/refs/heads/master mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/refs/heads/master
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/refs/heads/master	2014-06-21 11:56:38.194631106 -0700
@@ -0,0 +1 @@
+a866d9587b92a6c2803251ddd34f45fe9b4916e0
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.git/refs/remotes/origin/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/refs/remotes/origin/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-digest/.git/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.git/refs/remotes/origin/HEAD	2014-06-21 11:56:38.194631106 -0700
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.gitignore mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.gitignore
--- mruby-1.0.0/build/mrbgems/mruby-digest/.gitignore	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.gitignore	2014-06-21 11:56:38.204631092 -0700
@@ -0,0 +1,5 @@
+gem_*
+gem-*
+mrb-*.a
+src/*.o
+/tmp
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/.travis.yml mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.travis.yml
--- mruby-1.0.0/build/mrbgems/mruby-digest/.travis.yml	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/.travis.yml	2014-06-21 11:56:38.204631092 -0700
@@ -0,0 +1,2 @@
+script:
+  - "ruby run_test.rb all test"
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/Makefile mruby-1.0.0-seaos/build/mrbgems/mruby-digest/Makefile
--- mruby-1.0.0/build/mrbgems/mruby-digest/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/Makefile	2014-06-21 11:56:38.204631092 -0700
@@ -0,0 +1,14 @@
+GEM := mruby-digest
+
+include $(MAKEFILE_4_GEM)
+
+GEM_C_FILES := $(wildcard $(SRC_DIR)/*.c)
+GEM_OBJECTS := $(patsubst %.c, %.o, $(GEM_C_FILES))
+
+GEM_RB_FILES := $(wildcard $(MRB_DIR)/*.rb)
+
+gem-all : $(GEM_OBJECTS) gem-c-and-rb-files
+
+gem-clean : gem-clean-c-and-rb-files
+
+gem-test : gem-test-c-and-rb-files
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/README.md mruby-1.0.0-seaos/build/mrbgems/mruby-digest/README.md
--- mruby-1.0.0/build/mrbgems/mruby-digest/README.md	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/README.md	2014-06-21 11:56:38.204631092 -0700
@@ -0,0 +1,56 @@
+mruby-digest
+=========
+
+## Features
+
+Message Digest and HMAC classes are available.  They are compatible with CRuby's ones.
+
+- Digest::MD5, Digest::RMD160, Digest::SHA1, Digest::SHA256, Digest::SHA384 and
+  Digest::SHA512
+  - Note: some of them are not available if libcrypto.a does not support them on your system.
+- Digest::HMAC
+
+## Install
+ - add conf.gem line to `build_config.rb`
+
+```ruby
+MRuby::Build.new do |conf|
+
+    # ... (snip) ...
+
+    conf.gem :git => 'https://github.com/iij/mruby-digest.git'
+end
+```
+
+## Usage
+```ruby
+Digest::MD5.digest('ruby')
+Digest::MD5.hexdigest('ruby')
+```
+
+## Requirement
+- OpenSSL library (libcrypto.a) on Unix systems
+- Common Crypto library on MacOSX
+
+## License
+
+Copyright (c) 2012 Internet Initiative Japan Inc.
+
+Permission is hereby granted, free of charge, to any person obtaining a 
+copy of this software and associated documentation files (the "Software"), 
+to deal in the Software without restriction, including without limitation 
+the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+and/or sell copies of the Software, and to permit persons to whom the 
+Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in 
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+DEALINGS IN THE SOFTWARE.
+
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/mrbgem.rake mruby-1.0.0-seaos/build/mrbgems/mruby-digest/mrbgem.rake
--- mruby-1.0.0/build/mrbgems/mruby-digest/mrbgem.rake	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/mrbgem.rake	2014-06-21 11:56:38.204631092 -0700
@@ -0,0 +1,6 @@
+MRuby::Gem::Specification.new('mruby-digest') do |spec|
+  spec.license = 'MIT'
+  spec.authors = 'Internet Initiative Japan Inc.'
+
+  spec.linker.libraries << 'crypto' unless RUBY_PLATFORM =~ /darwin/
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/mrblib/digest.rb mruby-1.0.0-seaos/build/mrbgems/mruby-digest/mrblib/digest.rb
--- mruby-1.0.0/build/mrbgems/mruby-digest/mrblib/digest.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/mrblib/digest.rb	2014-06-21 11:56:38.204631092 -0700
@@ -0,0 +1,46 @@
+if Object.const_defined? :Digest
+module Digest
+  class Base
+    def self.digest(data)
+      self.new.update(data).digest
+    end
+    def self.file(path)
+      self.new.update(File.open(path).read)
+    end
+    def self.hexdigest(data)
+      self.new.update(data).hexdigest
+    end
+    def ==(other)
+      if other.kind_of? String
+        self.hexdigest == other
+      else 
+        self.digest == other.digest
+      end
+    end
+    def file(path)
+      self.update(File.open(path).read)
+    end
+    def hexdigest!
+      x = self.hexdigest
+      self.reset
+      x
+    end
+
+    alias length digest_length
+    alias size digest_length
+    alias to_s hexdigest
+    alias << update
+  end
+
+  class HMAC
+    def self.digest(data, key, digest)
+      self.new(key, digest).update(data).digest
+    end
+    def self.hexdigest(data, key, digest)
+      self.new(key, digest).update(data).hexdigest
+    end
+
+    alias << update
+  end
+end
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/run_test.rb mruby-1.0.0-seaos/build/mrbgems/mruby-digest/run_test.rb
--- mruby-1.0.0/build/mrbgems/mruby-digest/run_test.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/run_test.rb	2014-06-21 11:56:38.204631092 -0700
@@ -0,0 +1,26 @@
+#!/usr/bin/env ruby
+#
+# mrbgems test runner
+#
+
+gemname = File.basename(File.dirname(File.expand_path __FILE__))
+
+if __FILE__ == $0
+  repository, dir = 'https://github.com/mruby/mruby.git', 'tmp/mruby'
+  build_args = ARGV
+  build_args = ['all', 'test']  if build_args.nil? or build_args.empty?
+
+  Dir.mkdir 'tmp'  unless File.exist?('tmp')
+  unless File.exist?(dir)
+    system "git clone #{repository} #{dir}"
+  end
+
+  exit system(%Q[cd #{dir}; MRUBY_CONFIG=#{File.expand_path __FILE__} ruby minirake #{build_args.join(' ')}])
+end
+
+MRuby::Build.new do |conf|
+  toolchain :gcc
+  conf.gembox 'default'
+
+  conf.gem File.expand_path(File.dirname(__FILE__))
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/src/digest.c mruby-1.0.0-seaos/build/mrbgems/mruby-digest/src/digest.c
--- mruby-1.0.0/build/mrbgems/mruby-digest/src/digest.c	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/src/digest.c	2014-06-21 11:56:38.204631092 -0700
@@ -0,0 +1,809 @@
+/*
+** digest.c - Digest and subclasses
+**
+** See Copyright Notice in mruby.h
+*/
+
+#include "mruby.h"
+
+#ifdef __APPLE__
+#define USE_DIGEST_OSX_COMMONCRYPTO
+#else
+#define USE_DIGEST_OPENSSL
+#endif
+
+#if defined(USE_DIGEST_OPENSSL)
+#include <openssl/evp.h>
+#include <openssl/hmac.h>
+#include <openssl/sha.h>
+#elif defined(USE_DIGEST_OSX_COMMONCRYPTO)
+#include <CommonCrypto/CommonDigest.h>
+#include <CommonCrypto/CommonHMAC.h>
+#else
+#error "define USE_DIGEST_OPENSSL or USE_DIGEST_OSX_COMMONCRYPTO"
+#endif
+#include <stdio.h>
+#include <string.h>
+#include "mruby/array.h"
+#include "mruby/class.h"
+#include "mruby/data.h"
+#include "mruby/string.h"
+#include "mruby/variable.h"
+
+#define TYPESYM "__type__"
+
+
+/*
+ * library-independent layer API
+ */
+enum {
+	MD_TYPE_MD5,
+	MD_TYPE_RMD160,
+	MD_TYPE_SHA1,
+	MD_TYPE_SHA256,
+	MD_TYPE_SHA384,
+	MD_TYPE_SHA512,
+};
+
+struct mrb_md;
+struct mrb_hmac;
+
+static void lib_init(void);
+static int lib_md_block_length(const struct mrb_md *);
+static mrb_value lib_md_digest(mrb_state *, const struct mrb_md *);
+static mrb_value lib_md_digest_bang(mrb_state *, struct mrb_md *);
+static int lib_md_digest_length(const struct mrb_md *);
+static void lib_md_free(mrb_state *, void *);
+static void lib_md_init(mrb_state *, struct mrb_md *, int);
+static void lib_md_init_copy(mrb_state *, struct mrb_md *, struct mrb_md *);
+static void lib_md_reset(mrb_state *, struct mrb_md *);
+static void lib_md_update(mrb_state *, struct mrb_md *, unsigned char *, int);
+
+static mrb_value lib_hmac_digest(mrb_state *, const struct mrb_hmac *);
+static int lib_hmac_block_length(const struct mrb_hmac *);
+static int lib_hmac_digest_length(const struct mrb_hmac *);
+static void lib_hmac_free(mrb_state *, void *);
+static void lib_hmac_init(mrb_state *, struct mrb_hmac *, int, const unsigned char *, int);
+static void lib_hmac_update(struct mrb_hmac *, unsigned char *, int);
+
+
+#if defined(USE_DIGEST_OPENSSL)
+/*
+ * OpenSSL Implementation
+ */
+
+#define HAVE_MD5
+
+#ifndef OPENSSL_NO_RIPEMD
+#define HAVE_RMD160
+#endif
+
+#define HAVE_SHA1
+#ifdef SHA256_DIGEST_LENGTH
+#define HAVE_SHA256
+#endif
+#ifdef SHA512_DIGEST_LENGTH
+#define HAVE_SHA384
+#define HAVE_SHA512
+#endif
+
+struct mrb_md {
+  EVP_MD_CTX *ctx;
+};
+
+struct mrb_hmac {
+  HMAC_CTX ctx;
+  const EVP_MD *md;
+};
+
+static void
+lib_md_free(mrb_state *mrb, void *ptr)
+{
+  struct mrb_md *md = ptr;
+
+  if (md != NULL) {
+    if (md->ctx != NULL) {
+      EVP_MD_CTX_destroy(md->ctx);
+    }
+    mrb_free(mrb, md);
+  }
+}
+
+static void
+lib_hmac_free(mrb_state *mrb, void *ptr)
+{
+  struct mrb_hmac *hmac = ptr;
+
+  if (hmac != NULL) {
+    HMAC_CTX_cleanup(&hmac->ctx);
+    mrb_free(mrb, hmac);
+  }
+}
+
+static struct mrb_data_type mrb_md_type = { "MD", lib_md_free };
+static struct mrb_data_type mrb_hmac_type = { "HMAC", lib_hmac_free };
+
+static void
+lib_init(void)
+{
+  OpenSSL_add_all_digests();
+}
+
+static int
+lib_md_block_length(const struct mrb_md *md)
+{
+  return EVP_MD_CTX_block_size(md->ctx);
+}
+
+static mrb_value
+lib_md_digest(mrb_state *mrb, const struct mrb_md *md)
+{
+  EVP_MD_CTX ctx;
+  unsigned int mdlen;
+  unsigned char mdstr[EVP_MAX_MD_SIZE];
+
+  EVP_MD_CTX_copy(&ctx, md->ctx);
+  EVP_DigestFinal_ex(&ctx, mdstr, &mdlen);
+  return mrb_str_new(mrb, (char *)mdstr, mdlen);
+}
+
+static mrb_value
+lib_md_digest_bang(mrb_state *mrb, struct mrb_md *md)
+{
+  unsigned int mdlen;
+  unsigned char mdstr[EVP_MAX_MD_SIZE];
+
+  EVP_DigestFinal_ex(md->ctx, mdstr, &mdlen);
+  EVP_DigestInit_ex(md->ctx, EVP_MD_CTX_md(md->ctx), NULL);
+  return mrb_str_new(mrb, (char *)mdstr, mdlen);
+}
+
+static int
+lib_md_digest_length(const struct mrb_md *md)
+{
+  return EVP_MD_CTX_size(md->ctx);
+}
+
+const EVP_MD *
+md_type_md(int type)
+{
+  switch (type) {
+  case MD_TYPE_MD5:	return EVP_md5();
+#ifdef HAVE_RMD160
+  case MD_TYPE_RMD160:	return EVP_ripemd160();
+#endif
+  case MD_TYPE_SHA1:	return EVP_sha1();
+#ifdef HAVE_SHA256
+  case MD_TYPE_SHA256:	return EVP_sha256();
+#endif
+#ifdef HAVE_SHA512
+  case MD_TYPE_SHA384:	return EVP_sha384();
+  case MD_TYPE_SHA512:	return EVP_sha512();
+#endif
+  default:		return NULL;
+  }
+}
+
+static void
+lib_md_init(mrb_state *mrb, struct mrb_md *md, int type)
+{
+  const EVP_MD *evpmd;
+
+  md->ctx = NULL;
+  evpmd = md_type_md(type);
+  if (!evpmd) {
+    mrb_raise(mrb, E_NOTIMP_ERROR, "not supported");
+  }
+  md->ctx = EVP_MD_CTX_create();
+  EVP_DigestInit_ex(md->ctx, evpmd, NULL);
+}
+
+static void
+lib_md_init_copy(mrb_state *mrb, struct mrb_md *mdnew, struct mrb_md *mdold)
+{
+  mdnew->ctx = EVP_MD_CTX_create();
+  EVP_DigestInit_ex(mdnew->ctx, EVP_MD_CTX_md(mdold->ctx), NULL);
+}
+
+static void
+lib_md_reset(mrb_state *mrb, struct mrb_md *md)
+{
+  //EVP_MD_CTX_init(&md->ctx);
+  EVP_DigestInit_ex(md->ctx, EVP_MD_CTX_md(md->ctx), NULL);
+}
+
+static void
+lib_md_update(mrb_state *mrb, struct mrb_md *md, unsigned char *str, int len)
+{
+  EVP_DigestUpdate(md->ctx, str, len);
+}
+
+static mrb_value
+lib_hmac_digest(mrb_state *mrb, const struct mrb_hmac *hmac)
+{
+  HMAC_CTX ctx;
+  unsigned int mdlen;
+  unsigned char mdstr[EVP_MAX_MD_SIZE];
+
+  memcpy(&ctx, &hmac->ctx, sizeof(ctx));
+  HMAC_Final(&ctx, mdstr, &mdlen);
+  return mrb_str_new(mrb, (char *)mdstr, mdlen);
+}
+
+static int
+lib_hmac_block_length(const struct mrb_hmac *hmac)
+{
+  return EVP_MD_block_size(hmac->md);
+}
+
+static int
+lib_hmac_digest_length(const struct mrb_hmac *hmac)
+{
+  return EVP_MD_size(hmac->md);
+}
+
+static void
+lib_hmac_init(mrb_state *mrb, struct mrb_hmac *hmac, int type, const unsigned char *key, int keylen)
+{
+  hmac->md = md_type_md(type);
+  HMAC_CTX_init(&hmac->ctx);
+  HMAC_Init_ex(&hmac->ctx, key, keylen, hmac->md, NULL);
+}
+
+static void
+lib_hmac_update(struct mrb_hmac *hmac, unsigned char *data, int len)
+{
+  HMAC_Update(&hmac->ctx, data, len);
+}
+
+#elif defined(USE_DIGEST_OSX_COMMONCRYPTO)
+/*
+ * Mac OS X CommonCrypto Implementation
+ */
+
+#define HAVE_MD5
+/* #define HAVE_RMD160 */
+#define HAVE_SHA1
+#define HAVE_SHA256
+#define HAVE_SHA384
+#define HAVE_SHA512
+
+struct mrb_md {
+  int type;
+  void *ctx;
+  int ctx_size;
+};
+
+struct mrb_hmac {
+  int type;
+  CCHmacContext ctx;
+};
+
+static int
+md_ctx_size(int type)
+{
+  switch (type) {
+  case MD_TYPE_MD5:	return sizeof(CC_MD5_CTX);
+  case MD_TYPE_SHA1:	return sizeof(CC_SHA1_CTX);
+  case MD_TYPE_SHA256:	return sizeof(CC_SHA256_CTX);
+  case MD_TYPE_SHA384:	return sizeof(CC_SHA512_CTX);	/* ! */
+  case MD_TYPE_SHA512:	return sizeof(CC_SHA512_CTX);
+  default:		return 0;
+  }
+}
+
+static void
+lib_md_free(mrb_state *mrb, void *ptr)
+{
+  struct mrb_md *md = ptr;
+
+  memset(md->ctx, 0, md_ctx_size(md->type));
+  mrb_free(mrb, md->ctx);
+  mrb_free(mrb, md);
+}
+
+static void
+lib_hmac_free(mrb_state *mrb, void *ptr)
+{
+  struct mrb_hmac *hmac = ptr;
+
+  memset(&hmac->ctx, 0, sizeof(hmac->ctx));
+  mrb_free(mrb, hmac);
+}
+
+static struct mrb_data_type mrb_md_type = { "MD", lib_md_free };
+static struct mrb_data_type mrb_hmac_type = { "HMAC", lib_hmac_free };
+
+#define MAX_DIGEST_LENGTH	CC_SHA512_DIGEST_LENGTH
+
+union ctx_union {
+  CC_MD5_CTX md5;
+  CC_SHA1_CTX sha1;
+  CC_SHA256_CTX sha256;
+  /* we don't have CC_SHA384_CTX! */
+  CC_SHA512_CTX sha512;
+};
+
+static void
+lib_init(void)
+{
+}
+
+static int
+md_block_length(int type)
+{
+  switch (type) {
+  case MD_TYPE_MD5:	return CC_MD5_BLOCK_BYTES;
+  case MD_TYPE_SHA1:	return CC_SHA1_BLOCK_BYTES;
+  case MD_TYPE_SHA256:	return CC_SHA256_BLOCK_BYTES;
+  case MD_TYPE_SHA384:	return CC_SHA384_BLOCK_BYTES;
+  case MD_TYPE_SHA512:	return CC_SHA512_BLOCK_BYTES;
+  default:		return 0;
+  }
+}
+
+static int
+lib_md_block_length(const struct mrb_md *md)
+{
+  return md_block_length(md->type);
+}
+
+static void
+md_init(int type, void *ctxp)
+{
+  switch (type) {
+  case MD_TYPE_MD5:	CC_MD5_Init(ctxp);    break;
+  case MD_TYPE_SHA1:	CC_SHA1_Init(ctxp);   break;
+  case MD_TYPE_SHA256:	CC_SHA256_Init(ctxp); break;
+  case MD_TYPE_SHA384:	CC_SHA384_Init(ctxp); break;
+  case MD_TYPE_SHA512:	CC_SHA512_Init(ctxp); break;
+  default:				      break;
+  }
+}
+
+static void
+md_final(int type, unsigned char *str, void *ctx)
+{
+  switch (type) {
+  case MD_TYPE_MD5:	CC_MD5_Final(str, ctx);		break;
+  case MD_TYPE_SHA1:	CC_SHA1_Final(str, ctx);	break;
+  case MD_TYPE_SHA256:	CC_SHA256_Final(str, ctx);	break;
+  case MD_TYPE_SHA384:	CC_SHA384_Final(str, ctx);	break;
+  case MD_TYPE_SHA512:	CC_SHA512_Final(str, ctx);	break;
+  default:						break;
+  }
+}
+
+static int
+md_digest_length(int type)
+{
+  switch (type) {
+  case MD_TYPE_MD5:	return 16;
+  case MD_TYPE_SHA1:	return 20;
+  case MD_TYPE_SHA256:	return 32;
+  case MD_TYPE_SHA384:	return 48;
+  case MD_TYPE_SHA512:	return 64;
+  default:		return 0;
+  }
+}
+
+static mrb_value
+lib_md_digest(mrb_state *mrb, const struct mrb_md *md)
+{
+  union ctx_union ctx;
+  unsigned char mdstr[MAX_DIGEST_LENGTH];
+
+  memcpy(&ctx, md->ctx, md_ctx_size(md->type));
+  md_final(md->type, mdstr, &ctx);
+  return mrb_str_new(mrb, (char *)mdstr, md_digest_length(md->type));
+}
+
+static mrb_value
+lib_md_digest_bang(mrb_state *mrb, struct mrb_md *md)
+{
+  unsigned char mdstr[MAX_DIGEST_LENGTH];
+
+  md_final(md->type, mdstr, md->ctx);
+  md_init(md->type, md->ctx);
+  return mrb_str_new(mrb, (char *)mdstr, md_digest_length(md->type));
+}
+
+static int
+lib_md_digest_length(const struct mrb_md *md)
+{
+  return md_digest_length(md->type);
+}
+
+static void
+lib_md_init(mrb_state *mrb, struct mrb_md *md, int type)
+{
+  int ctxsize;
+
+  ctxsize = md_ctx_size(type);
+  if (ctxsize == 0) {
+    mrb_raise(mrb, E_NOTIMP_ERROR, "not supported");
+  }
+  md->type = type;
+  md->ctx = NULL;
+  md->ctx = mrb_malloc(mrb, ctxsize);
+  md_init(type, md->ctx);
+}
+
+static void
+lib_md_init_copy(mrb_state *mrb, struct mrb_md *mdnew, struct mrb_md *mdold)
+{
+  lib_md_init(mrb, mdnew, mdold->type);
+}
+
+static void
+lib_md_reset(mrb_state *mrb, struct mrb_md *md)
+{
+  md_init(md->type, md->ctx);
+}
+
+static void
+lib_md_update(mrb_state *mrb, struct mrb_md *md, unsigned char *data, int len)
+{
+  switch (md->type) {
+  case MD_TYPE_MD5:	CC_MD5_Update(md->ctx, data, len);	break;
+  case MD_TYPE_SHA1:	CC_SHA1_Update(md->ctx, data, len);	break;
+  case MD_TYPE_SHA256:	CC_SHA256_Update(md->ctx, data, len);	break;
+  case MD_TYPE_SHA384:	CC_SHA384_Update(md->ctx, data, len);	break;
+  case MD_TYPE_SHA512:	CC_SHA512_Update(md->ctx, data, len);	break;
+  default: break;
+  }
+}
+
+static int
+lib_hmac_block_length(const struct mrb_hmac *hmac)
+{
+  return md_block_length(hmac->type);
+}
+
+static mrb_value
+lib_hmac_digest(mrb_state *mrb, const struct mrb_hmac *hmac)
+{
+  CCHmacContext ctx;
+  unsigned char str[MAX_DIGEST_LENGTH];
+
+  memcpy(&ctx, &hmac->ctx, sizeof(ctx));
+  CCHmacFinal(&ctx, str);
+  return mrb_str_new(mrb, (const char *)str, md_digest_length(hmac->type));
+}
+
+static int
+lib_hmac_digest_length(const struct mrb_hmac *hmac)
+{
+  return md_digest_length(hmac->type);
+}
+
+static void
+lib_hmac_init(mrb_state *mrb, struct mrb_hmac *hmac, int type, const unsigned char *key, int keylen)
+{
+  CCHmacAlgorithm algorithm;
+
+  switch (type) {
+  case MD_TYPE_MD5:    algorithm = kCCHmacAlgMD5;    break;
+  case MD_TYPE_SHA1:   algorithm = kCCHmacAlgSHA1;   break;
+  case MD_TYPE_SHA256: algorithm = kCCHmacAlgSHA256; break;
+  case MD_TYPE_SHA384: algorithm = kCCHmacAlgSHA384; break;
+  case MD_TYPE_SHA512: algorithm = kCCHmacAlgSHA512; break;
+  default:					     break;
+  }
+  hmac->type = type;
+  CCHmacInit(&hmac->ctx, algorithm, key, keylen);
+}
+
+static void
+lib_hmac_update(struct mrb_hmac *hmac, unsigned char *data, int len)
+{
+  CCHmacUpdate(&hmac->ctx, data, len);
+}
+
+#endif
+
+static void
+basecheck(mrb_state *mrb, mrb_value self, struct mrb_md **mdp)
+{
+  struct RClass *c;
+  struct mrb_md *md;
+  mrb_value t;
+
+  c = mrb_obj_class(mrb, self);
+  t = mrb_const_get(mrb, mrb_obj_value(c), mrb_intern_lit(mrb, TYPESYM));
+  if (mrb_nil_p(t)) {
+    mrb_raise(mrb, E_NOTIMP_ERROR, "Digest::Base is an abstract class");
+  }
+  md = (struct mrb_md *)DATA_PTR(self);
+  if (!md) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "no md found (BUG?)");
+  }
+  if (mdp) *mdp = md;
+}
+
+static mrb_value
+mrb_digest_block_length(mrb_state *mrb, mrb_value self)
+{
+  struct mrb_md *md;
+
+  basecheck(mrb, self, &md);
+  return mrb_fixnum_value(lib_md_block_length(md));
+}
+
+static mrb_value
+mrb_digest_digest(mrb_state *mrb, mrb_value self)
+{
+  struct mrb_md *md;
+
+  md = (struct mrb_md *)DATA_PTR(self);
+  if (!md) return mrb_nil_value();
+  return lib_md_digest(mrb, md);
+}
+
+static mrb_value
+mrb_digest_digest_bang(mrb_state *mrb, mrb_value self)
+{
+  struct mrb_md *md;
+
+  md = (struct mrb_md *)DATA_PTR(self);
+  if (!md) return mrb_nil_value();
+  return lib_md_digest_bang(mrb, md);
+}
+
+static mrb_value
+mrb_digest_digest_length(mrb_state *mrb, mrb_value self)
+{
+  struct mrb_md *md;
+
+  basecheck(mrb, self, &md);
+  return mrb_fixnum_value(lib_md_digest_length(md));
+}
+
+static mrb_value
+digest2hexdigest(mrb_state *mrb, mrb_value b)
+{
+  mrb_value h;
+  int i, len;
+  char *bp, buf[3];
+
+  bp = RSTRING_PTR(b);
+  len = RSTRING_LEN(b);
+  h = mrb_str_buf_new(mrb, len * 2);
+  for (i = 0; i < len; i++) {
+    snprintf(buf, sizeof(buf), "%02x", (unsigned char )bp[i]);
+    mrb_str_buf_cat(mrb, h, buf, 2);
+  }
+  return h;
+}
+
+static mrb_value
+mrb_digest_hexdigest(mrb_state *mrb, mrb_value self)
+{
+  return digest2hexdigest(mrb, mrb_digest_digest(mrb, self));
+}
+
+static mrb_value
+mrb_digest_init(mrb_state *mrb, mrb_value self)
+{
+  struct RClass *c;
+  struct mrb_md *md;
+  mrb_value t;
+
+  md = (struct mrb_md *)DATA_PTR(self);
+  if (md) {
+    lib_md_free(mrb, md);
+  }
+  DATA_TYPE(self) = &mrb_md_type;
+  DATA_PTR(self) = NULL;
+
+  c = mrb_obj_class(mrb, self);
+  if (!mrb_const_defined(mrb, mrb_obj_value(c), mrb_intern_lit(mrb, TYPESYM))) {
+    mrb_raise(mrb, E_NOTIMP_ERROR, "Digest::Base is an abstract class");
+  }
+  t = mrb_const_get(mrb, mrb_obj_value(c), mrb_intern_lit(mrb, TYPESYM));
+#if 0
+  if (lib_md_supported(t)) {
+    mrb_raise(mrb, E_NOTIMP_ERROR, "unknown algorithm");
+  }
+#endif
+
+  md = (struct mrb_md *)mrb_malloc(mrb, sizeof(*md));
+  DATA_PTR(self) = md;
+  lib_md_init(mrb, md, mrb_fixnum(t));
+  return self;
+}
+
+static mrb_value
+mrb_digest_init_copy(mrb_state *mrb, mrb_value copy)
+{
+  struct mrb_md *m1, *m2;
+  mrb_value src;
+
+  mrb_get_args(mrb, "o", &src);
+  if (mrb_obj_equal(mrb, copy, src)) return copy;
+  if (!mrb_obj_is_instance_of(mrb, src, mrb_obj_class(mrb, copy))) {
+    mrb_raise(mrb, E_TYPE_ERROR, "wrong argument class");
+  }
+  if (!DATA_PTR(copy)) {
+    DATA_PTR(copy) = mrb_malloc(mrb, sizeof(struct mrb_md));
+    DATA_TYPE(copy) = &mrb_md_type;
+  }
+  m1 = DATA_PTR(src);
+  m2 = DATA_PTR(copy);
+  lib_md_init_copy(mrb, m2, m1);
+  return copy;
+}
+
+static mrb_value
+mrb_digest_reset(mrb_state *mrb, mrb_value self)
+{
+  struct mrb_md *md;
+
+  md = (struct mrb_md *)DATA_PTR(self);
+  if (!md) return mrb_nil_value();
+  lib_md_reset(mrb, md);
+  return self;
+}
+
+static mrb_value
+mrb_digest_update(mrb_state *mrb, mrb_value self)
+{
+  struct mrb_md *md;
+  int len;
+  char *str;
+
+  md = (struct mrb_md *)DATA_PTR(self);
+  if (!md) return mrb_nil_value();
+  mrb_get_args(mrb, "s", &str, &len);
+  lib_md_update(mrb, md, (unsigned char *)str, len);
+  return self;
+}
+
+static mrb_value
+mrb_hmac_block_length(mrb_state *mrb, mrb_value self)
+{
+  struct mrb_hmac *hmac;
+
+  hmac = (struct mrb_hmac *)DATA_PTR(self);
+  if (!hmac) return mrb_nil_value();
+  return mrb_fixnum_value(lib_hmac_block_length(hmac));
+}
+
+static mrb_value
+mrb_hmac_digest(mrb_state *mrb, mrb_value self)
+{
+  struct mrb_hmac *hmac;
+
+  hmac = (struct mrb_hmac *)DATA_PTR(self);
+  if (!hmac) return mrb_nil_value();
+  return lib_hmac_digest(mrb, hmac);
+}
+
+static mrb_value
+mrb_hmac_digest_length(mrb_state *mrb, mrb_value self)
+{
+  struct mrb_hmac *hmac;
+
+  hmac = (struct mrb_hmac *)DATA_PTR(self);
+  if (!hmac) return mrb_nil_value();
+  return mrb_fixnum_value(lib_hmac_digest_length(hmac));
+}
+
+static mrb_value
+mrb_hmac_hexdigest(mrb_state *mrb, mrb_value self)
+{
+  return digest2hexdigest(mrb, mrb_hmac_digest(mrb, self));
+}
+
+static mrb_value
+mrb_hmac_init(mrb_state *mrb, mrb_value self)
+{
+  struct mrb_hmac *hmac;
+  mrb_value digest, t;
+  int keylen;
+  char *key;
+
+  hmac = (struct mrb_hmac *)DATA_PTR(self);
+  if (hmac) {
+    lib_hmac_free(mrb, hmac);
+  }
+  DATA_TYPE(self) = &mrb_hmac_type;
+  DATA_PTR(self) = NULL;
+
+  mrb_get_args(mrb, "so", &key, &keylen, &digest);
+  t = mrb_const_get(mrb, digest, mrb_intern_lit(mrb, TYPESYM));
+  if (mrb_nil_p(t)) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "not a digester");
+  }
+
+  hmac = (struct mrb_hmac *)mrb_malloc(mrb, sizeof(*hmac));
+  DATA_PTR(self) = hmac;
+  lib_hmac_init(mrb, hmac, mrb_fixnum(t), (unsigned char *)key, keylen);
+  return self;
+}
+
+static mrb_value
+mrb_hmac_init_copy(mrb_state *mrb, mrb_value copy)
+{
+  mrb_raise(mrb, E_RUNTIME_ERROR, "cannot duplicate HMAC");
+  return copy;
+}
+
+static mrb_value
+mrb_hmac_update(mrb_state *mrb, mrb_value self)
+{
+  struct mrb_hmac *hmac;
+  int len;
+  char *str;
+
+  hmac = (struct mrb_hmac *)DATA_PTR(self);
+  if (!hmac) return mrb_nil_value();
+  mrb_get_args(mrb, "s", &str, &len);
+  lib_hmac_update(hmac, (unsigned char *)str, len);
+  return self;
+}
+
+
+void
+mrb_mruby_digest_gem_init(mrb_state *mrb)
+{
+  struct RClass *b, *d, *h;
+
+  lib_init();
+
+  d = mrb_define_module(mrb, "Digest");
+
+  b = mrb_define_class_under(mrb, d, "Base", mrb->object_class);
+  mrb_define_method(mrb, b, "block_length",    mrb_digest_block_length,  MRB_ARGS_NONE());
+  mrb_define_method(mrb, b, "digest",          mrb_digest_digest,        MRB_ARGS_NONE());
+  mrb_define_method(mrb, b, "digest!",         mrb_digest_digest_bang,   MRB_ARGS_NONE()); /* XXX: can be defined in mrblib... */
+  mrb_define_method(mrb, b, "digest_length",   mrb_digest_digest_length, MRB_ARGS_NONE());
+  //mrb_define_method(mrb, b, "file",            mrb_digest_file,          MRB_ARGS_REQ(1));
+  mrb_define_method(mrb, b, "hexdigest",       mrb_digest_hexdigest,     MRB_ARGS_NONE());
+  //mrb_define_method(mrb, b, "hexdigest!",      mrb_digest_hexdigest_bang, MRB_ARGS_NONE()); /* XXX: can be defined in mrblib... */
+  mrb_define_method(mrb, b, "initialize",      mrb_digest_init,          MRB_ARGS_NONE());
+  mrb_define_method(mrb, b, "initialize_copy", mrb_digest_init_copy,     MRB_ARGS_REQ(1));
+  mrb_define_method(mrb, b, "reset",           mrb_digest_reset,         MRB_ARGS_NONE());
+  mrb_define_method(mrb, b, "update",          mrb_digest_update,        MRB_ARGS_REQ(1));
+
+#define DEFCLASS(n)						\
+do {								\
+  struct RClass *a = mrb_define_class_under(mrb, d, #n, b);	\
+  MRB_SET_INSTANCE_TT(a, MRB_TT_DATA);				\
+  mrb_define_const(mrb, a, TYPESYM, mrb_fixnum_value(MD_TYPE_##n));	\
+} while (0)
+
+#ifdef HAVE_MD5
+  DEFCLASS(MD5);
+#endif
+#ifdef HAVE_RMD160
+  DEFCLASS(RMD160);
+#endif
+#ifdef HAVE_SHA1
+  DEFCLASS(SHA1);
+#endif
+#ifdef HAVE_SHA256
+  DEFCLASS(SHA256);
+#endif
+#ifdef HAVE_SHA384
+  DEFCLASS(SHA384);
+#endif
+#ifdef HAVE_SHA512
+  DEFCLASS(SHA512);
+#endif
+
+  h = mrb_define_class_under(mrb, d, "HMAC", mrb->object_class);
+  MRB_SET_INSTANCE_TT(h, MRB_TT_DATA);
+  mrb_define_method(mrb, h, "block_length",    mrb_hmac_block_length,  MRB_ARGS_NONE());
+  mrb_define_method(mrb, h, "digest",          mrb_hmac_digest,        MRB_ARGS_NONE());
+  mrb_define_method(mrb, h, "digest_length",   mrb_hmac_digest_length, MRB_ARGS_NONE());
+  mrb_define_method(mrb, h, "hexdigest",       mrb_hmac_hexdigest,     MRB_ARGS_NONE());
+  mrb_define_method(mrb, h, "initialize",      mrb_hmac_init,          MRB_ARGS_REQ(2));
+  mrb_define_method(mrb, h, "initialize_copy", mrb_hmac_init_copy,     MRB_ARGS_REQ(1));
+  mrb_define_method(mrb, h, "update",          mrb_hmac_update,        MRB_ARGS_REQ(1));
+}
+
+void
+mrb_mruby_digest_gem_final(mrb_state *mrb)
+{
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-digest/test/digest.rb mruby-1.0.0-seaos/build/mrbgems/mruby-digest/test/digest.rb
--- mruby-1.0.0/build/mrbgems/mruby-digest/test/digest.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-digest/test/digest.rb	2014-06-21 11:56:38.204631092 -0700
@@ -0,0 +1,203 @@
+##
+# Digest Test
+
+if Object.const_defined?(:Digest)
+  assert('Digest') do
+    Digest.class == Module
+  end
+
+  assert('Digest::Base') do
+    Digest::Base.class == Class
+  end
+
+  assert('Digest::Base#new') do
+    e1 = nil
+    begin
+      Digest::Base.new
+    rescue NotImplementedError => e
+      e1 = e
+    end
+    e1.class == NotImplementedError
+  end
+
+  assert('Digest::MD5') do
+    Digest::MD5.class == Class
+  end
+
+  assert('Digest::MD5 superclass') do
+    Digest::MD5.superclass == Digest::Base
+  end
+
+  assert('Digest::MD5.digest') do
+    Digest::MD5.digest('ruby') == "X\xE5=\x13$\xEE\xF6&_\xDB\x97\xB0\x8E\xD9\xAA\xDF"
+  end
+
+  #assert('Digest::MD5.file')
+
+  assert('Digest::MD5.hexdigest') do
+    Digest::MD5.hexdigest('ruby') == "58e53d1324eef6265fdb97b08ed9aadf"
+  end
+
+  assert('Digest::MD5#update') do
+    d = Digest::MD5.new
+    d.update('ruby')
+    d.hexdigest == "58e53d1324eef6265fdb97b08ed9aadf"
+  end
+
+  assert('Digest::MD5#update 2') do
+    d = Digest::MD5.new
+    d.update('ruby')
+    d.update('digest')
+    d.hexdigest == "2ac1b3e3db06239e3244817f281450f1"
+  end
+
+  assert('Digest::MD5#<<') do
+    a = Digest::MD5.new
+    b = Digest::MD5.new
+    a.update('ruby')
+    b << "r" << "u" << "b" << "y"
+    a.hexdigest == b.hexdigest
+  end
+
+  assert('Digest::MD5#== with Digest::XXX') do
+    x1 = Digest::MD5.new.update("ruby")
+    x2 = Digest::MD5.new.update("ruby")
+    x3 = Digest::MD5.new.update("RUBY")
+    (x1 == x2) == true and
+    (x1 == x3) == false
+  end
+
+  assert('Digest::MD5#== with String') do
+    Digest::MD5.new.update("ruby") == "58e53d1324eef6265fdb97b08ed9aadf"
+  end
+
+  assert('Digest::MD5#block_length') do
+    Digest::MD5.new.block_length == 64
+  end
+
+  assert('Digest::MD5#digest') do
+    Digest::MD5.new.update("ruby").digest == "X\xE5=\x13$\xEE\xF6&_\xDB\x97\xB0\x8E\xD9\xAA\xDF"
+  end
+
+  assert('Digest::MD5#digest!') do
+    d = Digest::MD5.new.update("ruby")
+    d.digest!
+    #d.digest! == "\xD4\x1D\x8C\xD9\x8F\x00\xB2\x04\xE9\x80\t\x98\xEC\xF8B~"
+    # XXX: mrbtest dumps core!
+    d.digest! == Digest::MD5.new.digest
+  end
+
+  assert('Digest::MD5#digest_length') do
+    d = Digest::MD5.new
+    n = 16
+    d.digest_length == n and
+    d.length == n and
+    d.size == n
+  end
+
+  #assert('Digest::MD5#file')
+
+  assert('Digest::MD5#hexdigest') do
+    d = Digest::MD5.new.update("ruby")
+    s = "58e53d1324eef6265fdb97b08ed9aadf"
+    d.hexdigest == s and
+    d.to_s == s
+  end
+
+  assert('Digest::MD5#hexdigest!') do
+    d = Digest::MD5.new.update("ruby")
+    d.hexdigest!
+    d.hexdigest! == "d41d8cd98f00b204e9800998ecf8427e"
+  end
+
+  assert('Digest::MD5#reset') do
+    d = Digest::MD5.new.update("ruby")
+    d.reset
+    d.hexdigest! == "d41d8cd98f00b204e9800998ecf8427e"
+  end
+
+  if Digest.const_defined? :RMD160
+    assert('Digest::RMD160#hexdigest') do
+      d = Digest::RMD160.new.update("ruby")
+      s = "29d9b710bc50866fa2399c3061cd02c0c8ffa197"
+      d.hexdigest == s
+    end
+  end
+
+  if Digest.const_defined? :SHA1
+    assert('Digest::SHA1#hexdigest') do
+      d = Digest::SHA1.new.update("ruby")
+      s = "18e40e1401eef67e1ae69efab09afb71f87ffb81"
+      d.hexdigest == s
+    end
+  end
+
+  if Digest.const_defined? :SHA256
+    assert('Digest::SHA256#hexdigest') do
+      d = Digest::SHA256.new.update("ruby")
+      s = "b9138194ffe9e7c8bb6d79d1ed56259553d18d9cb60b66e3ba5aa2e5b078055a"
+      d.hexdigest == s
+    end
+  end
+
+  if Digest.const_defined? :SHA384
+    assert('Digest::SHA384#hexdigest') do
+      d = Digest::SHA384.new.update("ruby")
+      s = "635365ef93ebf2c7a4e40b0b497da727ab8c2914eb9f052e6be40476f95d3daf44786790f5f0e843fab419b43022e069"
+      d.hexdigest == s
+    end
+  end
+
+  if Digest.const_defined? :SHA512
+    assert('Digest::SHA512#hexdigest') do
+      d = Digest::SHA512.new.update("ruby")
+      s = "423408d7723a3d80baefa804bd50b61a89667efec1713386a7b8efe28e5d13968307a908778cad210d7aa2dfe7db9a2aa86895f9fc1eeefcc99814310b207a6b"
+      d.hexdigest == s
+    end
+  end
+
+  assert('Digest::HMAC') do
+    Digest::HMAC.class == Class
+  end
+
+  assert('Digest::HMAC.digest') do
+    Digest::HMAC.digest("data", "hash key", Digest::SHA1) == "\xFD \xECC=\xFD\x97\x0E\xEC!FW\xCF\xB5Gl]\x913f"
+  end
+
+  assert('Digest::HMAC.hexdigest') do
+    Digest::HMAC.hexdigest("data", "hash key", Digest::SHA1) == "fd20ec433dfd970eec214657cfb5476c5d913366"
+  end
+
+  assert('Digest::HMAC#<<') do
+    a = Digest::HMAC.new('hash key', Digest::SHA1)
+    b = Digest::HMAC.new('hash key', Digest::SHA1)
+    a.update('ruby')
+    b << "r" << "u" << "b" << "y"
+    a.hexdigest == b.hexdigest
+  end
+
+  assert('Digest::HMAC#block_length') do
+    d = Digest::HMAC.new("hash key", Digest::SHA1)
+    d.block_length == 64
+  end
+
+  assert('Digest::HMAC#digest_length') do
+    d = Digest::HMAC.new("hash key", Digest::SHA1)
+    d.digest_length == 20
+  end
+
+  # assert('Digest::HMAC#reset')
+
+  assert('Digest::HMAC#update') do
+    d = Digest::HMAC.new("hash key", Digest::SHA1)
+    d.update('data')
+    d.hexdigest == "fd20ec433dfd970eec214657cfb5476c5d913366"
+  end
+
+  assert('Digest::HMAC#update 2') do
+    d = Digest::HMAC.new("hash key", Digest::SHA1)
+    d.update('ruby')
+    d.update('digest')
+    d.hexdigest == "e4be3728777e43deba3aa522a4247ea83b19a1c7"
+  end
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/HEAD	2014-06-20 19:34:26.440780443 -0700
@@ -0,0 +1 @@
+ref: refs/heads/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/config mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/config
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/config	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/config	2014-06-20 19:34:26.440780443 -0700
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = https://github.com/iij/mruby-dir.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/description mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/description
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/description	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/description	2014-06-20 19:34:25.474111105 -0700
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/applypatch-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/applypatch-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/applypatch-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/applypatch-msg.sample	2014-06-20 19:34:25.474111105 -0700
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/commit-msg" &&
+	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
+:
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/commit-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/commit-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/commit-msg.sample	2014-06-20 19:34:25.474111105 -0700
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/post-update.sample mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/post-update.sample
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/post-update.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/post-update.sample	2014-06-20 19:34:25.474111105 -0700
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/pre-applypatch.sample mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/pre-applypatch.sample
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/pre-applypatch.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/pre-applypatch.sample	2014-06-20 19:34:25.474111105 -0700
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
+:
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/pre-commit.sample mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/pre-commit.sample
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/pre-commit.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/pre-commit.sample	2014-06-20 19:34:25.474111105 -0700
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/pre-push.sample mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/pre-push.sample
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/pre-push.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/pre-push.sample	2014-06-20 19:34:25.474111105 -0700
@@ -0,0 +1,54 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+IFS=' '
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/pre-rebase.sample mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/pre-rebase.sample
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/pre-rebase.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/pre-rebase.sample	2014-06-20 19:34:25.474111105 -0700
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up-to-date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+exit 0
+
+################################################################
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/prepare-commit-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/prepare-commit-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/prepare-commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/prepare-commit-msg.sample	2014-06-20 19:34:25.474111105 -0700
@@ -0,0 +1,36 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples.  The first comments out the
+# "Conflicts:" part of a merge commit.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+case "$2,$3" in
+  merge,)
+    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
+
+# ,|template,)
+#   /usr/bin/perl -i.bak -pe '
+#      print "\n" . `git diff --cached --name-status -r`
+#	 if /^#/ && $first++ == 0' "$1" ;;
+
+  *) ;;
+esac
+
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/update.sample mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/update.sample
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/hooks/update.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/hooks/update.sample	2014-06-20 19:34:25.474111105 -0700
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to blocks unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
Binary files mruby-1.0.0/build/mrbgems/mruby-dir/.git/index and mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/index differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/info/exclude mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/info/exclude
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/info/exclude	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/info/exclude	2014-06-20 19:34:25.474111105 -0700
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/logs/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/logs/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/logs/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/logs/HEAD	2014-06-20 19:34:26.440780443 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 6cc24d07935a265df6edad4352ece1b1c3aca8dc Daniel Bittman <danielbittman1@gmail.com> 1403318066 -0700	clone: from https://github.com/iij/mruby-dir.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/logs/refs/heads/master mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/logs/refs/heads/master
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/logs/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/logs/refs/heads/master	2014-06-20 19:34:26.440780443 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 6cc24d07935a265df6edad4352ece1b1c3aca8dc Daniel Bittman <danielbittman1@gmail.com> 1403318066 -0700	clone: from https://github.com/iij/mruby-dir.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/logs/refs/remotes/origin/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/logs/refs/remotes/origin/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/logs/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/logs/refs/remotes/origin/HEAD	2014-06-20 19:34:26.440780443 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 6cc24d07935a265df6edad4352ece1b1c3aca8dc Daniel Bittman <danielbittman1@gmail.com> 1403318066 -0700	clone: from https://github.com/iij/mruby-dir.git
Binary files mruby-1.0.0/build/mrbgems/mruby-dir/.git/objects/pack/pack-1b59e4adf4d6fa1299a1178680b353824f6965f5.idx and mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/objects/pack/pack-1b59e4adf4d6fa1299a1178680b353824f6965f5.idx differ
Binary files mruby-1.0.0/build/mrbgems/mruby-dir/.git/objects/pack/pack-1b59e4adf4d6fa1299a1178680b353824f6965f5.pack and mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/objects/pack/pack-1b59e4adf4d6fa1299a1178680b353824f6965f5.pack differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/packed-refs mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/packed-refs
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/packed-refs	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/packed-refs	2014-06-20 19:34:26.440780443 -0700
@@ -0,0 +1,2 @@
+# pack-refs with: peeled fully-peeled 
+6cc24d07935a265df6edad4352ece1b1c3aca8dc refs/remotes/origin/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/refs/heads/master mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/refs/heads/master
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/refs/heads/master	2014-06-20 19:34:26.440780443 -0700
@@ -0,0 +1 @@
+6cc24d07935a265df6edad4352ece1b1c3aca8dc
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.git/refs/remotes/origin/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/refs/remotes/origin/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-dir/.git/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.git/refs/remotes/origin/HEAD	2014-06-20 19:34:26.440780443 -0700
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.gitignore mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.gitignore
--- mruby-1.0.0/build/mrbgems/mruby-dir/.gitignore	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.gitignore	2014-06-20 19:34:26.457447156 -0700
@@ -0,0 +1,5 @@
+gem_*
+gem-*
+mrb-*.a
+src/*.o
+/tmp
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/.travis.yml mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.travis.yml
--- mruby-1.0.0/build/mrbgems/mruby-dir/.travis.yml	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/.travis.yml	2014-06-20 19:34:26.457447156 -0700
@@ -0,0 +1,2 @@
+script:
+  - "ruby run_test.rb all test"
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/README.md mruby-1.0.0-seaos/build/mrbgems/mruby-dir/README.md
--- mruby-1.0.0/build/mrbgems/mruby-dir/README.md	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/README.md	2014-06-20 19:34:26.457447156 -0700
@@ -0,0 +1,56 @@
+mruby-dir
+=========
+
+Dir class for mruby.  Supported methods are:
+
+`.chdir`
+`.delete`
+`.entries`
+`.exist?`
+`.foreach`
+`.getwd`
+`.mkdir`
+`.open`
+`#close`
+`#each`
+`#read`
+`#rewind`
+`#seek`
+`#tell`
+
+
+## License
+
+Copyright (c) 2012 Internet Initiative Japan Inc.
+
+Permission is hereby granted, free of charge, to any person obtaining a 
+copy of this software and associated documentation files (the "Software"), 
+to deal in the Software without restriction, including without limitation 
+the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+and/or sell copies of the Software, and to permit persons to whom the 
+Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in 
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+DEALINGS IN THE SOFTWARE.
+
+
+- On Windows platforms, you must agree on addional license too:
+
+Copyright Kevlin Henney, 1997, 2003, 2012. All rights reserved.
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose is hereby granted without fee, provided
+that this copyright and permissions notice appear in all copies and
+derivatives.
+
+This software is supplied "as is" without express or implied warranty.
+
+But that said, if there are any problems please get in touch.
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/mrbgem.rake mruby-1.0.0-seaos/build/mrbgems/mruby-dir/mrbgem.rake
--- mruby-1.0.0/build/mrbgems/mruby-dir/mrbgem.rake	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/mrbgem.rake	2014-06-20 19:34:26.457447156 -0700
@@ -0,0 +1,15 @@
+MRuby::Gem::Specification.new('mruby-dir') do |spec|
+  spec.license = 'MIT'
+  spec.authors = [ 'Internet Initiative Japan Inc.' ]
+
+  spec.cc.include_paths << "#{build.root}/src"
+  
+  case RUBY_PLATFORM
+  when /mingw|mswin/
+    spec.license = 'MIT and MIT-like license'
+    spec.authors += [ 'Kevlin Henney' ]
+    spec.objs += Dir.glob("#{dir}/src/Win/*.{c,cpp,m,asm,S}").map { |f| 
+      objfile(f.relative_path_from(dir).pathmap("#{build_dir}/%X")) 
+    }
+  end
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/mrblib/dir.rb mruby-1.0.0-seaos/build/mrbgems/mruby-dir/mrblib/dir.rb
--- mruby-1.0.0/build/mrbgems/mruby-dir/mrblib/dir.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/mrblib/dir.rb	2014-06-20 19:34:26.457447156 -0700
@@ -0,0 +1,64 @@
+class Dir
+  def each(&block)
+    while s = self.read
+      block.call(s)
+    end
+    self
+  end
+
+  alias pos tell
+  alias pos= seek
+
+  def self.entries(path)
+    a = []
+      self.open(path) { |d|
+      while s = d.read
+        a << s
+      end
+    }
+    a
+  end
+
+  def self.foreach(path, &block)
+    if block
+      self.open(path).each { |f| block.call(f) }
+    else
+      self.open(path).each
+    end
+  end
+
+  def self.open(path, &block)
+    if block
+      d = self.new(path)
+      begin
+        block.call(d)
+      ensure
+        d.close
+      end
+    else
+      self.new(path)
+    end
+  end
+
+  def self.chdir(path, &block)
+    my = self # workaround for https://github.com/mruby/mruby/issues/1579
+    if block
+      wd = self.getwd
+      begin
+        self._chdir(path)
+        block.call(path)
+      ensure
+        my._chdir(wd)
+      end
+    else
+      self._chdir(path)
+    end
+  end
+
+  class << self
+    alias exists? exist?
+    alias pwd getwd
+    alias rmdir delete
+    alias unlink delete
+  end
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/run_test.rb mruby-1.0.0-seaos/build/mrbgems/mruby-dir/run_test.rb
--- mruby-1.0.0/build/mrbgems/mruby-dir/run_test.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/run_test.rb	2014-06-20 19:34:26.457447156 -0700
@@ -0,0 +1,26 @@
+#!/usr/bin/env ruby
+#
+# mrbgems test runner
+#
+
+gemname = File.basename(File.dirname(File.expand_path __FILE__))
+
+if __FILE__ == $0
+  repository, dir = 'https://github.com/mruby/mruby.git', 'tmp/mruby'
+  build_args = ARGV
+  build_args = ['all', 'test']  if build_args.nil? or build_args.empty?
+
+  Dir.mkdir 'tmp'  unless File.exist?('tmp')
+  unless File.exist?(dir)
+    system "git clone #{repository} #{dir}"
+  end
+
+  exit system(%Q[cd #{dir}; MRUBY_CONFIG=#{File.expand_path __FILE__} ruby minirake #{build_args.join(' ')}])
+end
+
+MRuby::Build.new do |conf|
+  toolchain :gcc
+  conf.gembox 'default'
+
+  conf.gem File.expand_path(File.dirname(__FILE__))
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/src/Win/dirent.c mruby-1.0.0-seaos/build/mrbgems/mruby-dir/src/Win/dirent.c
--- mruby-1.0.0/build/mrbgems/mruby-dir/src/Win/dirent.c	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/src/Win/dirent.c	2014-06-20 19:34:26.457447156 -0700
@@ -0,0 +1,148 @@
+/*
+
+    Implementation of POSIX directory browsing functions and types for Win32.
+
+    Author:  Kevlin Henney (kevlin@acm.org, kevlin@curbralan.com)
+    History: Created March 1997. Updated June 2003 and July 2012.
+    Rights:  See end of file.
+
+*/
+
+#include "dirent.h"
+#include <errno.h>
+#include <io.h> /* _findfirst and _findnext set errno iff they return -1 */
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+typedef ptrdiff_t handle_type; /* C99's intptr_t not sufficiently portable */
+
+struct DIR
+{
+    handle_type         handle; /* -1 for failed rewind */
+    struct _finddata_t  info;
+    struct dirent       result; /* d_name null iff first time */
+    char                *name;  /* null-terminated char string */
+};
+
+DIR *opendir(const char *name)
+{
+    DIR *dir = 0;
+
+    if(name && name[0])
+    {
+        size_t base_length = strlen(name);
+        const char *all = /* search pattern must end with suitable wildcard */
+            strchr("/\\", name[base_length - 1]) ? "*" : "/*";
+
+        if((dir = (DIR *) malloc(sizeof *dir)) != 0 &&
+           (dir->name = (char *) malloc(base_length + strlen(all) + 1)) != 0)
+        {
+            strcat(strcpy(dir->name, name), all);
+
+            if((dir->handle =
+                (handle_type) _findfirst(dir->name, &dir->info)) != -1)
+            {
+                dir->result.d_name = 0;
+            }
+            else /* rollback */
+            {
+                free(dir->name);
+                free(dir);
+                dir = 0;
+            }
+        }
+        else /* rollback */
+        {
+            free(dir);
+            dir   = 0;
+            errno = ENOMEM;
+        }
+    }
+    else
+    {
+        errno = EINVAL;
+    }
+
+    return dir;
+}
+
+int closedir(DIR *dir)
+{
+    int result = -1;
+
+    if(dir)
+    {
+        if(dir->handle != -1)
+        {
+            result = _findclose(dir->handle);
+        }
+
+        free(dir->name);
+        free(dir);
+    }
+
+    if(result == -1) /* map all errors to EBADF */
+    {
+        errno = EBADF;
+    }
+
+    return result;
+}
+
+struct dirent *readdir(DIR *dir)
+{
+    struct dirent *result = 0;
+
+    if(dir && dir->handle != -1)
+    {
+        if(!dir->result.d_name || _findnext(dir->handle, &dir->info) != -1)
+        {
+            result         = &dir->result;
+            result->d_name = dir->info.name;
+        }
+    }
+    else
+    {
+        errno = EBADF;
+    }
+
+    return result;
+}
+
+void rewinddir(DIR *dir)
+{
+    if(dir && dir->handle != -1)
+    {
+        _findclose(dir->handle);
+        dir->handle = (handle_type) _findfirst(dir->name, &dir->info);
+        dir->result.d_name = 0;
+    }
+    else
+    {
+        errno = EBADF;
+    }
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+/*
+
+    Copyright Kevlin Henney, 1997, 2003, 2012. All rights reserved.
+
+    Permission to use, copy, modify, and distribute this software and its
+    documentation for any purpose is hereby granted without fee, provided
+    that this copyright and permissions notice appear in all copies and
+    derivatives.
+    
+    This software is supplied "as is" without express or implied warranty.
+
+    But that said, if there are any problems please get in touch.
+
+*/
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/src/Win/dirent.h mruby-1.0.0-seaos/build/mrbgems/mruby-dir/src/Win/dirent.h
--- mruby-1.0.0/build/mrbgems/mruby-dir/src/Win/dirent.h	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/src/Win/dirent.h	2014-06-20 19:34:26.457447156 -0700
@@ -0,0 +1,50 @@
+#ifndef DIRENT_INCLUDED
+#define DIRENT_INCLUDED
+
+/*
+
+    Declaration of POSIX directory browsing functions and types for Win32.
+
+    Author:  Kevlin Henney (kevlin@acm.org, kevlin@curbralan.com)
+    History: Created March 1997. Updated June 2003.
+    Rights:  See end of file.
+    
+*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+typedef struct DIR DIR;
+
+struct dirent
+{
+    char *d_name;
+};
+
+DIR           *opendir(const char *);
+int           closedir(DIR *);
+struct dirent *readdir(DIR *);
+void          rewinddir(DIR *);
+
+/*
+
+    Copyright Kevlin Henney, 1997, 2003. All rights reserved.
+
+    Permission to use, copy, modify, and distribute this software and its
+    documentation for any purpose is hereby granted without fee, provided
+    that this copyright and permissions notice appear in all copies and
+    derivatives.
+    
+    This software is supplied "as is" without express or implied warranty.
+
+    But that said, if there are any problems please get in touch.
+
+*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/src/dir.c mruby-1.0.0-seaos/build/mrbgems/mruby-dir/src/dir.c
--- mruby-1.0.0/build/mrbgems/mruby-dir/src/dir.c	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/src/dir.c	2014-06-20 19:34:26.457447156 -0700
@@ -0,0 +1,281 @@
+/*
+** dir.c - Dir
+**
+** See Copyright Notice in mruby.h
+*/
+
+#include "mruby.h"
+#include "mruby/class.h"
+#include "mruby/data.h"
+#include "mruby/string.h"
+#include "error.h"
+#include <sys/types.h>
+#if defined(_WIN32) || defined(_WIN64)
+  #define MAXPATHLEN 1024
+ #if !defined(PATH_MAX)
+  #define PATH_MAX MAX_PATH
+ #endif
+  #define S_ISDIR(B) ((B)&_S_IFDIR)
+  #include "Win/dirent.h"
+  #include <direct.h>
+  #define rmdir _rmdir
+  #define getcwd _getcwd
+  #define mkdir _mkdir
+  #define chdir _chdir
+#else
+  #include <sys/param.h>
+  #include <dirent.h>
+  #include <unistd.h>
+#endif
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <string.h>
+
+/* with/without IO module */
+#ifdef ENABLE_IO
+#include "mruby/ext/io.h"
+#else
+#define E_IO_ERROR E_RUNTIME_ERROR
+#endif
+
+struct mrb_dir {
+  DIR *dir;
+};
+
+void
+mrb_dir_free(mrb_state *mrb, void *ptr)
+{
+  struct mrb_dir *mdir = ptr;
+
+  if (mdir->dir) {
+    closedir(mdir->dir);
+    mdir->dir = NULL;
+  }
+  mrb_free(mrb, mdir);
+}
+
+static struct mrb_data_type mrb_dir_type = { "DIR", mrb_dir_free };
+
+mrb_value
+mrb_dir_close(mrb_state *mrb, mrb_value self)
+{
+  struct mrb_dir *mdir;
+  mdir = (struct mrb_dir *)mrb_get_datatype(mrb, self, &mrb_dir_type);
+  if (!mdir) return mrb_nil_value();
+  if (!mdir->dir) {
+    mrb_raise(mrb, E_IO_ERROR, "closed directory");
+  }
+  if (closedir(mdir->dir) == -1) {
+    mrb_sys_fail(mrb, "closedir");
+  }
+  mdir->dir = NULL;
+  return mrb_nil_value();
+}
+
+mrb_value
+mrb_dir_init(mrb_state *mrb, mrb_value self)
+{
+  DIR *dir;
+  struct mrb_dir *mdir;
+  mrb_value path;
+  char *cpath;
+
+  mdir = (struct mrb_dir *)DATA_PTR(self);
+  if (mdir) {
+    mrb_dir_free(mrb, mdir);
+  }
+  DATA_TYPE(self) = &mrb_dir_type;
+  DATA_PTR(self) = NULL;
+
+  mdir = (struct mrb_dir *)mrb_malloc(mrb, sizeof(*mdir));
+  mdir->dir = NULL;
+  DATA_PTR(self) = mdir;
+
+  mrb_get_args(mrb, "S", &path);
+  cpath = mrb_str_to_cstr(mrb, path);
+  if ((dir = opendir(cpath)) == NULL) {
+    mrb_sys_fail(mrb, cpath);
+  }
+  mdir->dir = dir;
+  return self;
+}
+
+mrb_value
+mrb_dir_delete(mrb_state *mrb, mrb_value klass)
+{
+  mrb_value path;
+  char *cpath;
+
+  mrb_get_args(mrb, "S", &path);
+  cpath = mrb_str_to_cstr(mrb, path);
+  if (rmdir(cpath) == -1) {
+    mrb_sys_fail(mrb, cpath);
+  }
+  return mrb_fixnum_value(0);
+}
+
+mrb_value
+mrb_dir_existp(mrb_state *mrb, mrb_value klass)
+{
+  mrb_value path;
+  struct stat sb;
+  char *cpath;
+
+  mrb_get_args(mrb, "S", &path);
+  cpath = mrb_str_to_cstr(mrb, path);
+  if (stat(cpath, &sb) == 0 && S_ISDIR(sb.st_mode)) {
+    return mrb_true_value();
+  } else {
+    return mrb_false_value();
+  }
+}
+
+mrb_value
+mrb_dir_getwd(mrb_state *mrb, mrb_value klass)
+{
+  mrb_value path;
+
+  path = mrb_str_buf_new(mrb, MAXPATHLEN);
+  if (getcwd(RSTRING_PTR(path), MAXPATHLEN) == NULL) {
+    mrb_sys_fail(mrb, "getcwd(2)");
+  }
+  mrb_str_resize(mrb, path, strlen(RSTRING_PTR(path)));
+  return path;
+}
+
+mrb_value
+mrb_dir_mkdir(mrb_state *mrb, mrb_value klass)
+{
+  mrb_int mode;
+  mrb_value spath;
+  char *path;
+
+  mode = 0777;
+  mrb_get_args(mrb, "S|i", &spath, &mode);
+  path = mrb_str_to_cstr(mrb, spath);
+#ifndef _WIN32
+  if (mkdir(path, mode) == -1) {
+#else
+  if (mkdir(path) == -1) {
+#endif
+    mrb_sys_fail(mrb, path);
+  }
+  return mrb_fixnum_value(0);
+}
+
+mrb_value
+mrb_dir_chdir(mrb_state *mrb, mrb_value klass)
+{
+  mrb_value spath;
+  char *path;
+
+  mrb_get_args(mrb, "S", &spath);
+  path = mrb_str_to_cstr(mrb, spath);
+  if (chdir(path) == -1) {
+    mrb_sys_fail(mrb, path);
+  }
+  return mrb_fixnum_value(0);
+}
+
+mrb_value
+mrb_dir_read(mrb_state *mrb, mrb_value self)
+{
+  struct mrb_dir *mdir;
+  struct dirent *dp;
+
+  mdir = (struct mrb_dir *)mrb_get_datatype(mrb, self, &mrb_dir_type);
+  if (!mdir) return mrb_nil_value();
+  if (!mdir->dir) {
+    mrb_raise(mrb, E_IO_ERROR, "closed directory");
+  }
+  dp = readdir(mdir->dir);
+  if (dp != NULL) {
+    return mrb_str_new_cstr(mrb, dp->d_name);
+  } else {
+    return mrb_nil_value();
+  }
+}
+
+mrb_value
+mrb_dir_rewind(mrb_state *mrb, mrb_value self)
+{
+  struct mrb_dir *mdir;
+
+  mdir = (struct mrb_dir *)mrb_get_datatype(mrb, self, &mrb_dir_type);
+  if (!mdir) return mrb_nil_value();
+  if (!mdir->dir) {
+    mrb_raise(mrb, E_IO_ERROR, "closed directory");
+  }
+  rewinddir(mdir->dir);
+  return self;
+}
+
+mrb_value
+mrb_dir_seek(mrb_state *mrb, mrb_value self)
+{
+  #if defined(_WIN32) || (_WIN64)
+  mrb_raise(mrb, E_RUNTIME_ERROR, "dirseek() unreliable on Win platforms");
+  return self;
+  #else
+  struct mrb_dir *mdir;
+  mrb_int pos;
+
+  mdir = (struct mrb_dir *)mrb_get_datatype(mrb, self, &mrb_dir_type);
+  if (!mdir) return mrb_nil_value();
+  if (!mdir->dir) {
+    mrb_raise(mrb, E_IO_ERROR, "closed directory");
+  }
+  mrb_get_args(mrb, "i", &pos);
+  seekdir(mdir->dir, (long)pos);
+  return self;
+  #endif
+}
+
+mrb_value
+mrb_dir_tell(mrb_state *mrb, mrb_value self)
+{
+  #if defined(_WIN32) || (_WIN64)
+  mrb_raise(mrb, E_RUNTIME_ERROR, "dirtell() unreliable on Win platforms");
+  return mrb_fixnum_value(0);
+  #else
+  struct mrb_dir *mdir;
+  mrb_int pos;
+
+  mdir = (struct mrb_dir *)mrb_get_datatype(mrb, self, &mrb_dir_type);
+  if (!mdir) return mrb_nil_value();
+  if (!mdir->dir) {
+    mrb_raise(mrb, E_IO_ERROR, "closed directory");
+  }
+  pos = (mrb_int)telldir(mdir->dir);
+  return mrb_fixnum_value(pos);
+  #endif
+}
+
+void
+mrb_mruby_dir_gem_init(mrb_state *mrb)
+{
+  struct RClass *d;
+
+  d = mrb_define_class(mrb, "Dir", mrb->object_class);
+  MRB_SET_INSTANCE_TT(d, MRB_TT_DATA);
+  mrb_define_class_method(mrb, d, "delete", mrb_dir_delete, MRB_ARGS_REQ(1));
+  mrb_define_class_method(mrb, d, "exist?", mrb_dir_existp, MRB_ARGS_REQ(1));
+  mrb_define_class_method(mrb, d, "getwd",  mrb_dir_getwd,  MRB_ARGS_NONE());
+  mrb_define_class_method(mrb, d, "mkdir",  mrb_dir_mkdir,  MRB_ARGS_REQ(1)|MRB_ARGS_OPT(1));
+  mrb_define_class_method(mrb, d, "_chdir", mrb_dir_chdir,  MRB_ARGS_REQ(1));
+
+  mrb_define_method(mrb, d, "close",      mrb_dir_close,  MRB_ARGS_NONE());
+  mrb_define_method(mrb, d, "initialize", mrb_dir_init,   MRB_ARGS_REQ(1));
+  mrb_define_method(mrb, d, "read",       mrb_dir_read,   MRB_ARGS_NONE());
+  mrb_define_method(mrb, d, "rewind",     mrb_dir_rewind, MRB_ARGS_NONE());
+  mrb_define_method(mrb, d, "seek",       mrb_dir_seek,   MRB_ARGS_REQ(1));
+  mrb_define_method(mrb, d, "tell",       mrb_dir_tell,   MRB_ARGS_NONE());
+}
+
+void
+mrb_mruby_dir_gem_final(mrb_state *mrb)
+{
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/test/dir.rb mruby-1.0.0-seaos/build/mrbgems/mruby-dir/test/dir.rb
--- mruby-1.0.0/build/mrbgems/mruby-dir/test/dir.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/test/dir.rb	2014-06-20 19:34:26.457447156 -0700
@@ -0,0 +1,128 @@
+assert('Dir') do
+  assert_equal(Class, Dir.class)
+end
+
+assert('DirTest.setup') do
+  DirTest.setup
+end
+
+assert('Dir.chdir') do
+  assert_equal 0, Dir.chdir(DirTest.sandbox)
+end
+
+assert('Dir.entries') do
+  a = Dir.entries(DirTest.sandbox)
+  assert_true a.include? "a"
+  assert_true a.include? "b"
+end
+
+assert('Dir.exist?') do
+  assert_true Dir.exist?(DirTest.sandbox)
+  assert_false Dir.exist?(DirTest.sandbox + "/nosuchdir")
+end
+
+assert('Dir.foreach') do
+  a = []
+  Dir.foreach(DirTest.sandbox) { |s| a << s }
+  assert_true a.include? "a"
+  assert_true a.include? "b"
+end
+
+assert('Dir.getwd') do
+  s = Dir.getwd
+  assert_true s.kind_of? String
+end
+
+assert('Dir.mkdir') do
+  m1 = DirTest.sandbox + "/mkdir1"
+  m2 = DirTest.sandbox + "/mkdir2"
+  assert_equal 0, Dir.mkdir(m1)
+  assert_equal 0, Dir.mkdir(m2, 0765)
+end
+
+assert('Dir.delete') do
+  s = DirTest.sandbox + "/delete"
+  Dir.mkdir(s)
+  assert_true Dir.exist?(s)
+
+  Dir.delete(s)
+  assert_false Dir.exist?(s)
+end
+
+assert('Dir.open') do
+  a = []
+  Dir.open(DirTest.sandbox) { |d|
+    d.each { |s| a << s }
+  }
+  assert_true a.include? "a"
+  assert_true a.include? "b"
+end
+
+assert('Dir#initialize and Dir#close') do
+  d = Dir.new(".")
+  assert_true d.instance_of? Dir
+  assert_nil d.close
+end
+
+assert('Dir#close') do
+  d = Dir.new(".")
+end
+
+assert('Dir#each') do
+  a = []
+  d = Dir.open(DirTest.sandbox)
+  d.each { |s| a << s }
+  d.close
+  assert_true a.include? "a"
+  assert_true a.include? "b"
+end
+
+assert('Dir#read') do
+  a = []
+  d = Dir.open(DirTest.sandbox)
+  while s = d.read
+    a << s
+  end
+  d.close
+  assert_true a.include? "a"
+  assert_true a.include? "b"
+end
+
+assert('Dir#rewind') do
+  d = Dir.open(DirTest.sandbox)
+  while d.read; end
+
+  assert_equal d, d.rewind
+
+  a = []
+  while s = d.read
+    a << s
+  end
+  d.close
+  assert_true a.include? "a"
+  assert_true a.include? "b"
+end
+
+# Note: behaviors of seekdir(3) and telldir(3) are so platform-dependent
+# that we cannot write portable tests here.
+
+assert('Dir#tell') do
+  n = nil
+  Dir.open(DirTest.sandbox) { |d|
+    n = d.tell
+  }
+  assert_true n.is_a? Integer
+end
+
+assert('Dir#seek') do
+  d1 = Dir.open(DirTest.sandbox)
+  d1.read
+  n = d1.tell
+  d1.read
+  d2 = d1.seek(n)
+  assert_equal d1, d2
+end
+
+assert('DirTest.teardown') do
+  DirTest.teardown
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-dir/test/dirtest.c mruby-1.0.0-seaos/build/mrbgems/mruby-dir/test/dirtest.c
--- mruby-1.0.0/build/mrbgems/mruby-dir/test/dirtest.c	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-dir/test/dirtest.c	2014-06-20 19:34:26.457447156 -0700
@@ -0,0 +1,114 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <dirent.h>
+#include <unistd.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "mruby.h"
+#include "mruby/string.h"
+#include "mruby/variable.h"
+
+
+mrb_value
+mrb_dirtest_setup(mrb_state *mrb, mrb_value klass)
+{
+  mrb_value s;
+  char buf[1024];
+  const char *aname = "a";
+  const char *bname = "b";
+
+  /* save current working directory */
+  if (getcwd(buf, sizeof(buf)) == NULL) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "getcwd() failed");
+  }
+  mrb_cv_set(mrb, klass, mrb_intern_cstr(mrb, "pwd"), mrb_str_new_cstr(mrb, buf));
+
+  /* create sandbox */
+  snprintf(buf, sizeof(buf), "%s/mruby-dir-test.XXXXXX", P_tmpdir);
+  if (mkdtemp(buf) == NULL) {
+    mrb_raisef(mrb, E_RUNTIME_ERROR, "mkdtemp(%S) failed", mrb_str_new_cstr(mrb, buf));
+  }
+  s = mrb_str_new_cstr(mrb, buf);
+  mrb_cv_set(mrb, klass, mrb_intern_cstr(mrb, "sandbox"), s);
+
+  /* go to sandbox */
+  if (chdir(buf) == -1) {
+    rmdir(buf);
+    mrb_raisef(mrb, E_RUNTIME_ERROR, "chdir(%S) failed", s);
+  }
+  
+  /* make some directories in the sandbox */
+  if (mkdir(aname, 0) == -1) {
+    chdir("..");
+    rmdir(buf);
+    mrb_raisef(mrb, E_RUNTIME_ERROR, "mkdir(%S) failed", mrb_str_new_cstr(mrb, aname));
+  }
+  if (mkdir(bname, 0) == -1) {
+    rmdir(aname);
+    chdir("..");
+    rmdir(buf);
+    mrb_raisef(mrb, E_RUNTIME_ERROR, "mkdir(%S) failed", mrb_str_new_cstr(mrb, bname));
+  }
+
+  return mrb_true_value();
+}
+
+mrb_value
+mrb_dirtest_teardown(mrb_state *mrb, mrb_value klass)
+{
+  mrb_value d, sandbox;
+  DIR *dirp;
+  struct dirent *dp;
+  const char *path;
+
+  /* cleanup sandbox */
+  sandbox = mrb_cv_get(mrb, klass, mrb_intern_cstr(mrb, "sandbox"));
+  path = mrb_str_to_cstr(mrb, sandbox);
+
+  dirp = opendir(path);
+  while ((dp = readdir(dirp)) != NULL) {
+    if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0)
+      continue;
+    if (rmdir(dp->d_name) == -1) {
+      mrb_raisef(mrb, E_RUNTIME_ERROR, "rmdir(%S) failed", mrb_str_new_cstr(mrb, dp->d_name));
+    }
+  }
+  closedir(dirp);
+
+  /* back to original pwd */
+  d = mrb_cv_get(mrb, klass, mrb_intern_cstr(mrb, "pwd"));
+  path = mrb_str_to_cstr(mrb, d);
+  if (chdir(path) == -1) {
+    mrb_raisef(mrb, E_RUNTIME_ERROR, "chdir(%S) failed", d);
+  }
+
+  /* remove sandbox directory */
+  sandbox = mrb_cv_get(mrb, klass, mrb_intern_cstr(mrb, "sandbox"));
+  path = mrb_str_to_cstr(mrb, sandbox);
+  if (rmdir(path) == -1) {
+    mrb_raisef(mrb, E_RUNTIME_ERROR, "rmdir(%S) failed", sandbox);
+  }
+
+  return mrb_true_value();
+}
+
+mrb_value
+mrb_dirtest_sandbox(mrb_state *mrb, mrb_value klass)
+{
+  return mrb_cv_get(mrb, klass, mrb_intern_cstr(mrb, "sandbox"));
+}
+
+void
+mrb_mruby_dir_gem_test(mrb_state *mrb)
+{
+  struct RClass *c = mrb_define_module(mrb, "DirTest");
+
+  mrb_define_class_method(mrb, c, "sandbox", mrb_dirtest_sandbox, MRB_ARGS_NONE());
+  mrb_define_class_method(mrb, c, "setup", mrb_dirtest_setup, MRB_ARGS_NONE());
+  mrb_define_class_method(mrb, c, "teardown", mrb_dirtest_teardown, MRB_ARGS_NONE());
+}
+
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/HEAD	2014-06-21 11:57:29.201227045 -0700
@@ -0,0 +1 @@
+ref: refs/heads/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/config mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/config
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/config	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/config	2014-06-21 11:57:29.201227045 -0700
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = https://github.com/mattn/mruby-http.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/description mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/description
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/description	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/description	2014-06-21 11:57:28.201228438 -0700
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/applypatch-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/applypatch-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/applypatch-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/applypatch-msg.sample	2014-06-21 11:57:28.201228438 -0700
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/commit-msg" &&
+	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
+:
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/commit-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/commit-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/commit-msg.sample	2014-06-21 11:57:28.201228438 -0700
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/post-update.sample mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/post-update.sample
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/post-update.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/post-update.sample	2014-06-21 11:57:28.201228438 -0700
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/pre-applypatch.sample mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/pre-applypatch.sample
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/pre-applypatch.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/pre-applypatch.sample	2014-06-21 11:57:28.201228438 -0700
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
+:
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/pre-commit.sample mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/pre-commit.sample
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/pre-commit.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/pre-commit.sample	2014-06-21 11:57:28.201228438 -0700
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/pre-push.sample mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/pre-push.sample
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/pre-push.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/pre-push.sample	2014-06-21 11:57:28.201228438 -0700
@@ -0,0 +1,54 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+IFS=' '
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/pre-rebase.sample mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/pre-rebase.sample
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/pre-rebase.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/pre-rebase.sample	2014-06-21 11:57:28.201228438 -0700
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up-to-date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+exit 0
+
+################################################################
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/prepare-commit-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/prepare-commit-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/prepare-commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/prepare-commit-msg.sample	2014-06-21 11:57:28.201228438 -0700
@@ -0,0 +1,36 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples.  The first comments out the
+# "Conflicts:" part of a merge commit.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+case "$2,$3" in
+  merge,)
+    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
+
+# ,|template,)
+#   /usr/bin/perl -i.bak -pe '
+#      print "\n" . `git diff --cached --name-status -r`
+#	 if /^#/ && $first++ == 0' "$1" ;;
+
+  *) ;;
+esac
+
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/update.sample mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/update.sample
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/hooks/update.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/hooks/update.sample	2014-06-21 11:57:28.201228438 -0700
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to blocks unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
Binary files mruby-1.0.0/build/mrbgems/mruby-http/.git/index and mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/index differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/info/exclude mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/info/exclude
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/info/exclude	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/info/exclude	2014-06-21 11:57:28.201228438 -0700
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/logs/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/logs/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/logs/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/logs/HEAD	2014-06-21 11:57:29.201227045 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 183486de84eddff43417b946f9933c88d096b764 Daniel Bittman <danielbittman1@gmail.com> 1403377049 -0700	clone: from https://github.com/mattn/mruby-http.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/logs/refs/heads/master mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/logs/refs/heads/master
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/logs/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/logs/refs/heads/master	2014-06-21 11:57:29.201227045 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 183486de84eddff43417b946f9933c88d096b764 Daniel Bittman <danielbittman1@gmail.com> 1403377049 -0700	clone: from https://github.com/mattn/mruby-http.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/logs/refs/remotes/origin/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/logs/refs/remotes/origin/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/logs/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/logs/refs/remotes/origin/HEAD	2014-06-21 11:57:29.201227045 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 183486de84eddff43417b946f9933c88d096b764 Daniel Bittman <danielbittman1@gmail.com> 1403377049 -0700	clone: from https://github.com/mattn/mruby-http.git
Binary files mruby-1.0.0/build/mrbgems/mruby-http/.git/objects/pack/pack-6126fc6b45c47f1fb85a6ec3afc969a0a25e1bdc.idx and mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/objects/pack/pack-6126fc6b45c47f1fb85a6ec3afc969a0a25e1bdc.idx differ
Binary files mruby-1.0.0/build/mrbgems/mruby-http/.git/objects/pack/pack-6126fc6b45c47f1fb85a6ec3afc969a0a25e1bdc.pack and mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/objects/pack/pack-6126fc6b45c47f1fb85a6ec3afc969a0a25e1bdc.pack differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/packed-refs mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/packed-refs
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/packed-refs	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/packed-refs	2014-06-21 11:57:29.201227045 -0700
@@ -0,0 +1,3 @@
+# pack-refs with: peeled fully-peeled 
+0f9b3fe001a842f59b0b90a01eaadfe2a6049c9b refs/remotes/origin/gemifest
+183486de84eddff43417b946f9933c88d096b764 refs/remotes/origin/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/refs/heads/master mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/refs/heads/master
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/refs/heads/master	2014-06-21 11:57:29.201227045 -0700
@@ -0,0 +1 @@
+183486de84eddff43417b946f9933c88d096b764
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.git/refs/remotes/origin/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/refs/remotes/origin/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-http/.git/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.git/refs/remotes/origin/HEAD	2014-06-21 11:57:29.201227045 -0700
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/.gitignore mruby-1.0.0-seaos/build/mrbgems/mruby-http/.gitignore
--- mruby-1.0.0/build/mrbgems/mruby-http/.gitignore	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/.gitignore	2014-06-21 11:57:29.204560373 -0700
@@ -0,0 +1,5 @@
+gem_*
+gem-*
+mrb-*.a
+src/*.o
+.local.vimrc
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/README.md mruby-1.0.0-seaos/build/mrbgems/mruby-http/README.md
--- mruby-1.0.0/build/mrbgems/mruby-http/README.md	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/README.md	2014-06-21 11:57:29.204560373 -0700
@@ -0,0 +1,11 @@
+mruby-http
+==========
+
+Some of examples requires [mruby-uv](https://github.com/mattn/mruby-uv)
+
+This uses joyent's [http-parser](https://github.com/joyent/http-parser)
+
+License
+-------
+
+MIT
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/example/file-server.rb mruby-1.0.0-seaos/build/mrbgems/mruby-http/example/file-server.rb
--- mruby-1.0.0/build/mrbgems/mruby-http/example/file-server.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/example/file-server.rb	2014-06-21 11:57:29.204560373 -0700
@@ -0,0 +1,93 @@
+cmap = {
+ 'txt'  => 'text/plain',
+ 'html' => 'text/html',
+ 'css'  => 'text/css',
+ 'jpg'  => 'image/jpeg',
+ 'png'  => 'image/png',
+ 'gif'  => 'image/gif',
+}
+cache = {}
+h = HTTP::Parser.new()
+s = UV::TCP.new()
+s.bind(UV::ip4_addr('127.0.0.1', 8888))
+s.listen(1024) do |x|
+  return if x != 0
+  c = s.accept()
+  c.data = ''
+  c.read_start do |b|
+    next unless b
+    c.data += b
+    i = c.data.index("\r\n\r\n")
+    next if i == nil || i < 0
+    r = h.parse_request(c.data)
+    r.body = c.data.slice(i + 4, c.data.bytesize - i - 4)
+    keep_alive = r.headers.has_key?('Connection') && r.headers['Connection'] == 'Keep-Alive'
+    path = r.path || '/'
+    file = path + (path[-1] == '/' ? 'index.html' : '')
+    size = -1
+    nw = 0
+    begin
+      cc = keep_alive ? "keep-alive" : "close"
+      stat = UV::FS::stat("public/#{file}")
+      size = stat.size.to_i
+      mtim = stat.mtim
+      ext = file.split(".")[-1]
+      ctype = cmap[ext] || 'application/octet-stream'
+      header = "HTTP/1.1 200 OK\r\nConnection: #{cc}\r\nContent-Type: #{ctype}\r\nContent-Length: #{size}\r\n\r\n"
+      item = cache[file]
+      body = ''
+      if item && item[:mtim] == stat.mtim
+        c.write(header + item[:body])
+        cache[file][:epoch] = Time.now.to_i
+      elsif size < 8192
+        f = UV::FS::open("public#{file}", UV::FS::O_RDONLY, UV::FS::S_IREAD)
+        begin
+          read = f.read(size, 0)
+          cache[file] = {:body => read.clone, :mtim => mtim, :epoch => Time.now.to_i}
+          c.write(header + f.read(size, 0))
+          nw = read.bytesize
+        rescue
+        end
+        f.close
+      else
+        f = UV::FS::open("public#{file}", UV::FS::O_RDONLY, UV::FS::S_IREAD)
+        begin
+          read = f.read(8192, 0)
+          c.write(header + read)
+          nw = read.bytesize
+          while nw < size
+            read = f.read(8192, nw)
+            c.write(read)
+            nw += read.bytesize
+          end
+        rescue
+        end
+        f.close
+      end
+    rescue
+      if c && nw == 0
+        if size >= 0
+          c.write("HTTP/1.0 500 Internal Server Error\r\n\r\nInternal Server Error")
+        else
+          c.write("HTTP/1.0 404 Not Found\r\n\r\nNot Found")
+        end
+      end
+      keep_alive = false
+    end
+    c.data = ''
+    unless keep_alive
+      c.close if c
+      c = nil
+    end
+  end
+end
+
+t = UV::Timer.new
+t.start(3000, 3000) {|x|
+  n = Time.now.to_i
+  cache.delete_if {|k, v| v[:epoch] < n - 10}
+  UV::gc()
+  GC.start
+}
+
+UV::run()
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/example/http.rb mruby-1.0.0-seaos/build/mrbgems/mruby-http/example/http.rb
--- mruby-1.0.0/build/mrbgems/mruby-http/example/http.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/example/http.rb	2014-06-21 11:57:29.204560373 -0700
@@ -0,0 +1,46 @@
+#!mruby
+
+h = HTTP::Parser.new()
+q = "GET http://localhost:8080/foo?bar=baz#zzz HTTP/1.1\r\nHost: localhost\r\nUser-Agent: mruby\r\n\r\n"
+h.parse_request(q) {|x|
+  puts x.method
+  puts x.schema
+  puts x.host
+  puts x.port
+  puts x.path
+  puts x.query
+}
+puts
+
+q = "GET http://localhost/foo?bar=baz#zzz HTTP/1.1\r\nHost: localhost\r\nUser-Agent: mruby\r\n\r\n"
+h.parse_request(q) {|x|
+  puts x.method
+  puts x.schema
+  puts x.host
+  puts x.port
+  puts x.path
+  puts x.query
+}
+puts
+
+q = "POST http://localhost/foo?bar=baz#zzz HTTP/1.1\r\nHost: localhost\r\nUser-Agent: mruby\r\nContent-Length: 5\r\n\r\nhello"
+h.parse_request(q) {|x|
+  puts x.method
+  puts x.schema
+  puts x.host
+  puts x.port
+  puts x.path
+  puts x.query
+  puts x.body
+}
+puts
+
+x = h.parse_request(q)
+puts x.method
+puts x.schema
+puts x.host
+puts x.port
+puts x.path
+puts x.query
+puts x.body
+puts
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/example/server.rb mruby-1.0.0-seaos/build/mrbgems/mruby-http/example/server.rb
--- mruby-1.0.0/build/mrbgems/mruby-http/example/server.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/example/server.rb	2014-06-21 11:57:29.204560373 -0700
@@ -0,0 +1,28 @@
+h = HTTP::Parser.new()
+s = UV::TCP.new()
+s.bind(UV::ip4_addr('127.0.0.1', 8888))
+s.listen(1024) do |x|
+  return if x != 0
+  c = s.accept()
+  c.read_start do |b|
+    next unless b
+    r = h.parse_request(b)
+    body = "hello #{r.path}"
+    if !r.headers.has_key?('Connection') || r.headers['Connection'] != 'Keep-Alive'
+      c.write("HTTP/1.1 200 OK\r\nConnection: close\r\nContent-Length: #{body.size}\r\n\r\n#{body}") do |x|
+        c.close() if c
+        c = nil
+      end
+    else
+      c.write("HTTP/1.1 200 OK\r\nConnection: keep-alive\r\nContent-Length: #{body.size}\r\n\r\n#{body}")
+    end
+  end
+end
+
+t = UV::Timer.new
+t.start(3000, 3000) {|x|
+  UV::gc()
+  GC.start
+}
+
+UV::run()
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/example/url.rb mruby-1.0.0-seaos/build/mrbgems/mruby-http/example/url.rb
--- mruby-1.0.0/build/mrbgems/mruby-http/example/url.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/example/url.rb	2014-06-21 11:57:29.204560373 -0700
@@ -0,0 +1,5 @@
+#!mruby
+
+h = HTTP::Parser.new()
+puts h.parse_url("http://localhost:8080/foo?bar=baz#zzz").fragment
+puts "ä¿ºã®å¡©" == HTTP::URL::decode(HTTP::URL::encode("ä¿ºã®å¡©"))
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/include/http_parser.h mruby-1.0.0-seaos/build/mrbgems/mruby-http/include/http_parser.h
--- mruby-1.0.0/build/mrbgems/mruby-http/include/http_parser.h	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/include/http_parser.h	2014-06-21 11:57:29.204560373 -0700
@@ -0,0 +1,325 @@
+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+#ifndef http_parser_h
+#define http_parser_h
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Also update SONAME in the Makefile whenever you change these. */
+#define HTTP_PARSER_VERSION_MAJOR 2
+#define HTTP_PARSER_VERSION_MINOR 3
+#define HTTP_PARSER_VERSION_PATCH 0
+
+#include <sys/types.h>
+#if defined(_WIN32) && !defined(__MINGW32__) && (!defined(_MSC_VER) || _MSC_VER<1600)
+#include <BaseTsd.h>
+#include <stddef.h>
+typedef __int8 int8_t;
+typedef unsigned __int8 uint8_t;
+typedef __int16 int16_t;
+typedef unsigned __int16 uint16_t;
+typedef __int32 int32_t;
+typedef unsigned __int32 uint32_t;
+typedef __int64 int64_t;
+typedef unsigned __int64 uint64_t;
+#else
+#include <stdint.h>
+#endif
+
+/* Compile with -DHTTP_PARSER_STRICT=0 to make less checks, but run
+ * faster
+ */
+#ifndef HTTP_PARSER_STRICT
+# define HTTP_PARSER_STRICT 1
+#endif
+
+/* Maximium header size allowed. If the macro is not defined
+ * before including this header then the default is used. To
+ * change the maximum header size, define the macro in the build
+ * environment (e.g. -DHTTP_MAX_HEADER_SIZE=<value>). To remove
+ * the effective limit on the size of the header, define the macro
+ * to a very large number (e.g. -DHTTP_MAX_HEADER_SIZE=0x7fffffff)
+ */
+#ifndef HTTP_MAX_HEADER_SIZE
+# define HTTP_MAX_HEADER_SIZE (80*1024)
+#endif
+
+typedef struct http_parser http_parser;
+typedef struct http_parser_settings http_parser_settings;
+
+
+/* Callbacks should return non-zero to indicate an error. The parser will
+ * then halt execution.
+ *
+ * The one exception is on_headers_complete. In a HTTP_RESPONSE parser
+ * returning '1' from on_headers_complete will tell the parser that it
+ * should not expect a body. This is used when receiving a response to a
+ * HEAD request which may contain 'Content-Length' or 'Transfer-Encoding:
+ * chunked' headers that indicate the presence of a body.
+ *
+ * http_data_cb does not return data chunks. It will be call arbitrarally
+ * many times for each string. E.G. you might get 10 callbacks for "on_url"
+ * each providing just a few characters more data.
+ */
+typedef int (*http_data_cb) (http_parser*, const char *at, size_t length);
+typedef int (*http_cb) (http_parser*);
+
+
+/* Request Methods */
+#define HTTP_METHOD_MAP(XX)         \
+  XX(0,  DELETE,      DELETE)       \
+  XX(1,  GET,         GET)          \
+  XX(2,  HEAD,        HEAD)         \
+  XX(3,  POST,        POST)         \
+  XX(4,  PUT,         PUT)          \
+  /* pathological */                \
+  XX(5,  CONNECT,     CONNECT)      \
+  XX(6,  OPTIONS,     OPTIONS)      \
+  XX(7,  TRACE,       TRACE)        \
+  /* webdav */                      \
+  XX(8,  COPY,        COPY)         \
+  XX(9,  LOCK,        LOCK)         \
+  XX(10, MKCOL,       MKCOL)        \
+  XX(11, MOVE,        MOVE)         \
+  XX(12, PROPFIND,    PROPFIND)     \
+  XX(13, PROPPATCH,   PROPPATCH)    \
+  XX(14, SEARCH,      SEARCH)       \
+  XX(15, UNLOCK,      UNLOCK)       \
+  /* subversion */                  \
+  XX(16, REPORT,      REPORT)       \
+  XX(17, MKACTIVITY,  MKACTIVITY)   \
+  XX(18, CHECKOUT,    CHECKOUT)     \
+  XX(19, MERGE,       MERGE)        \
+  /* upnp */                        \
+  XX(20, MSEARCH,     M-SEARCH)     \
+  XX(21, NOTIFY,      NOTIFY)       \
+  XX(22, SUBSCRIBE,   SUBSCRIBE)    \
+  XX(23, UNSUBSCRIBE, UNSUBSCRIBE)  \
+  /* RFC-5789 */                    \
+  XX(24, PATCH,       PATCH)        \
+  XX(25, PURGE,       PURGE)        \
+
+enum http_method
+  {
+#define XX(num, name, string) HTTP_##name = num,
+  HTTP_METHOD_MAP(XX)
+#undef XX
+  };
+
+
+enum http_parser_type { HTTP_REQUEST, HTTP_RESPONSE, HTTP_BOTH };
+
+
+/* Flag values for http_parser.flags field */
+enum flags
+  { F_CHUNKED               = 1 << 0
+  , F_CONNECTION_KEEP_ALIVE = 1 << 1
+  , F_CONNECTION_CLOSE      = 1 << 2
+  , F_TRAILING              = 1 << 3
+  , F_UPGRADE               = 1 << 4
+  , F_SKIPBODY              = 1 << 5
+  };
+
+
+/* Map for errno-related constants
+ * 
+ * The provided argument should be a macro that takes 2 arguments.
+ */
+#define HTTP_ERRNO_MAP(XX)                                           \
+  /* No error */                                                     \
+  XX(OK, "success")                                                  \
+                                                                     \
+  /* Callback-related errors */                                      \
+  XX(CB_message_begin, "the on_message_begin callback failed")       \
+  XX(CB_url, "the on_url callback failed")                           \
+  XX(CB_header_field, "the on_header_field callback failed")         \
+  XX(CB_header_value, "the on_header_value callback failed")         \
+  XX(CB_headers_complete, "the on_headers_complete callback failed") \
+  XX(CB_body, "the on_body callback failed")                         \
+  XX(CB_message_complete, "the on_message_complete callback failed") \
+  XX(CB_status, "the on_status callback failed")                     \
+                                                                     \
+  /* Parsing-related errors */                                       \
+  XX(INVALID_EOF_STATE, "stream ended at an unexpected time")        \
+  XX(HEADER_OVERFLOW,                                                \
+     "too many header bytes seen; overflow detected")                \
+  XX(CLOSED_CONNECTION,                                              \
+     "data received after completed connection: close message")      \
+  XX(INVALID_VERSION, "invalid HTTP version")                        \
+  XX(INVALID_STATUS, "invalid HTTP status code")                     \
+  XX(INVALID_METHOD, "invalid HTTP method")                          \
+  XX(INVALID_URL, "invalid URL")                                     \
+  XX(INVALID_HOST, "invalid host")                                   \
+  XX(INVALID_PORT, "invalid port")                                   \
+  XX(INVALID_PATH, "invalid path")                                   \
+  XX(INVALID_QUERY_STRING, "invalid query string")                   \
+  XX(INVALID_FRAGMENT, "invalid fragment")                           \
+  XX(LF_EXPECTED, "LF character expected")                           \
+  XX(INVALID_HEADER_TOKEN, "invalid character in header")            \
+  XX(INVALID_CONTENT_LENGTH,                                         \
+     "invalid character in content-length header")                   \
+  XX(INVALID_CHUNK_SIZE,                                             \
+     "invalid character in chunk size header")                       \
+  XX(INVALID_CONSTANT, "invalid constant string")                    \
+  XX(INVALID_INTERNAL_STATE, "encountered unexpected internal state")\
+  XX(STRICT, "strict mode assertion failed")                         \
+  XX(PAUSED, "parser is paused")                                     \
+  XX(UNKNOWN, "an unknown error occurred")
+
+
+/* Define HPE_* values for each errno value above */
+#define HTTP_ERRNO_GEN(n, s) HPE_##n,
+enum http_errno {
+  HTTP_ERRNO_MAP(HTTP_ERRNO_GEN)
+};
+#undef HTTP_ERRNO_GEN
+
+
+/* Get an http_errno value from an http_parser */
+#define HTTP_PARSER_ERRNO(p)            ((enum http_errno) (p)->http_errno)
+
+
+struct http_parser {
+  /** PRIVATE **/
+  unsigned int type : 2;         /* enum http_parser_type */
+  unsigned int flags : 6;        /* F_* values from 'flags' enum; semi-public */
+  unsigned int state : 8;        /* enum state from http_parser.c */
+  unsigned int header_state : 8; /* enum header_state from http_parser.c */
+  unsigned int index : 8;        /* index into current matcher */
+
+  uint32_t nread;          /* # bytes read in various scenarios */
+  uint64_t content_length; /* # bytes in body (0 if no Content-Length header) */
+
+  /** READ-ONLY **/
+  unsigned short http_major;
+  unsigned short http_minor;
+  unsigned int status_code : 16; /* responses only */
+  unsigned int method : 8;       /* requests only */
+  unsigned int http_errno : 7;
+
+  /* 1 = Upgrade header was present and the parser has exited because of that.
+   * 0 = No upgrade header present.
+   * Should be checked when http_parser_execute() returns in addition to
+   * error checking.
+   */
+  unsigned int upgrade : 1;
+
+  /** PUBLIC **/
+  void *data; /* A pointer to get hook to the "connection" or "socket" object */
+};
+
+
+struct http_parser_settings {
+  http_cb      on_message_begin;
+  http_data_cb on_url;
+  http_data_cb on_status;
+  http_data_cb on_header_field;
+  http_data_cb on_header_value;
+  http_cb      on_headers_complete;
+  http_data_cb on_body;
+  http_cb      on_message_complete;
+};
+
+
+enum http_parser_url_fields
+  { UF_SCHEMA           = 0
+  , UF_HOST             = 1
+  , UF_PORT             = 2
+  , UF_PATH             = 3
+  , UF_QUERY            = 4
+  , UF_FRAGMENT         = 5
+  , UF_USERINFO         = 6
+  , UF_MAX              = 7
+  };
+
+
+/* Result structure for http_parser_parse_url().
+ *
+ * Callers should index into field_data[] with UF_* values iff field_set
+ * has the relevant (1 << UF_*) bit set. As a courtesy to clients (and
+ * because we probably have padding left over), we convert any port to
+ * a uint16_t.
+ */
+struct http_parser_url {
+  uint16_t field_set;           /* Bitmask of (1 << UF_*) values */
+  uint16_t port;                /* Converted UF_PORT string */
+
+  struct {
+    uint16_t off;               /* Offset into buffer in which field starts */
+    uint16_t len;               /* Length of run in buffer */
+  } field_data[UF_MAX];
+};
+
+
+/* Returns the library version. Bits 16-23 contain the major version number,
+ * bits 8-15 the minor version number and bits 0-7 the patch level.
+ * Usage example:
+ *
+ *   unsigned long version = http_parser_version();
+ *   unsigned major = (version >> 16) & 255;
+ *   unsigned minor = (version >> 8) & 255;
+ *   unsigned patch = version & 255;
+ *   printf("http_parser v%u.%u.%u\n", major, minor, version);
+ */
+unsigned long http_parser_version(void);
+
+void http_parser_init(http_parser *parser, enum http_parser_type type);
+
+
+size_t http_parser_execute(http_parser *parser,
+                           const http_parser_settings *settings,
+                           const char *data,
+                           size_t len);
+
+
+/* If http_should_keep_alive() in the on_headers_complete or
+ * on_message_complete callback returns 0, then this should be
+ * the last message on the connection.
+ * If you are the server, respond with the "Connection: close" header.
+ * If you are the client, close the connection.
+ */
+int http_should_keep_alive(const http_parser *parser);
+
+/* Returns a string version of the HTTP method. */
+const char *http_method_str(enum http_method m);
+
+/* Return a string name of the given error */
+const char *http_errno_name(enum http_errno err);
+
+/* Return a string description of the given error */
+const char *http_errno_description(enum http_errno err);
+
+/* Parse a URL; return nonzero on failure */
+int http_parser_parse_url(const char *buf, size_t buflen,
+                          int is_connect,
+                          struct http_parser_url *u);
+
+/* Pause or un-pause the parser; a nonzero value pauses */
+void http_parser_pause(http_parser *parser, int paused);
+
+/* Checks if this is the final chunk of the body. */
+int http_body_is_final(const http_parser *parser);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/include/mrb_http.h mruby-1.0.0-seaos/build/mrbgems/mruby-http/include/mrb_http.h
--- mruby-1.0.0/build/mrbgems/mruby-http/include/mrb_http.h	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/include/mrb_http.h	2014-06-21 11:57:29.204560373 -0700
@@ -0,0 +1,6 @@
+#ifndef MRB_HTTP_H
+#define MRB_HTTP_H
+
+void mrb_mruby_http_gem_init(mrb_state*);
+
+#endif	/* MRB_HTTP_H */
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/mrbgem.rake mruby-1.0.0-seaos/build/mrbgems/mruby-http/mrbgem.rake
--- mruby-1.0.0/build/mrbgems/mruby-http/mrbgem.rake	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/mrbgem.rake	2014-06-21 11:57:29.204560373 -0700
@@ -0,0 +1,4 @@
+MRuby::Gem::Specification.new('mruby-http') do |spec|
+  spec.license = 'MIT'
+  spec.authors = 'mattn'
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/src/http_parser.c mruby-1.0.0-seaos/build/mrbgems/mruby-http/src/http_parser.c
--- mruby-1.0.0/build/mrbgems/mruby-http/src/http_parser.c	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/src/http_parser.c	2014-06-21 11:57:29.204560373 -0700
@@ -0,0 +1,2257 @@
+/* Based on src/http/ngx_http_parse.c from NGINX copyright Igor Sysoev
+ *
+ * Additional changes are licensed under the same terms as NGINX and
+ * copyright Joyent, Inc. and other Node contributors. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+#include "http_parser.h"
+#include <assert.h>
+#include <stddef.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+
+#ifndef ULLONG_MAX
+# define ULLONG_MAX ((uint64_t) -1) /* 2^64-1 */
+#endif
+
+#ifndef MIN
+# define MIN(a,b) ((a) < (b) ? (a) : (b))
+#endif
+
+#ifndef ARRAY_SIZE
+# define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
+#endif
+
+#ifndef BIT_AT
+# define BIT_AT(a, i)                                                \
+  (!!((unsigned int) (a)[(unsigned int) (i) >> 3] &                  \
+   (1 << ((unsigned int) (i) & 7))))
+#endif
+
+#ifndef ELEM_AT
+# define ELEM_AT(a, i, v) ((unsigned int) (i) < ARRAY_SIZE(a) ? (a)[(i)] : (v))
+#endif
+
+#define SET_ERRNO(e)                                                 \
+do {                                                                 \
+  parser->http_errno = (e);                                          \
+} while(0)
+
+
+/* Run the notify callback FOR, returning ER if it fails */
+#define CALLBACK_NOTIFY_(FOR, ER)                                    \
+do {                                                                 \
+  assert(HTTP_PARSER_ERRNO(parser) == HPE_OK);                       \
+                                                                     \
+  if (settings->on_##FOR) {                                          \
+    if (0 != settings->on_##FOR(parser)) {                           \
+      SET_ERRNO(HPE_CB_##FOR);                                       \
+    }                                                                \
+                                                                     \
+    /* We either errored above or got paused; get out */             \
+    if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {                       \
+      return (ER);                                                   \
+    }                                                                \
+  }                                                                  \
+} while (0)
+
+/* Run the notify callback FOR and consume the current byte */
+#define CALLBACK_NOTIFY(FOR)            CALLBACK_NOTIFY_(FOR, p - data + 1)
+
+/* Run the notify callback FOR and don't consume the current byte */
+#define CALLBACK_NOTIFY_NOADVANCE(FOR)  CALLBACK_NOTIFY_(FOR, p - data)
+
+/* Run data callback FOR with LEN bytes, returning ER if it fails */
+#define CALLBACK_DATA_(FOR, LEN, ER)                                 \
+do {                                                                 \
+  assert(HTTP_PARSER_ERRNO(parser) == HPE_OK);                       \
+                                                                     \
+  if (FOR##_mark) {                                                  \
+    if (settings->on_##FOR) {                                        \
+      if (0 != settings->on_##FOR(parser, FOR##_mark, (LEN))) {      \
+        SET_ERRNO(HPE_CB_##FOR);                                     \
+      }                                                              \
+                                                                     \
+      /* We either errored above or got paused; get out */           \
+      if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {                     \
+        return (ER);                                                 \
+      }                                                              \
+    }                                                                \
+    FOR##_mark = NULL;                                               \
+  }                                                                  \
+} while (0)
+  
+/* Run the data callback FOR and consume the current byte */
+#define CALLBACK_DATA(FOR)                                           \
+    CALLBACK_DATA_(FOR, p - FOR##_mark, p - data + 1)
+
+/* Run the data callback FOR and don't consume the current byte */
+#define CALLBACK_DATA_NOADVANCE(FOR)                                 \
+    CALLBACK_DATA_(FOR, p - FOR##_mark, p - data)
+
+/* Set the mark FOR; non-destructive if mark is already set */
+#define MARK(FOR)                                                    \
+do {                                                                 \
+  if (!FOR##_mark) {                                                 \
+    FOR##_mark = p;                                                  \
+  }                                                                  \
+} while (0)
+
+
+#define PROXY_CONNECTION "proxy-connection"
+#define CONNECTION "connection"
+#define CONTENT_LENGTH "content-length"
+#define TRANSFER_ENCODING "transfer-encoding"
+#define UPGRADE "upgrade"
+#define CHUNKED "chunked"
+#define KEEP_ALIVE "keep-alive"
+#define CLOSE "close"
+
+
+static const char *method_strings[] =
+  {
+#define XX(num, name, string) #string,
+  HTTP_METHOD_MAP(XX)
+#undef XX
+  };
+
+
+/* Tokens as defined by rfc 2616. Also lowercases them.
+ *        token       = 1*<any CHAR except CTLs or separators>
+ *     separators     = "(" | ")" | "<" | ">" | "@"
+ *                    | "," | ";" | ":" | "\" | <">
+ *                    | "/" | "[" | "]" | "?" | "="
+ *                    | "{" | "}" | SP | HT
+ */
+static const char tokens[256] = {
+/*   0 nul    1 soh    2 stx    3 etx    4 eot    5 enq    6 ack    7 bel  */
+        0,       0,       0,       0,       0,       0,       0,       0,
+/*   8 bs     9 ht    10 nl    11 vt    12 np    13 cr    14 so    15 si   */
+        0,       0,       0,       0,       0,       0,       0,       0,
+/*  16 dle   17 dc1   18 dc2   19 dc3   20 dc4   21 nak   22 syn   23 etb */
+        0,       0,       0,       0,       0,       0,       0,       0,
+/*  24 can   25 em    26 sub   27 esc   28 fs    29 gs    30 rs    31 us  */
+        0,       0,       0,       0,       0,       0,       0,       0,
+/*  32 sp    33  !    34  "    35  #    36  $    37  %    38  &    39  '  */
+        0,      '!',      0,      '#',     '$',     '%',     '&',    '\'',
+/*  40  (    41  )    42  *    43  +    44  ,    45  -    46  .    47  /  */
+        0,       0,      '*',     '+',      0,      '-',     '.',      0,
+/*  48  0    49  1    50  2    51  3    52  4    53  5    54  6    55  7  */
+       '0',     '1',     '2',     '3',     '4',     '5',     '6',     '7',
+/*  56  8    57  9    58  :    59  ;    60  <    61  =    62  >    63  ?  */
+       '8',     '9',      0,       0,       0,       0,       0,       0,
+/*  64  @    65  A    66  B    67  C    68  D    69  E    70  F    71  G  */
+        0,      'a',     'b',     'c',     'd',     'e',     'f',     'g',
+/*  72  H    73  I    74  J    75  K    76  L    77  M    78  N    79  O  */
+       'h',     'i',     'j',     'k',     'l',     'm',     'n',     'o',
+/*  80  P    81  Q    82  R    83  S    84  T    85  U    86  V    87  W  */
+       'p',     'q',     'r',     's',     't',     'u',     'v',     'w',
+/*  88  X    89  Y    90  Z    91  [    92  \    93  ]    94  ^    95  _  */
+       'x',     'y',     'z',      0,       0,       0,      '^',     '_',
+/*  96  `    97  a    98  b    99  c   100  d   101  e   102  f   103  g  */
+       '`',     'a',     'b',     'c',     'd',     'e',     'f',     'g',
+/* 104  h   105  i   106  j   107  k   108  l   109  m   110  n   111  o  */
+       'h',     'i',     'j',     'k',     'l',     'm',     'n',     'o',
+/* 112  p   113  q   114  r   115  s   116  t   117  u   118  v   119  w  */
+       'p',     'q',     'r',     's',     't',     'u',     'v',     'w',
+/* 120  x   121  y   122  z   123  {   124  |   125  }   126  ~   127 del */
+       'x',     'y',     'z',      0,      '|',      0,      '~',       0 };
+
+
+static const int8_t unhex[256] =
+  {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
+  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
+  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
+  , 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1
+  ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1
+  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
+  ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1
+  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
+  };
+
+
+#if HTTP_PARSER_STRICT
+# define T(v) 0
+#else
+# define T(v) v
+#endif
+
+
+static const uint8_t normal_url_char[32] = {
+/*   0 nul    1 soh    2 stx    3 etx    4 eot    5 enq    6 ack    7 bel  */
+        0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,
+/*   8 bs     9 ht    10 nl    11 vt    12 np    13 cr    14 so    15 si   */
+        0    | T(2)   |   0    |   0    | T(16)  |   0    |   0    |   0,
+/*  16 dle   17 dc1   18 dc2   19 dc3   20 dc4   21 nak   22 syn   23 etb */
+        0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,
+/*  24 can   25 em    26 sub   27 esc   28 fs    29 gs    30 rs    31 us  */
+        0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,
+/*  32 sp    33  !    34  "    35  #    36  $    37  %    38  &    39  '  */
+        0    |   2    |   4    |   0    |   16   |   32   |   64   |  128,
+/*  40  (    41  )    42  *    43  +    44  ,    45  -    46  .    47  /  */
+        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
+/*  48  0    49  1    50  2    51  3    52  4    53  5    54  6    55  7  */
+        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
+/*  56  8    57  9    58  :    59  ;    60  <    61  =    62  >    63  ?  */
+        1    |   2    |   4    |   8    |   16   |   32   |   64   |   0,
+/*  64  @    65  A    66  B    67  C    68  D    69  E    70  F    71  G  */
+        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
+/*  72  H    73  I    74  J    75  K    76  L    77  M    78  N    79  O  */
+        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
+/*  80  P    81  Q    82  R    83  S    84  T    85  U    86  V    87  W  */
+        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
+/*  88  X    89  Y    90  Z    91  [    92  \    93  ]    94  ^    95  _  */
+        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
+/*  96  `    97  a    98  b    99  c   100  d   101  e   102  f   103  g  */
+        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
+/* 104  h   105  i   106  j   107  k   108  l   109  m   110  n   111  o  */
+        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
+/* 112  p   113  q   114  r   115  s   116  t   117  u   118  v   119  w  */
+        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
+/* 120  x   121  y   122  z   123  {   124  |   125  }   126  ~   127 del */
+        1    |   2    |   4    |   8    |   16   |   32   |   64   |   0, };
+
+#undef T
+
+enum state
+  { s_dead = 1 /* important that this is > 0 */
+
+  , s_start_req_or_res
+  , s_res_or_resp_H
+  , s_start_res
+  , s_res_H
+  , s_res_HT
+  , s_res_HTT
+  , s_res_HTTP
+  , s_res_first_http_major
+  , s_res_http_major
+  , s_res_first_http_minor
+  , s_res_http_minor
+  , s_res_first_status_code
+  , s_res_status_code
+  , s_res_status_start
+  , s_res_status
+  , s_res_line_almost_done
+
+  , s_start_req
+
+  , s_req_method
+  , s_req_spaces_before_url
+  , s_req_schema
+  , s_req_schema_slash
+  , s_req_schema_slash_slash
+  , s_req_server_start
+  , s_req_server
+  , s_req_server_with_at
+  , s_req_path
+  , s_req_query_string_start
+  , s_req_query_string
+  , s_req_fragment_start
+  , s_req_fragment
+  , s_req_http_start
+  , s_req_http_H
+  , s_req_http_HT
+  , s_req_http_HTT
+  , s_req_http_HTTP
+  , s_req_first_http_major
+  , s_req_http_major
+  , s_req_first_http_minor
+  , s_req_http_minor
+  , s_req_line_almost_done
+
+  , s_header_field_start
+  , s_header_field
+  , s_header_value_discard_ws
+  , s_header_value_discard_ws_almost_done
+  , s_header_value_discard_lws
+  , s_header_value_start
+  , s_header_value
+  , s_header_value_lws
+
+  , s_header_almost_done
+
+  , s_chunk_size_start
+  , s_chunk_size
+  , s_chunk_parameters
+  , s_chunk_size_almost_done
+
+  , s_headers_almost_done
+  , s_headers_done
+
+  /* Important: 's_headers_done' must be the last 'header' state. All
+   * states beyond this must be 'body' states. It is used for overflow
+   * checking. See the PARSING_HEADER() macro.
+   */
+
+  , s_chunk_data
+  , s_chunk_data_almost_done
+  , s_chunk_data_done
+
+  , s_body_identity
+  , s_body_identity_eof
+
+  , s_message_done
+  };
+
+
+#define PARSING_HEADER(state) (state <= s_headers_done)
+
+
+enum header_states
+  { h_general = 0
+  , h_C
+  , h_CO
+  , h_CON
+
+  , h_matching_connection
+  , h_matching_proxy_connection
+  , h_matching_content_length
+  , h_matching_transfer_encoding
+  , h_matching_upgrade
+
+  , h_connection
+  , h_content_length
+  , h_transfer_encoding
+  , h_upgrade
+
+  , h_matching_transfer_encoding_chunked
+  , h_matching_connection_keep_alive
+  , h_matching_connection_close
+
+  , h_transfer_encoding_chunked
+  , h_connection_keep_alive
+  , h_connection_close
+  };
+
+enum http_host_state
+  {
+    s_http_host_dead = 1
+  , s_http_userinfo_start
+  , s_http_userinfo
+  , s_http_host_start
+  , s_http_host_v6_start
+  , s_http_host
+  , s_http_host_v6
+  , s_http_host_v6_end
+  , s_http_host_port_start
+  , s_http_host_port
+};
+
+/* Macros for character classes; depends on strict-mode  */
+#define CR                  '\r'
+#define LF                  '\n'
+#define LOWER(c)            (unsigned char)(c | 0x20)
+#define IS_ALPHA(c)         (LOWER(c) >= 'a' && LOWER(c) <= 'z')
+#define IS_NUM(c)           ((c) >= '0' && (c) <= '9')
+#define IS_ALPHANUM(c)      (IS_ALPHA(c) || IS_NUM(c))
+#define IS_HEX(c)           (IS_NUM(c) || (LOWER(c) >= 'a' && LOWER(c) <= 'f'))
+#define IS_MARK(c)          ((c) == '-' || (c) == '_' || (c) == '.' || \
+  (c) == '!' || (c) == '~' || (c) == '*' || (c) == '\'' || (c) == '(' || \
+  (c) == ')')
+#define IS_USERINFO_CHAR(c) (IS_ALPHANUM(c) || IS_MARK(c) || (c) == '%' || \
+  (c) == ';' || (c) == ':' || (c) == '&' || (c) == '=' || (c) == '+' || \
+  (c) == '$' || (c) == ',')
+
+#if HTTP_PARSER_STRICT
+#define TOKEN(c)            (tokens[(unsigned char)c])
+#define IS_URL_CHAR(c)      (BIT_AT(normal_url_char, (unsigned char)c))
+#define IS_HOST_CHAR(c)     (IS_ALPHANUM(c) || (c) == '.' || (c) == '-')
+#else
+#define TOKEN(c)            ((c == ' ') ? ' ' : tokens[(unsigned char)c])
+#define IS_URL_CHAR(c)                                                         \
+  (BIT_AT(normal_url_char, (unsigned char)c) || ((c) & 0x80))
+#define IS_HOST_CHAR(c)                                                        \
+  (IS_ALPHANUM(c) || (c) == '.' || (c) == '-' || (c) == '_')
+#endif
+
+
+#define start_state (parser->type == HTTP_REQUEST ? s_start_req : s_start_res)
+
+
+#if HTTP_PARSER_STRICT
+# define STRICT_CHECK(cond)                                          \
+do {                                                                 \
+  if (cond) {                                                        \
+    SET_ERRNO(HPE_STRICT);                                           \
+    goto error;                                                      \
+  }                                                                  \
+} while (0)
+# define NEW_MESSAGE() (http_should_keep_alive(parser) ? start_state : s_dead)
+#else
+# define STRICT_CHECK(cond)
+# define NEW_MESSAGE() start_state
+#endif
+
+
+/* Map errno values to strings for human-readable output */
+#define HTTP_STRERROR_GEN(n, s) { "HPE_" #n, s },
+static struct {
+  const char *name;
+  const char *description;
+} http_strerror_tab[] = {
+  HTTP_ERRNO_MAP(HTTP_STRERROR_GEN)
+};
+#undef HTTP_STRERROR_GEN
+
+int http_message_needs_eof(const http_parser *parser);
+
+/* Our URL parser.
+ *
+ * This is designed to be shared by http_parser_execute() for URL validation,
+ * hence it has a state transition + byte-for-byte interface. In addition, it
+ * is meant to be embedded in http_parser_parse_url(), which does the dirty
+ * work of turning state transitions URL components for its API.
+ *
+ * This function should only be invoked with non-space characters. It is
+ * assumed that the caller cares about (and can detect) the transition between
+ * URL and non-URL states by looking for these.
+ */
+static enum state
+parse_url_char(enum state s, const char ch)
+{
+  if (ch == ' ' || ch == '\r' || ch == '\n') {
+    return s_dead;
+  }
+
+#if HTTP_PARSER_STRICT
+  if (ch == '\t' || ch == '\f') {
+    return s_dead;
+  }
+#endif
+
+  switch (s) {
+    case s_req_spaces_before_url:
+      /* Proxied requests are followed by scheme of an absolute URI (alpha).
+       * All methods except CONNECT are followed by '/' or '*'.
+       */
+
+      if (ch == '/' || ch == '*') {
+        return s_req_path;
+      }
+
+      if (IS_ALPHA(ch)) {
+        return s_req_schema;
+      }
+
+      break;
+
+    case s_req_schema:
+      if (IS_ALPHA(ch)) {
+        return s;
+      }
+
+      if (ch == ':') {
+        return s_req_schema_slash;
+      }
+
+      break;
+
+    case s_req_schema_slash:
+      if (ch == '/') {
+        return s_req_schema_slash_slash;
+      }
+
+      break;
+
+    case s_req_schema_slash_slash:
+      if (ch == '/') {
+        return s_req_server_start;
+      }
+
+      break;
+
+    case s_req_server_with_at:
+      if (ch == '@') {
+        return s_dead;
+      }
+
+    /* FALLTHROUGH */
+    case s_req_server_start:
+    case s_req_server:
+      if (ch == '/') {
+        return s_req_path;
+      }
+
+      if (ch == '?') {
+        return s_req_query_string_start;
+      }
+
+      if (ch == '@') {
+        return s_req_server_with_at;
+      }
+
+      if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {
+        return s_req_server;
+      }
+
+      break;
+
+    case s_req_path:
+      if (IS_URL_CHAR(ch)) {
+        return s;
+      }
+
+      switch (ch) {
+        case '?':
+          return s_req_query_string_start;
+
+        case '#':
+          return s_req_fragment_start;
+      }
+
+      break;
+
+    case s_req_query_string_start:
+    case s_req_query_string:
+      if (IS_URL_CHAR(ch)) {
+        return s_req_query_string;
+      }
+
+      switch (ch) {
+        case '?':
+          /* allow extra '?' in query string */
+          return s_req_query_string;
+
+        case '#':
+          return s_req_fragment_start;
+      }
+
+      break;
+
+    case s_req_fragment_start:
+      if (IS_URL_CHAR(ch)) {
+        return s_req_fragment;
+      }
+
+      switch (ch) {
+        case '?':
+          return s_req_fragment;
+
+        case '#':
+          return s;
+      }
+
+      break;
+
+    case s_req_fragment:
+      if (IS_URL_CHAR(ch)) {
+        return s;
+      }
+
+      switch (ch) {
+        case '?':
+        case '#':
+          return s;
+      }
+
+      break;
+
+    default:
+      break;
+  }
+
+  /* We should never fall out of the switch above unless there's an error */
+  return s_dead;
+}
+
+size_t http_parser_execute (http_parser *parser,
+                            const http_parser_settings *settings,
+                            const char *data,
+                            size_t len)
+{
+  char c, ch;
+  int8_t unhex_val;
+  const char *p = data;
+  const char *header_field_mark = 0;
+  const char *header_value_mark = 0;
+  const char *url_mark = 0;
+  const char *body_mark = 0;
+  const char *status_mark = 0;
+
+  /* We're in an error state. Don't bother doing anything. */
+  if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {
+    return 0;
+  }
+
+  if (len == 0) {
+    switch (parser->state) {
+      case s_body_identity_eof:
+        /* Use of CALLBACK_NOTIFY() here would erroneously return 1 byte read if
+         * we got paused.
+         */
+        CALLBACK_NOTIFY_NOADVANCE(message_complete);
+        return 0;
+
+      case s_dead:
+      case s_start_req_or_res:
+      case s_start_res:
+      case s_start_req:
+        return 0;
+
+      default:
+        SET_ERRNO(HPE_INVALID_EOF_STATE);
+        return 1;
+    }
+  }
+
+
+  if (parser->state == s_header_field)
+    header_field_mark = data;
+  if (parser->state == s_header_value)
+    header_value_mark = data;
+  switch (parser->state) {
+  case s_req_path:
+  case s_req_schema:
+  case s_req_schema_slash:
+  case s_req_schema_slash_slash:
+  case s_req_server_start:
+  case s_req_server:
+  case s_req_server_with_at:
+  case s_req_query_string_start:
+  case s_req_query_string:
+  case s_req_fragment_start:
+  case s_req_fragment:
+    url_mark = data;
+    break;
+  case s_res_status:
+    status_mark = data;
+    break;
+  }
+
+  for (p=data; p != data + len; p++) {
+    ch = *p;
+
+    if (PARSING_HEADER(parser->state)) {
+      ++parser->nread;
+      /* Don't allow the total size of the HTTP headers (including the status
+       * line) to exceed HTTP_MAX_HEADER_SIZE.  This check is here to protect
+       * embedders against denial-of-service attacks where the attacker feeds
+       * us a never-ending header that the embedder keeps buffering.
+       *
+       * This check is arguably the responsibility of embedders but we're doing
+       * it on the embedder's behalf because most won't bother and this way we
+       * make the web a little safer.  HTTP_MAX_HEADER_SIZE is still far bigger
+       * than any reasonable request or response so this should never affect
+       * day-to-day operation.
+       */
+      if (parser->nread > (HTTP_MAX_HEADER_SIZE)) {
+        SET_ERRNO(HPE_HEADER_OVERFLOW);
+        goto error;
+      }
+    }
+
+    reexecute_byte:
+    switch (parser->state) {
+
+      case s_dead:
+        /* this state is used after a 'Connection: close' message
+         * the parser will error out if it reads another message
+         */
+        if (ch == CR || ch == LF)
+          break;
+
+        SET_ERRNO(HPE_CLOSED_CONNECTION);
+        goto error;
+
+      case s_start_req_or_res:
+      {
+        if (ch == CR || ch == LF)
+          break;
+        parser->flags = 0;
+        parser->content_length = ULLONG_MAX;
+
+        if (ch == 'H') {
+          parser->state = s_res_or_resp_H;
+
+          CALLBACK_NOTIFY(message_begin);
+        } else {
+          parser->type = HTTP_REQUEST;
+          parser->state = s_start_req;
+          goto reexecute_byte;
+        }
+
+        break;
+      }
+
+      case s_res_or_resp_H:
+        if (ch == 'T') {
+          parser->type = HTTP_RESPONSE;
+          parser->state = s_res_HT;
+        } else {
+          if (ch != 'E') {
+            SET_ERRNO(HPE_INVALID_CONSTANT);
+            goto error;
+          }
+
+          parser->type = HTTP_REQUEST;
+          parser->method = HTTP_HEAD;
+          parser->index = 2;
+          parser->state = s_req_method;
+        }
+        break;
+
+      case s_start_res:
+      {
+        parser->flags = 0;
+        parser->content_length = ULLONG_MAX;
+
+        switch (ch) {
+          case 'H':
+            parser->state = s_res_H;
+            break;
+
+          case CR:
+          case LF:
+            break;
+
+          default:
+            SET_ERRNO(HPE_INVALID_CONSTANT);
+            goto error;
+        }
+
+        CALLBACK_NOTIFY(message_begin);
+        break;
+      }
+
+      case s_res_H:
+        STRICT_CHECK(ch != 'T');
+        parser->state = s_res_HT;
+        break;
+
+      case s_res_HT:
+        STRICT_CHECK(ch != 'T');
+        parser->state = s_res_HTT;
+        break;
+
+      case s_res_HTT:
+        STRICT_CHECK(ch != 'P');
+        parser->state = s_res_HTTP;
+        break;
+
+      case s_res_HTTP:
+        STRICT_CHECK(ch != '/');
+        parser->state = s_res_first_http_major;
+        break;
+
+      case s_res_first_http_major:
+        if (ch < '0' || ch > '9') {
+          SET_ERRNO(HPE_INVALID_VERSION);
+          goto error;
+        }
+
+        parser->http_major = ch - '0';
+        parser->state = s_res_http_major;
+        break;
+
+      /* major HTTP version or dot */
+      case s_res_http_major:
+      {
+        if (ch == '.') {
+          parser->state = s_res_first_http_minor;
+          break;
+        }
+
+        if (!IS_NUM(ch)) {
+          SET_ERRNO(HPE_INVALID_VERSION);
+          goto error;
+        }
+
+        parser->http_major *= 10;
+        parser->http_major += ch - '0';
+
+        if (parser->http_major > 999) {
+          SET_ERRNO(HPE_INVALID_VERSION);
+          goto error;
+        }
+
+        break;
+      }
+
+      /* first digit of minor HTTP version */
+      case s_res_first_http_minor:
+        if (!IS_NUM(ch)) {
+          SET_ERRNO(HPE_INVALID_VERSION);
+          goto error;
+        }
+
+        parser->http_minor = ch - '0';
+        parser->state = s_res_http_minor;
+        break;
+
+      /* minor HTTP version or end of request line */
+      case s_res_http_minor:
+      {
+        if (ch == ' ') {
+          parser->state = s_res_first_status_code;
+          break;
+        }
+
+        if (!IS_NUM(ch)) {
+          SET_ERRNO(HPE_INVALID_VERSION);
+          goto error;
+        }
+
+        parser->http_minor *= 10;
+        parser->http_minor += ch - '0';
+
+        if (parser->http_minor > 999) {
+          SET_ERRNO(HPE_INVALID_VERSION);
+          goto error;
+        }
+
+        break;
+      }
+
+      case s_res_first_status_code:
+      {
+        if (!IS_NUM(ch)) {
+          if (ch == ' ') {
+            break;
+          }
+
+          SET_ERRNO(HPE_INVALID_STATUS);
+          goto error;
+        }
+        parser->status_code = ch - '0';
+        parser->state = s_res_status_code;
+        break;
+      }
+
+      case s_res_status_code:
+      {
+        if (!IS_NUM(ch)) {
+          switch (ch) {
+            case ' ':
+              parser->state = s_res_status_start;
+              break;
+            case CR:
+              parser->state = s_res_line_almost_done;
+              break;
+            case LF:
+              parser->state = s_header_field_start;
+              break;
+            default:
+              SET_ERRNO(HPE_INVALID_STATUS);
+              goto error;
+          }
+          break;
+        }
+
+        parser->status_code *= 10;
+        parser->status_code += ch - '0';
+
+        if (parser->status_code > 999) {
+          SET_ERRNO(HPE_INVALID_STATUS);
+          goto error;
+        }
+
+        break;
+      }
+
+      case s_res_status_start:
+      {
+        if (ch == CR) {
+          parser->state = s_res_line_almost_done;
+          break;
+        }
+
+        if (ch == LF) {
+          parser->state = s_header_field_start;
+          break;
+        }
+
+        MARK(status);
+        parser->state = s_res_status;
+        parser->index = 0;
+        break;
+      }
+
+      case s_res_status:
+        if (ch == CR) {
+          parser->state = s_res_line_almost_done;
+          CALLBACK_DATA(status);
+          break;
+        }
+
+        if (ch == LF) {
+          parser->state = s_header_field_start;
+          CALLBACK_DATA(status);
+          break;
+        }
+
+        break;
+
+      case s_res_line_almost_done:
+        STRICT_CHECK(ch != LF);
+        parser->state = s_header_field_start;
+        break;
+
+      case s_start_req:
+      {
+        if (ch == CR || ch == LF)
+          break;
+        parser->flags = 0;
+        parser->content_length = ULLONG_MAX;
+
+        if (!IS_ALPHA(ch)) {
+          SET_ERRNO(HPE_INVALID_METHOD);
+          goto error;
+        }
+
+        parser->method = (enum http_method) 0;
+        parser->index = 1;
+        switch (ch) {
+          case 'C': parser->method = HTTP_CONNECT; /* or COPY, CHECKOUT */ break;
+          case 'D': parser->method = HTTP_DELETE; break;
+          case 'G': parser->method = HTTP_GET; break;
+          case 'H': parser->method = HTTP_HEAD; break;
+          case 'L': parser->method = HTTP_LOCK; break;
+          case 'M': parser->method = HTTP_MKCOL; /* or MOVE, MKACTIVITY, MERGE, M-SEARCH */ break;
+          case 'N': parser->method = HTTP_NOTIFY; break;
+          case 'O': parser->method = HTTP_OPTIONS; break;
+          case 'P': parser->method = HTTP_POST;
+            /* or PROPFIND|PROPPATCH|PUT|PATCH|PURGE */
+            break;
+          case 'R': parser->method = HTTP_REPORT; break;
+          case 'S': parser->method = HTTP_SUBSCRIBE; /* or SEARCH */ break;
+          case 'T': parser->method = HTTP_TRACE; break;
+          case 'U': parser->method = HTTP_UNLOCK; /* or UNSUBSCRIBE */ break;
+          default:
+            SET_ERRNO(HPE_INVALID_METHOD);
+            goto error;
+        }
+        parser->state = s_req_method;
+
+        CALLBACK_NOTIFY(message_begin);
+
+        break;
+      }
+
+      case s_req_method:
+      {
+        const char *matcher;
+        if (ch == '\0') {
+          SET_ERRNO(HPE_INVALID_METHOD);
+          goto error;
+        }
+
+        matcher = method_strings[parser->method];
+        if (ch == ' ' && matcher[parser->index] == '\0') {
+          parser->state = s_req_spaces_before_url;
+        } else if (ch == matcher[parser->index]) {
+          ; /* nada */
+        } else if (parser->method == HTTP_CONNECT) {
+          if (parser->index == 1 && ch == 'H') {
+            parser->method = HTTP_CHECKOUT;
+          } else if (parser->index == 2  && ch == 'P') {
+            parser->method = HTTP_COPY;
+          } else {
+            SET_ERRNO(HPE_INVALID_METHOD);
+            goto error;
+          }
+        } else if (parser->method == HTTP_MKCOL) {
+          if (parser->index == 1 && ch == 'O') {
+            parser->method = HTTP_MOVE;
+          } else if (parser->index == 1 && ch == 'E') {
+            parser->method = HTTP_MERGE;
+          } else if (parser->index == 1 && ch == '-') {
+            parser->method = HTTP_MSEARCH;
+          } else if (parser->index == 2 && ch == 'A') {
+            parser->method = HTTP_MKACTIVITY;
+          } else {
+            SET_ERRNO(HPE_INVALID_METHOD);
+            goto error;
+          }
+        } else if (parser->method == HTTP_SUBSCRIBE) {
+          if (parser->index == 1 && ch == 'E') {
+            parser->method = HTTP_SEARCH;
+          } else {
+            SET_ERRNO(HPE_INVALID_METHOD);
+            goto error;
+          }
+        } else if (parser->index == 1 && parser->method == HTTP_POST) {
+          if (ch == 'R') {
+            parser->method = HTTP_PROPFIND; /* or HTTP_PROPPATCH */
+          } else if (ch == 'U') {
+            parser->method = HTTP_PUT; /* or HTTP_PURGE */
+          } else if (ch == 'A') {
+            parser->method = HTTP_PATCH;
+          } else {
+            SET_ERRNO(HPE_INVALID_METHOD);
+            goto error;
+          }
+        } else if (parser->index == 2) {
+          if (parser->method == HTTP_PUT) {
+            if (ch == 'R') {
+              parser->method = HTTP_PURGE;
+            } else {
+              SET_ERRNO(HPE_INVALID_METHOD);
+              goto error;
+            }
+          } else if (parser->method == HTTP_UNLOCK) {
+            if (ch == 'S') {
+              parser->method = HTTP_UNSUBSCRIBE;
+            } else {
+              SET_ERRNO(HPE_INVALID_METHOD);
+              goto error;
+            }
+          } else {
+            SET_ERRNO(HPE_INVALID_METHOD);
+            goto error;
+          }
+        } else if (parser->index == 4 && parser->method == HTTP_PROPFIND && ch == 'P') {
+          parser->method = HTTP_PROPPATCH;
+        } else {
+          SET_ERRNO(HPE_INVALID_METHOD);
+          goto error;
+        }
+
+        ++parser->index;
+        break;
+      }
+
+      case s_req_spaces_before_url:
+      {
+        if (ch == ' ') break;
+
+        MARK(url);
+        if (parser->method == HTTP_CONNECT) {
+          parser->state = s_req_server_start;
+        }
+
+        parser->state = parse_url_char((enum state)parser->state, ch);
+        if (parser->state == s_dead) {
+          SET_ERRNO(HPE_INVALID_URL);
+          goto error;
+        }
+
+        break;
+      }
+
+      case s_req_schema:
+      case s_req_schema_slash:
+      case s_req_schema_slash_slash:
+      case s_req_server_start:
+      {
+        switch (ch) {
+          /* No whitespace allowed here */
+          case ' ':
+          case CR:
+          case LF:
+            SET_ERRNO(HPE_INVALID_URL);
+            goto error;
+          default:
+            parser->state = parse_url_char((enum state)parser->state, ch);
+            if (parser->state == s_dead) {
+              SET_ERRNO(HPE_INVALID_URL);
+              goto error;
+            }
+        }
+
+        break;
+      }
+
+      case s_req_server:
+      case s_req_server_with_at:
+      case s_req_path:
+      case s_req_query_string_start:
+      case s_req_query_string:
+      case s_req_fragment_start:
+      case s_req_fragment:
+      {
+        switch (ch) {
+          case ' ':
+            parser->state = s_req_http_start;
+            CALLBACK_DATA(url);
+            break;
+          case CR:
+          case LF:
+            parser->http_major = 0;
+            parser->http_minor = 9;
+            parser->state = (ch == CR) ?
+              s_req_line_almost_done :
+              s_header_field_start;
+            CALLBACK_DATA(url);
+            break;
+          default:
+            parser->state = parse_url_char((enum state)parser->state, ch);
+            if (parser->state == s_dead) {
+              SET_ERRNO(HPE_INVALID_URL);
+              goto error;
+            }
+        }
+        break;
+      }
+
+      case s_req_http_start:
+        switch (ch) {
+          case 'H':
+            parser->state = s_req_http_H;
+            break;
+          case ' ':
+            break;
+          default:
+            SET_ERRNO(HPE_INVALID_CONSTANT);
+            goto error;
+        }
+        break;
+
+      case s_req_http_H:
+        STRICT_CHECK(ch != 'T');
+        parser->state = s_req_http_HT;
+        break;
+
+      case s_req_http_HT:
+        STRICT_CHECK(ch != 'T');
+        parser->state = s_req_http_HTT;
+        break;
+
+      case s_req_http_HTT:
+        STRICT_CHECK(ch != 'P');
+        parser->state = s_req_http_HTTP;
+        break;
+
+      case s_req_http_HTTP:
+        STRICT_CHECK(ch != '/');
+        parser->state = s_req_first_http_major;
+        break;
+
+      /* first digit of major HTTP version */
+      case s_req_first_http_major:
+        if (ch < '1' || ch > '9') {
+          SET_ERRNO(HPE_INVALID_VERSION);
+          goto error;
+        }
+
+        parser->http_major = ch - '0';
+        parser->state = s_req_http_major;
+        break;
+
+      /* major HTTP version or dot */
+      case s_req_http_major:
+      {
+        if (ch == '.') {
+          parser->state = s_req_first_http_minor;
+          break;
+        }
+
+        if (!IS_NUM(ch)) {
+          SET_ERRNO(HPE_INVALID_VERSION);
+          goto error;
+        }
+
+        parser->http_major *= 10;
+        parser->http_major += ch - '0';
+
+        if (parser->http_major > 999) {
+          SET_ERRNO(HPE_INVALID_VERSION);
+          goto error;
+        }
+
+        break;
+      }
+
+      /* first digit of minor HTTP version */
+      case s_req_first_http_minor:
+        if (!IS_NUM(ch)) {
+          SET_ERRNO(HPE_INVALID_VERSION);
+          goto error;
+        }
+
+        parser->http_minor = ch - '0';
+        parser->state = s_req_http_minor;
+        break;
+
+      /* minor HTTP version or end of request line */
+      case s_req_http_minor:
+      {
+        if (ch == CR) {
+          parser->state = s_req_line_almost_done;
+          break;
+        }
+
+        if (ch == LF) {
+          parser->state = s_header_field_start;
+          break;
+        }
+
+        /* XXX allow spaces after digit? */
+
+        if (!IS_NUM(ch)) {
+          SET_ERRNO(HPE_INVALID_VERSION);
+          goto error;
+        }
+
+        parser->http_minor *= 10;
+        parser->http_minor += ch - '0';
+
+        if (parser->http_minor > 999) {
+          SET_ERRNO(HPE_INVALID_VERSION);
+          goto error;
+        }
+
+        break;
+      }
+
+      /* end of request line */
+      case s_req_line_almost_done:
+      {
+        if (ch != LF) {
+          SET_ERRNO(HPE_LF_EXPECTED);
+          goto error;
+        }
+
+        parser->state = s_header_field_start;
+        break;
+      }
+
+      case s_header_field_start:
+      {
+        if (ch == CR) {
+          parser->state = s_headers_almost_done;
+          break;
+        }
+
+        if (ch == LF) {
+          /* they might be just sending \n instead of \r\n so this would be
+           * the second \n to denote the end of headers*/
+          parser->state = s_headers_almost_done;
+          goto reexecute_byte;
+        }
+
+        c = TOKEN(ch);
+
+        if (!c) {
+          SET_ERRNO(HPE_INVALID_HEADER_TOKEN);
+          goto error;
+        }
+
+        MARK(header_field);
+
+        parser->index = 0;
+        parser->state = s_header_field;
+
+        switch (c) {
+          case 'c':
+            parser->header_state = h_C;
+            break;
+
+          case 'p':
+            parser->header_state = h_matching_proxy_connection;
+            break;
+
+          case 't':
+            parser->header_state = h_matching_transfer_encoding;
+            break;
+
+          case 'u':
+            parser->header_state = h_matching_upgrade;
+            break;
+
+          default:
+            parser->header_state = h_general;
+            break;
+        }
+        break;
+      }
+
+      case s_header_field:
+      {
+        c = TOKEN(ch);
+
+        if (c) {
+          switch (parser->header_state) {
+            case h_general:
+              break;
+
+            case h_C:
+              parser->index++;
+              parser->header_state = (c == 'o' ? h_CO : h_general);
+              break;
+
+            case h_CO:
+              parser->index++;
+              parser->header_state = (c == 'n' ? h_CON : h_general);
+              break;
+
+            case h_CON:
+              parser->index++;
+              switch (c) {
+                case 'n':
+                  parser->header_state = h_matching_connection;
+                  break;
+                case 't':
+                  parser->header_state = h_matching_content_length;
+                  break;
+                default:
+                  parser->header_state = h_general;
+                  break;
+              }
+              break;
+
+            /* connection */
+
+            case h_matching_connection:
+              parser->index++;
+              if (parser->index > sizeof(CONNECTION)-1
+                  || c != CONNECTION[parser->index]) {
+                parser->header_state = h_general;
+              } else if (parser->index == sizeof(CONNECTION)-2) {
+                parser->header_state = h_connection;
+              }
+              break;
+
+            /* proxy-connection */
+
+            case h_matching_proxy_connection:
+              parser->index++;
+              if (parser->index > sizeof(PROXY_CONNECTION)-1
+                  || c != PROXY_CONNECTION[parser->index]) {
+                parser->header_state = h_general;
+              } else if (parser->index == sizeof(PROXY_CONNECTION)-2) {
+                parser->header_state = h_connection;
+              }
+              break;
+
+            /* content-length */
+
+            case h_matching_content_length:
+              parser->index++;
+              if (parser->index > sizeof(CONTENT_LENGTH)-1
+                  || c != CONTENT_LENGTH[parser->index]) {
+                parser->header_state = h_general;
+              } else if (parser->index == sizeof(CONTENT_LENGTH)-2) {
+                parser->header_state = h_content_length;
+              }
+              break;
+
+            /* transfer-encoding */
+
+            case h_matching_transfer_encoding:
+              parser->index++;
+              if (parser->index > sizeof(TRANSFER_ENCODING)-1
+                  || c != TRANSFER_ENCODING[parser->index]) {
+                parser->header_state = h_general;
+              } else if (parser->index == sizeof(TRANSFER_ENCODING)-2) {
+                parser->header_state = h_transfer_encoding;
+              }
+              break;
+
+            /* upgrade */
+
+            case h_matching_upgrade:
+              parser->index++;
+              if (parser->index > sizeof(UPGRADE)-1
+                  || c != UPGRADE[parser->index]) {
+                parser->header_state = h_general;
+              } else if (parser->index == sizeof(UPGRADE)-2) {
+                parser->header_state = h_upgrade;
+              }
+              break;
+
+            case h_connection:
+            case h_content_length:
+            case h_transfer_encoding:
+            case h_upgrade:
+              if (ch != ' ') parser->header_state = h_general;
+              break;
+
+            default:
+              assert(0 && "Unknown header_state");
+              break;
+          }
+          break;
+        }
+
+        if (ch == ':') {
+          parser->state = s_header_value_discard_ws;
+          CALLBACK_DATA(header_field);
+          break;
+        }
+
+        if (ch == CR) {
+          parser->state = s_header_almost_done;
+          CALLBACK_DATA(header_field);
+          break;
+        }
+
+        if (ch == LF) {
+          parser->state = s_header_field_start;
+          CALLBACK_DATA(header_field);
+          break;
+        }
+
+        SET_ERRNO(HPE_INVALID_HEADER_TOKEN);
+        goto error;
+      }
+
+      case s_header_value_discard_ws:
+        if (ch == ' ' || ch == '\t') break;
+
+        if (ch == CR) {
+          parser->state = s_header_value_discard_ws_almost_done;
+          break;
+        }
+
+        if (ch == LF) {
+          parser->state = s_header_value_discard_lws;
+          break;
+        }
+
+        /* FALLTHROUGH */
+
+      case s_header_value_start:
+      {
+        MARK(header_value);
+
+        parser->state = s_header_value;
+        parser->index = 0;
+
+        c = LOWER(ch);
+
+        switch (parser->header_state) {
+          case h_upgrade:
+            parser->flags |= F_UPGRADE;
+            parser->header_state = h_general;
+            break;
+
+          case h_transfer_encoding:
+            /* looking for 'Transfer-Encoding: chunked' */
+            if ('c' == c) {
+              parser->header_state = h_matching_transfer_encoding_chunked;
+            } else {
+              parser->header_state = h_general;
+            }
+            break;
+
+          case h_content_length:
+            if (!IS_NUM(ch)) {
+              SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
+              goto error;
+            }
+
+            parser->content_length = ch - '0';
+            break;
+
+          case h_connection:
+            /* looking for 'Connection: keep-alive' */
+            if (c == 'k') {
+              parser->header_state = h_matching_connection_keep_alive;
+            /* looking for 'Connection: close' */
+            } else if (c == 'c') {
+              parser->header_state = h_matching_connection_close;
+            } else {
+              parser->header_state = h_general;
+            }
+            break;
+
+          default:
+            parser->header_state = h_general;
+            break;
+        }
+        break;
+      }
+
+      case s_header_value:
+      {
+
+        if (ch == CR) {
+          parser->state = s_header_almost_done;
+          CALLBACK_DATA(header_value);
+          break;
+        }
+
+        if (ch == LF) {
+          parser->state = s_header_almost_done;
+          CALLBACK_DATA_NOADVANCE(header_value);
+          goto reexecute_byte;
+        }
+
+        c = LOWER(ch);
+
+        switch (parser->header_state) {
+          case h_general:
+            break;
+
+          case h_connection:
+          case h_transfer_encoding:
+            assert(0 && "Shouldn't get here.");
+            break;
+
+          case h_content_length:
+          {
+            uint64_t t;
+
+            if (ch == ' ') break;
+
+            if (!IS_NUM(ch)) {
+              SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
+              goto error;
+            }
+
+            t = parser->content_length;
+            t *= 10;
+            t += ch - '0';
+
+            /* Overflow? Test against a conservative limit for simplicity. */
+            if ((ULLONG_MAX - 10) / 10 < parser->content_length) {
+              SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
+              goto error;
+            }
+
+            parser->content_length = t;
+            break;
+          }
+
+          /* Transfer-Encoding: chunked */
+          case h_matching_transfer_encoding_chunked:
+            parser->index++;
+            if (parser->index > sizeof(CHUNKED)-1
+                || c != CHUNKED[parser->index]) {
+              parser->header_state = h_general;
+            } else if (parser->index == sizeof(CHUNKED)-2) {
+              parser->header_state = h_transfer_encoding_chunked;
+            }
+            break;
+
+          /* looking for 'Connection: keep-alive' */
+          case h_matching_connection_keep_alive:
+            parser->index++;
+            if (parser->index > sizeof(KEEP_ALIVE)-1
+                || c != KEEP_ALIVE[parser->index]) {
+              parser->header_state = h_general;
+            } else if (parser->index == sizeof(KEEP_ALIVE)-2) {
+              parser->header_state = h_connection_keep_alive;
+            }
+            break;
+
+          /* looking for 'Connection: close' */
+          case h_matching_connection_close:
+            parser->index++;
+            if (parser->index > sizeof(CLOSE)-1 || c != CLOSE[parser->index]) {
+              parser->header_state = h_general;
+            } else if (parser->index == sizeof(CLOSE)-2) {
+              parser->header_state = h_connection_close;
+            }
+            break;
+
+          case h_transfer_encoding_chunked:
+          case h_connection_keep_alive:
+          case h_connection_close:
+            if (ch != ' ') parser->header_state = h_general;
+            break;
+
+          default:
+            parser->state = s_header_value;
+            parser->header_state = h_general;
+            break;
+        }
+        break;
+      }
+
+      case s_header_almost_done:
+      {
+        STRICT_CHECK(ch != LF);
+
+        parser->state = s_header_value_lws;
+        break;
+      }
+
+      case s_header_value_lws:
+      {
+        if (ch == ' ' || ch == '\t') {
+          parser->state = s_header_value_start;
+          goto reexecute_byte;
+        }
+
+        /* finished the header */
+        switch (parser->header_state) {
+          case h_connection_keep_alive:
+            parser->flags |= F_CONNECTION_KEEP_ALIVE;
+            break;
+          case h_connection_close:
+            parser->flags |= F_CONNECTION_CLOSE;
+            break;
+          case h_transfer_encoding_chunked:
+            parser->flags |= F_CHUNKED;
+            break;
+          default:
+            break;
+        }
+
+        parser->state = s_header_field_start;
+        goto reexecute_byte;
+      }
+
+      case s_header_value_discard_ws_almost_done:
+      {
+        STRICT_CHECK(ch != LF);
+        parser->state = s_header_value_discard_lws;
+        break;
+      }
+
+      case s_header_value_discard_lws:
+      {
+        if (ch == ' ' || ch == '\t') {
+          parser->state = s_header_value_discard_ws;
+          break;
+        } else {
+          /* header value was empty */
+          MARK(header_value);
+          parser->state = s_header_field_start;
+          CALLBACK_DATA_NOADVANCE(header_value);
+          goto reexecute_byte;
+        }
+      }
+
+      case s_headers_almost_done:
+      {
+        STRICT_CHECK(ch != LF);
+
+        if (parser->flags & F_TRAILING) {
+          /* End of a chunked request */
+          parser->state = NEW_MESSAGE();
+          CALLBACK_NOTIFY(message_complete);
+          break;
+        }
+
+        parser->state = s_headers_done;
+
+        /* Set this here so that on_headers_complete() callbacks can see it */
+        parser->upgrade =
+          (parser->flags & F_UPGRADE || parser->method == HTTP_CONNECT);
+
+        /* Here we call the headers_complete callback. This is somewhat
+         * different than other callbacks because if the user returns 1, we
+         * will interpret that as saying that this message has no body. This
+         * is needed for the annoying case of recieving a response to a HEAD
+         * request.
+         *
+         * We'd like to use CALLBACK_NOTIFY_NOADVANCE() here but we cannot, so
+         * we have to simulate it by handling a change in errno below.
+         */
+        if (settings->on_headers_complete) {
+          switch (settings->on_headers_complete(parser)) {
+            case 0:
+              break;
+
+            case 1:
+              parser->flags |= F_SKIPBODY;
+              break;
+
+            default:
+              SET_ERRNO(HPE_CB_headers_complete);
+              return p - data; /* Error */
+          }
+        }
+
+        if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {
+          return p - data;
+        }
+
+        goto reexecute_byte;
+      }
+
+      case s_headers_done:
+      {
+        STRICT_CHECK(ch != LF);
+
+        parser->nread = 0;
+
+        /* Exit, the rest of the connect is in a different protocol. */
+        if (parser->upgrade) {
+          parser->state = NEW_MESSAGE();
+          CALLBACK_NOTIFY(message_complete);
+          return (p - data) + 1;
+        }
+
+        if (parser->flags & F_SKIPBODY) {
+          parser->state = NEW_MESSAGE();
+          CALLBACK_NOTIFY(message_complete);
+        } else if (parser->flags & F_CHUNKED) {
+          /* chunked encoding - ignore Content-Length header */
+          parser->state = s_chunk_size_start;
+        } else {
+          if (parser->content_length == 0) {
+            /* Content-Length header given but zero: Content-Length: 0\r\n */
+            parser->state = NEW_MESSAGE();
+            CALLBACK_NOTIFY(message_complete);
+          } else if (parser->content_length != ULLONG_MAX) {
+            /* Content-Length header given and non-zero */
+            parser->state = s_body_identity;
+          } else {
+            if (parser->type == HTTP_REQUEST ||
+                !http_message_needs_eof(parser)) {
+              /* Assume content-length 0 - read the next */
+              parser->state = NEW_MESSAGE();
+              CALLBACK_NOTIFY(message_complete);
+            } else {
+              /* Read body until EOF */
+              parser->state = s_body_identity_eof;
+            }
+          }
+        }
+
+        break;
+      }
+
+      case s_body_identity:
+      {
+        uint64_t to_read = MIN(parser->content_length,
+                               (uint64_t) ((data + len) - p));
+
+        assert(parser->content_length != 0
+            && parser->content_length != ULLONG_MAX);
+
+        /* The difference between advancing content_length and p is because
+         * the latter will automaticaly advance on the next loop iteration.
+         * Further, if content_length ends up at 0, we want to see the last
+         * byte again for our message complete callback.
+         */
+        MARK(body);
+        parser->content_length -= to_read;
+        p += to_read - 1;
+
+        if (parser->content_length == 0) {
+          parser->state = s_message_done;
+
+          /* Mimic CALLBACK_DATA_NOADVANCE() but with one extra byte.
+           *
+           * The alternative to doing this is to wait for the next byte to
+           * trigger the data callback, just as in every other case. The
+           * problem with this is that this makes it difficult for the test
+           * harness to distinguish between complete-on-EOF and
+           * complete-on-length. It's not clear that this distinction is
+           * important for applications, but let's keep it for now.
+           */
+          CALLBACK_DATA_(body, p - body_mark + 1, p - data);
+          goto reexecute_byte;
+        }
+
+        break;
+      }
+
+      /* read until EOF */
+      case s_body_identity_eof:
+        MARK(body);
+        p = data + len - 1;
+
+        break;
+
+      case s_message_done:
+        parser->state = NEW_MESSAGE();
+        CALLBACK_NOTIFY(message_complete);
+        break;
+
+      case s_chunk_size_start:
+      {
+        assert(parser->nread == 1);
+        assert(parser->flags & F_CHUNKED);
+
+        unhex_val = unhex[(unsigned char)ch];
+        if (unhex_val == -1) {
+          SET_ERRNO(HPE_INVALID_CHUNK_SIZE);
+          goto error;
+        }
+
+        parser->content_length = unhex_val;
+        parser->state = s_chunk_size;
+        break;
+      }
+
+      case s_chunk_size:
+      {
+        uint64_t t;
+
+        assert(parser->flags & F_CHUNKED);
+
+        if (ch == CR) {
+          parser->state = s_chunk_size_almost_done;
+          break;
+        }
+
+        unhex_val = unhex[(unsigned char)ch];
+
+        if (unhex_val == -1) {
+          if (ch == ';' || ch == ' ') {
+            parser->state = s_chunk_parameters;
+            break;
+          }
+
+          SET_ERRNO(HPE_INVALID_CHUNK_SIZE);
+          goto error;
+        }
+
+        t = parser->content_length;
+        t *= 16;
+        t += unhex_val;
+
+        /* Overflow? Test against a conservative limit for simplicity. */
+        if ((ULLONG_MAX - 16) / 16 < parser->content_length) {
+          SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
+          goto error;
+        }
+
+        parser->content_length = t;
+        break;
+      }
+
+      case s_chunk_parameters:
+      {
+        assert(parser->flags & F_CHUNKED);
+        /* just ignore this shit. TODO check for overflow */
+        if (ch == CR) {
+          parser->state = s_chunk_size_almost_done;
+          break;
+        }
+        break;
+      }
+
+      case s_chunk_size_almost_done:
+      {
+        assert(parser->flags & F_CHUNKED);
+        STRICT_CHECK(ch != LF);
+
+        parser->nread = 0;
+
+        if (parser->content_length == 0) {
+          parser->flags |= F_TRAILING;
+          parser->state = s_header_field_start;
+        } else {
+          parser->state = s_chunk_data;
+        }
+        break;
+      }
+
+      case s_chunk_data:
+      {
+        uint64_t to_read = MIN(parser->content_length,
+                               (uint64_t) ((data + len) - p));
+
+        assert(parser->flags & F_CHUNKED);
+        assert(parser->content_length != 0
+            && parser->content_length != ULLONG_MAX);
+
+        /* See the explanation in s_body_identity for why the content
+         * length and data pointers are managed this way.
+         */
+        MARK(body);
+        parser->content_length -= to_read;
+        p += to_read - 1;
+
+        if (parser->content_length == 0) {
+          parser->state = s_chunk_data_almost_done;
+        }
+
+        break;
+      }
+
+      case s_chunk_data_almost_done:
+        assert(parser->flags & F_CHUNKED);
+        assert(parser->content_length == 0);
+        STRICT_CHECK(ch != CR);
+        parser->state = s_chunk_data_done;
+        CALLBACK_DATA(body);
+        break;
+
+      case s_chunk_data_done:
+        assert(parser->flags & F_CHUNKED);
+        STRICT_CHECK(ch != LF);
+        parser->nread = 0;
+        parser->state = s_chunk_size_start;
+        break;
+
+      default:
+        assert(0 && "unhandled state");
+        SET_ERRNO(HPE_INVALID_INTERNAL_STATE);
+        goto error;
+    }
+  }
+
+  /* Run callbacks for any marks that we have leftover after we ran our of
+   * bytes. There should be at most one of these set, so it's OK to invoke
+   * them in series (unset marks will not result in callbacks).
+   *
+   * We use the NOADVANCE() variety of callbacks here because 'p' has already
+   * overflowed 'data' and this allows us to correct for the off-by-one that
+   * we'd otherwise have (since CALLBACK_DATA() is meant to be run with a 'p'
+   * value that's in-bounds).
+   */
+
+  assert(((header_field_mark ? 1 : 0) +
+          (header_value_mark ? 1 : 0) +
+          (url_mark ? 1 : 0)  +
+          (body_mark ? 1 : 0) +
+          (status_mark ? 1 : 0)) <= 1);
+
+  CALLBACK_DATA_NOADVANCE(header_field);
+  CALLBACK_DATA_NOADVANCE(header_value);
+  CALLBACK_DATA_NOADVANCE(url);
+  CALLBACK_DATA_NOADVANCE(body);
+  CALLBACK_DATA_NOADVANCE(status);
+
+  return len;
+
+error:
+  if (HTTP_PARSER_ERRNO(parser) == HPE_OK) {
+    SET_ERRNO(HPE_UNKNOWN);
+  }
+
+  return (p - data);
+}
+
+
+/* Does the parser need to see an EOF to find the end of the message? */
+int
+http_message_needs_eof (const http_parser *parser)
+{
+  if (parser->type == HTTP_REQUEST) {
+    return 0;
+  }
+
+  /* See RFC 2616 section 4.4 */
+  if (parser->status_code / 100 == 1 || /* 1xx e.g. Continue */
+      parser->status_code == 204 ||     /* No Content */
+      parser->status_code == 304 ||     /* Not Modified */
+      parser->flags & F_SKIPBODY) {     /* response to a HEAD request */
+    return 0;
+  }
+
+  if ((parser->flags & F_CHUNKED) || parser->content_length != ULLONG_MAX) {
+    return 0;
+  }
+
+  return 1;
+}
+
+
+int
+http_should_keep_alive (const http_parser *parser)
+{
+  if (parser->http_major > 0 && parser->http_minor > 0) {
+    /* HTTP/1.1 */
+    if (parser->flags & F_CONNECTION_CLOSE) {
+      return 0;
+    }
+  } else {
+    /* HTTP/1.0 or earlier */
+    if (!(parser->flags & F_CONNECTION_KEEP_ALIVE)) {
+      return 0;
+    }
+  }
+
+  return !http_message_needs_eof(parser);
+}
+
+
+const char *
+http_method_str (enum http_method m)
+{
+  return ELEM_AT(method_strings, m, "<unknown>");
+}
+
+
+void
+http_parser_init (http_parser *parser, enum http_parser_type t)
+{
+  void *data = parser->data; /* preserve application data */
+  memset(parser, 0, sizeof(*parser));
+  parser->data = data;
+  parser->type = t;
+  parser->state = (t == HTTP_REQUEST ? s_start_req : (t == HTTP_RESPONSE ? s_start_res : s_start_req_or_res));
+  parser->http_errno = HPE_OK;
+}
+
+const char *
+http_errno_name(enum http_errno err) {
+  assert(err < (sizeof(http_strerror_tab)/sizeof(http_strerror_tab[0])));
+  return http_strerror_tab[err].name;
+}
+
+const char *
+http_errno_description(enum http_errno err) {
+  assert(err < (sizeof(http_strerror_tab)/sizeof(http_strerror_tab[0])));
+  return http_strerror_tab[err].description;
+}
+
+static enum http_host_state
+http_parse_host_char(enum http_host_state s, const char ch) {
+  switch(s) {
+    case s_http_userinfo:
+    case s_http_userinfo_start:
+      if (ch == '@') {
+        return s_http_host_start;
+      }
+
+      if (IS_USERINFO_CHAR(ch)) {
+        return s_http_userinfo;
+      }
+      break;
+
+    case s_http_host_start:
+      if (ch == '[') {
+        return s_http_host_v6_start;
+      }
+
+      if (IS_HOST_CHAR(ch)) {
+        return s_http_host;
+      }
+
+      break;
+
+    case s_http_host:
+      if (IS_HOST_CHAR(ch)) {
+        return s_http_host;
+      }
+
+    /* FALLTHROUGH */
+    case s_http_host_v6_end:
+      if (ch == ':') {
+        return s_http_host_port_start;
+      }
+
+      break;
+
+    case s_http_host_v6:
+      if (ch == ']') {
+        return s_http_host_v6_end;
+      }
+
+    /* FALLTHROUGH */
+    case s_http_host_v6_start:
+      if (IS_HEX(ch) || ch == ':' || ch == '.') {
+        return s_http_host_v6;
+      }
+
+      break;
+
+    case s_http_host_port:
+    case s_http_host_port_start:
+      if (IS_NUM(ch)) {
+        return s_http_host_port;
+      }
+
+      break;
+
+    default:
+      break;
+  }
+  return s_http_host_dead;
+}
+
+static int
+http_parse_host(const char * buf, struct http_parser_url *u, int found_at) {
+  enum http_host_state s;
+
+  const char *p;
+  size_t buflen = u->field_data[UF_HOST].off + u->field_data[UF_HOST].len;
+
+  u->field_data[UF_HOST].len = 0;
+
+  s = found_at ? s_http_userinfo_start : s_http_host_start;
+
+  for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {
+    enum http_host_state new_s = http_parse_host_char(s, *p);
+
+    if (new_s == s_http_host_dead) {
+      return 1;
+    }
+
+    switch(new_s) {
+      case s_http_host:
+        if (s != s_http_host) {
+          u->field_data[UF_HOST].off = p - buf;
+        }
+        u->field_data[UF_HOST].len++;
+        break;
+
+      case s_http_host_v6:
+        if (s != s_http_host_v6) {
+          u->field_data[UF_HOST].off = p - buf;
+        }
+        u->field_data[UF_HOST].len++;
+        break;
+
+      case s_http_host_port:
+        if (s != s_http_host_port) {
+          u->field_data[UF_PORT].off = p - buf;
+          u->field_data[UF_PORT].len = 0;
+          u->field_set |= (1 << UF_PORT);
+        }
+        u->field_data[UF_PORT].len++;
+        break;
+
+      case s_http_userinfo:
+        if (s != s_http_userinfo) {
+          u->field_data[UF_USERINFO].off = p - buf ;
+          u->field_data[UF_USERINFO].len = 0;
+          u->field_set |= (1 << UF_USERINFO);
+        }
+        u->field_data[UF_USERINFO].len++;
+        break;
+
+      default:
+        break;
+    }
+    s = new_s;
+  }
+
+  /* Make sure we don't end somewhere unexpected */
+  switch (s) {
+    case s_http_host_start:
+    case s_http_host_v6_start:
+    case s_http_host_v6:
+    case s_http_host_port_start:
+    case s_http_userinfo:
+    case s_http_userinfo_start:
+      return 1;
+    default:
+      break;
+  }
+
+  return 0;
+}
+
+int
+http_parser_parse_url(const char *buf, size_t buflen, int is_connect,
+                      struct http_parser_url *u)
+{
+  enum state s;
+  const char *p;
+  enum http_parser_url_fields uf, old_uf;
+  int found_at = 0;
+
+  u->port = u->field_set = 0;
+  s = is_connect ? s_req_server_start : s_req_spaces_before_url;
+  uf = old_uf = UF_MAX;
+
+  for (p = buf; p < buf + buflen; p++) {
+    s = parse_url_char(s, *p);
+
+    /* Figure out the next field that we're operating on */
+    switch (s) {
+      case s_dead:
+        return 1;
+
+      /* Skip delimeters */
+      case s_req_schema_slash:
+      case s_req_schema_slash_slash:
+      case s_req_server_start:
+      case s_req_query_string_start:
+      case s_req_fragment_start:
+        continue;
+
+      case s_req_schema:
+        uf = UF_SCHEMA;
+        break;
+
+      case s_req_server_with_at:
+        found_at = 1;
+
+      /* FALLTROUGH */
+      case s_req_server:
+        uf = UF_HOST;
+        break;
+
+      case s_req_path:
+        uf = UF_PATH;
+        break;
+
+      case s_req_query_string:
+        uf = UF_QUERY;
+        break;
+
+      case s_req_fragment:
+        uf = UF_FRAGMENT;
+        break;
+
+      default:
+        assert(!"Unexpected state");
+        return 1;
+    }
+
+    /* Nothing's changed; soldier on */
+    if (uf == old_uf) {
+      u->field_data[uf].len++;
+      continue;
+    }
+
+    u->field_data[uf].off = p - buf;
+    u->field_data[uf].len = 1;
+
+    u->field_set |= (1 << uf);
+    old_uf = uf;
+  }
+
+  /* host must be present if there is a schema */
+  /* parsing http:///toto will fail */
+  if ((u->field_set & ((1 << UF_SCHEMA) | (1 << UF_HOST))) != 0) {
+    if (http_parse_host(buf, u, found_at) != 0) {
+      return 1;
+    }
+  }
+
+  /* CONNECT requests can only contain "hostname:port" */
+  if (is_connect && u->field_set != ((1 << UF_HOST)|(1 << UF_PORT))) {
+    return 1;
+  }
+
+  if (u->field_set & (1 << UF_PORT)) {
+    /* Don't bother with endp; we've already validated the string */
+    unsigned long v = strtoul(buf + u->field_data[UF_PORT].off, NULL, 10);
+
+    /* Ports have a max value of 2^16 */
+    if (v > 0xffff) {
+      return 1;
+    }
+
+    u->port = (uint16_t) v;
+  }
+
+  return 0;
+}
+
+void
+http_parser_pause(http_parser *parser, int paused) {
+  /* Users should only be pausing/unpausing a parser that is not in an error
+   * state. In non-debug builds, there's not much that we can do about this
+   * other than ignore it.
+   */
+  if (HTTP_PARSER_ERRNO(parser) == HPE_OK ||
+      HTTP_PARSER_ERRNO(parser) == HPE_PAUSED) {
+    SET_ERRNO((paused) ? HPE_PAUSED : HPE_OK);
+  } else {
+    assert(0 && "Attempting to pause parser in error state");
+  }
+}
+
+int
+http_body_is_final(const struct http_parser *parser) {
+    return parser->state == s_message_done;
+}
+
+unsigned long
+http_parser_version(void) {
+  return HTTP_PARSER_VERSION_MAJOR * 0x10000 |
+         HTTP_PARSER_VERSION_MINOR * 0x00100 |
+         HTTP_PARSER_VERSION_PATCH * 0x00001;
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-http/src/mrb_http.c mruby-1.0.0-seaos/build/mrbgems/mruby-http/src/mrb_http.c
--- mruby-1.0.0/build/mrbgems/mruby-http/src/mrb_http.c	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-http/src/mrb_http.c	2014-06-21 11:57:29.204560373 -0700
@@ -0,0 +1,690 @@
+#include <mruby.h>
+#include <mruby/proc.h>
+#include <mruby/data.h>
+#include <mruby/string.h>
+#include <mruby/hash.h>
+#include <mruby/array.h>
+#include <mruby/class.h>
+#include <mruby/variable.h>
+#include <http_parser.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define MAX_HEADER_NAME_LEN 1024
+#define MAX_HEADERS         128
+
+/*********************************************************
+ * parser
+ *********************************************************/
+
+typedef struct {
+  mrb_state *mrb;
+  int type;
+  struct http_parser parser;
+  struct http_parser_url handle;
+  struct http_parser_settings settings;
+  int was_header_value;
+  mrb_value instance;
+} mrb_http_parser_context;
+
+static void
+http_parser_context_free(mrb_state *mrb, void *p)
+{
+  free(p);
+}
+
+static const struct mrb_data_type
+http_parser_context_type = {
+  "mrb_http_parser_context", http_parser_context_free,
+};
+
+static void
+http_url_free(mrb_state *mrb, void *p)
+{
+  free(p);
+}
+
+static const struct mrb_data_type http_url_type = {
+  "mrb_http_url", http_url_free,
+};
+
+static int
+parser_settings_on_url(http_parser* parser, const char *at, size_t len)
+{
+  int ai;
+  mrb_http_parser_context *context = (mrb_http_parser_context*) parser->data;
+  mrb_state* mrb = context->mrb;
+
+  if(http_parser_parse_url(at, len, FALSE, &context->handle) != 0) {
+    mrb_raise(mrb, E_ARGUMENT_ERROR, "invalid argument");
+  }
+
+  ai = mrb_gc_arena_save(mrb);
+  mrb_iv_set(mrb, context->instance, mrb_intern_cstr(mrb, "buf"), mrb_str_new(mrb, at, len));
+  mrb_gc_arena_restore(mrb, ai);
+  return 0;
+}
+
+#define OBJECT_GET(mrb, instance, name) \
+  mrb_iv_get(mrb, instance, mrb_intern_cstr(mrb, name))
+
+#define OBJECT_SET(mrb, instance, name, value) \
+  mrb_iv_set(mrb, instance, mrb_intern_cstr(mrb, name), value)
+
+#define OBJECT_REMOVE(mrb, instance, name) \
+  mrb_iv_remove(mrb, instance, mrb_intern_cstr(mrb, name))
+
+static int
+parser_settings_on_header_field(http_parser* parser, const char* at, size_t len)
+{
+  mrb_http_parser_context *context = (mrb_http_parser_context*) parser->data;
+  mrb_state* mrb = context->mrb;
+
+  int ai = mrb_gc_arena_save(mrb);
+  if (context->was_header_value) {
+    if (!mrb_nil_p(OBJECT_GET(mrb, context->instance, "last_header_field"))) {
+      mrb_str_concat(mrb, OBJECT_GET(mrb, context->instance, "last_header_field"), OBJECT_GET(mrb, context->instance, "last_header_value"));
+      OBJECT_SET(mrb, context->instance, "last_header_value", mrb_nil_value());
+    }
+    OBJECT_SET(mrb, context->instance, "last_header_field", mrb_str_new(mrb, at, len));
+    context->was_header_value = FALSE;
+  } else {
+    mrb_str_concat(mrb, OBJECT_GET(mrb, context->instance, "last_header_field"), mrb_str_new(mrb, at, len));
+  }
+  mrb_gc_arena_restore(mrb, ai);
+  return 0;
+}
+
+static int
+parser_settings_on_header_value(http_parser* parser, const char* at, size_t len)
+{
+  mrb_http_parser_context *context = (mrb_http_parser_context*) parser->data;
+  mrb_state* mrb = context->mrb;
+
+  int ai = mrb_gc_arena_save(mrb);
+  if(!context->was_header_value) {
+    OBJECT_SET(mrb, context->instance, "last_header_value", mrb_str_new(mrb, at, len));
+    context->was_header_value = TRUE;
+    mrb_hash_set(mrb, OBJECT_GET(mrb, context->instance, "headers"),
+        OBJECT_GET(mrb, context->instance, "last_header_field"),
+        OBJECT_GET(mrb, context->instance, "last_header_value"));
+  } else {
+    mrb_str_concat(mrb, OBJECT_GET(mrb, context->instance, "last_header_value"), mrb_str_new(mrb, at, len));
+  }
+  mrb_gc_arena_restore(mrb, ai);
+  return 0;
+}
+
+static int
+parser_settings_on_headers_complete(http_parser* parser)
+{
+  mrb_http_parser_context *context = (mrb_http_parser_context*) parser->data;
+  mrb_state* mrb = context->mrb;
+
+  int ai = mrb_gc_arena_save(mrb);
+  if(!mrb_nil_p(OBJECT_GET(mrb, context->instance, "last_header_field"))) {
+    mrb_hash_set(mrb, OBJECT_GET(mrb, context->instance, "headers"),
+        OBJECT_GET(mrb, context->instance, "last_header_field"),
+        OBJECT_GET(mrb, context->instance, "last_header_value"));
+  }
+  mrb_gc_arena_restore(mrb, ai);
+  return 0;
+}
+
+static int
+parser_settings_on_body(http_parser *parser, const char *p, size_t len)
+{
+  mrb_http_parser_context *context = (mrb_http_parser_context*) parser->data;
+  mrb_state* mrb = context->mrb;
+
+  int ai = mrb_gc_arena_save(mrb);
+  OBJECT_SET(mrb, context->instance, "body", mrb_str_new(mrb, p, len));
+  mrb_gc_arena_restore(mrb, ai);
+  return 0;
+}
+
+static int
+parser_settings_on_message_complete(http_parser* parser)
+{
+  mrb_http_parser_context *context = (mrb_http_parser_context*) parser->data;
+  mrb_state* mrb = context->mrb;
+  mrb_value c = context->instance;
+
+  if (context->handle.field_set & (1<<UF_SCHEMA)) {
+    OBJECT_SET(mrb, c, "schema", mrb_str_substr(mrb, OBJECT_GET(mrb, c, "buf"), context->handle.field_data[UF_SCHEMA].off, context->handle.field_data[UF_SCHEMA].len));
+  }
+  if (context->handle.field_set & (1<<UF_HOST)) {
+    OBJECT_SET(mrb, c, "host", mrb_str_substr(mrb, OBJECT_GET(mrb, c, "buf"), context->handle.field_data[UF_HOST].off, context->handle.field_data[UF_HOST].len));
+  }
+  if (context->handle.field_set & (1<<UF_HOST)) {
+    OBJECT_SET(mrb, c, "host", mrb_str_substr(mrb, OBJECT_GET(mrb, c, "buf"), context->handle.field_data[UF_HOST].off, context->handle.field_data[UF_HOST].len));
+  }
+  if (context->handle.field_set & (1<<UF_PORT)) {
+    OBJECT_SET(mrb, c, "port", mrb_fixnum_value(context->handle.port));
+  } else {
+    if (context->handle.field_set & (1<<UF_SCHEMA)) {
+      mrb_value schema = mrb_str_substr(mrb, OBJECT_GET(mrb, c, "buf"), context->handle.field_data[UF_SCHEMA].off, context->handle.field_data[UF_SCHEMA].len);
+      if (!mrb_nil_p(schema) && !strcmp("https", (char*) RSTRING_PTR(schema))) {
+        OBJECT_SET(mrb, c, "port", mrb_fixnum_value(443));
+      }
+    }
+  }
+  if (context->handle.field_set & (1<<UF_PATH)) {
+    OBJECT_SET(mrb, c, "path", mrb_str_substr(mrb, OBJECT_GET(mrb, c, "buf"), context->handle.field_data[UF_PATH].off, context->handle.field_data[UF_PATH].len));
+  }
+  if (context->handle.field_set & (1<<UF_QUERY)) {
+    OBJECT_SET(mrb, c, "query", mrb_str_substr(mrb, OBJECT_GET(mrb, c, "buf"), context->handle.field_data[UF_QUERY].off, context->handle.field_data[UF_QUERY].len));
+  }
+  if (context->parser.method)
+    OBJECT_SET(mrb, c, "method", mrb_str_new_cstr(mrb, http_method_str(context->parser.method)));
+  if (context->parser.status_code)
+    OBJECT_SET(mrb, c, "status_code", mrb_fixnum_value(context->parser.status_code));
+  if (context->parser.content_length)
+    OBJECT_SET(mrb, c, "content_length", mrb_fixnum_value(context->parser.content_length));
+  OBJECT_REMOVE(mrb, c, "last_header_field");
+  OBJECT_REMOVE(mrb, c, "last_header_value");
+  OBJECT_REMOVE(mrb, c, "buf");
+
+  return 0;
+}
+
+static mrb_value
+mrb_http_parser_init(mrb_state *mrb, mrb_value self)
+{
+  mrb_http_parser_context* context = NULL;
+
+  context = (mrb_http_parser_context*) malloc(sizeof(mrb_http_parser_context));
+  memset(context, 0, sizeof(mrb_http_parser_context));
+  context->mrb = mrb;
+  context->instance = mrb_nil_value();
+  mrb_iv_set(mrb, self, mrb_intern_cstr(mrb, "context"), mrb_obj_value(
+    Data_Wrap_Struct(mrb, mrb->object_class,
+    &http_parser_context_type, (void*) context)));
+  return self;
+}
+
+static mrb_value
+_http_parser_parse(mrb_state *mrb, mrb_value self, int type)
+{
+  mrb_value arg_data = mrb_nil_value();
+  mrb_value value_context;
+  mrb_http_parser_context* context;
+  mrb_value b = mrb_nil_value();
+  struct RClass* _class_http;
+  struct RClass* clazz;
+  char* data;
+  size_t len;
+  char* eol;
+  size_t done;
+
+  value_context = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "context"));
+  Data_Get_Struct(mrb, value_context, &http_parser_context_type, context);
+  if (!context) {
+    mrb_raise(mrb, E_ARGUMENT_ERROR, "invalid argument");
+  }
+
+  mrb_get_args(mrb, "|&o", &b, &arg_data);
+  if (mrb_nil_p(arg_data)) {
+    mrb_raise(mrb, E_ARGUMENT_ERROR, "invalid argument");
+  }
+  context->parser.data = context;
+
+  _class_http = mrb_module_get(mrb, "HTTP");
+  if (type == HTTP_REQUEST) {
+    clazz = mrb_class_ptr(mrb_const_get(mrb, mrb_obj_value(_class_http), mrb_intern_cstr(mrb, "Request")));
+    context->instance = mrb_obj_new(mrb, clazz, 0, NULL);
+  } else {
+    clazz = mrb_class_ptr(mrb_const_get(mrb, mrb_obj_value(_class_http), mrb_intern_cstr(mrb, "Response")));
+    context->instance = mrb_obj_new(mrb, clazz, 0, NULL);
+  }
+  context->was_header_value = TRUE;
+
+  http_parser_init(&context->parser, type);
+
+  context->type = type;
+  context->settings.on_url = parser_settings_on_url;
+  context->settings.on_header_field = parser_settings_on_header_field;
+  context->settings.on_header_value = parser_settings_on_header_value;
+  context->settings.on_headers_complete = parser_settings_on_headers_complete;
+  context->settings.on_body = parser_settings_on_body;
+  context->settings.on_message_complete = parser_settings_on_message_complete;
+
+  data = RSTRING_PTR(arg_data);
+  len = RSTRING_LEN(arg_data);
+
+  eol = strpbrk(data, "\r\n");
+  if (eol) {
+  }
+
+RETRY:
+  if (len > 10 && (!strncmp(data+9, "200 Connection established\r\n", 28) ||
+      !strncmp(data+9, "100 Continue\r\n", 14) || *(data+9) == '3')) {
+    char* next = strstr(data, "\r\n\r\n");
+    if (next) {
+      len -= (next + 4 - data);
+      data = next + 4;
+      goto RETRY;
+    }
+  }
+
+  done = http_parser_execute(&context->parser, &context->settings, data, len);
+  if (done < len) {
+    OBJECT_SET(mrb, context->instance, "body", mrb_str_new(mrb, data + done, len - done));
+  }
+
+  if (!mrb_nil_p(b)) {
+    mrb_value args[1];
+    args[0] = context->instance;
+    mrb_yield_argv(mrb, b, 1, args);
+    return mrb_nil_value();
+  }
+  return context->instance;
+}
+
+static mrb_value
+mrb_http_parser_parse_request(mrb_state *mrb, mrb_value self)
+{
+  return _http_parser_parse(mrb, self, HTTP_REQUEST);
+}
+
+static mrb_value
+mrb_http_parser_parse_response(mrb_state *mrb, mrb_value self)
+{
+  return _http_parser_parse(mrb, self, HTTP_RESPONSE);
+}
+
+static mrb_value
+mrb_http_parser_execute(mrb_state *mrb, mrb_value self)
+{
+  mrb_value arg_data;
+  mrb_value value_context;
+  mrb_http_parser_context* context;
+  size_t done;
+
+  value_context = mrb_iv_get(mrb, self, mrb_intern_cstr(mrb, "context"));
+  Data_Get_Struct(mrb, value_context, &http_parser_context_type, context);
+  if (!context) {
+    mrb_raise(mrb, E_ARGUMENT_ERROR, "invalid argument");
+  }
+
+  mrb_get_args(mrb, "o", &arg_data);
+  if (mrb_nil_p(arg_data)) {
+    mrb_raise(mrb, E_ARGUMENT_ERROR, "invalid argument");
+  }
+
+  done = http_parser_execute(&context->parser, &context->settings, (char*) RSTRING_PTR(arg_data), RSTRING_LEN(arg_data));
+
+  return mrb_fixnum_value(done);
+}
+
+static mrb_value
+mrb_http_parser_parse_url(mrb_state *mrb, mrb_value self)
+{
+  mrb_value c;
+  mrb_value arg_data;
+  struct http_parser_url handle = {0};
+  struct RClass* _class_http, *_class_http_url;
+
+  mrb_get_args(mrb, "S", &arg_data);
+
+  if (http_parser_parse_url(RSTRING_PTR(arg_data), RSTRING_LEN(arg_data), FALSE, &handle)) {
+    mrb_raise(mrb, E_ARGUMENT_ERROR, "invalid URL");
+  }
+
+  _class_http = mrb_module_get(mrb, "HTTP");
+  _class_http_url = mrb_class_ptr(mrb_const_get(mrb, mrb_obj_value(_class_http), mrb_intern_cstr(mrb, "URL")));
+
+  c = mrb_obj_new(mrb, _class_http_url, 0, NULL);
+
+  if (handle.field_set & (1<<UF_SCHEMA)) {
+    OBJECT_SET(mrb, c, "schema", mrb_str_substr(mrb, arg_data, handle.field_data[UF_SCHEMA].off, handle.field_data[UF_SCHEMA].len));
+  }
+  if (handle.field_set & (1<<UF_HOST)) {
+    OBJECT_SET(mrb, c, "host", mrb_str_substr(mrb, arg_data, handle.field_data[UF_HOST].off, handle.field_data[UF_HOST].len));
+  }
+  if (handle.field_set & (1<<UF_HOST)) {
+    OBJECT_SET(mrb, c, "host", mrb_str_substr(mrb, arg_data, handle.field_data[UF_HOST].off, handle.field_data[UF_HOST].len));
+  }
+  if (handle.field_set & (1<<UF_PORT)) {
+    OBJECT_SET(mrb, c, "port", mrb_fixnum_value(handle.port));
+  } else {
+    if (handle.field_set & (1<<UF_SCHEMA)) {
+      mrb_value schema = mrb_str_substr(mrb, arg_data, handle.field_data[UF_SCHEMA].off, handle.field_data[UF_SCHEMA].len);
+      if (!mrb_nil_p(schema) && !strcmp("https", (char*) RSTRING_PTR(schema))) {
+        OBJECT_SET(mrb, c, "port", mrb_fixnum_value(443));
+      }
+    }
+  }
+  if (handle.field_set & (1<<UF_PATH)) {
+    OBJECT_SET(mrb, c, "path", mrb_str_substr(mrb, arg_data, handle.field_data[UF_PATH].off, handle.field_data[UF_PATH].len));
+  }
+  if (handle.field_set & (1<<UF_QUERY)) {
+    OBJECT_SET(mrb, c, "query", mrb_str_substr(mrb, arg_data, handle.field_data[UF_QUERY].off, handle.field_data[UF_QUERY].len));
+  }
+  if (handle.field_set & (1<<UF_FRAGMENT)) {
+    OBJECT_SET(mrb, c, "fragment", mrb_str_substr(mrb, arg_data, handle.field_data[UF_FRAGMENT].off, handle.field_data[UF_FRAGMENT].len));
+  }
+
+  return c;
+}
+
+/*********************************************************
+ * object
+ *********************************************************/
+
+static mrb_value
+mrb_http_object_initialize(mrb_state *mrb, mrb_value self)
+{
+  OBJECT_SET(mrb, self, "headers", mrb_hash_new(mrb));
+  OBJECT_SET(mrb, self, "body", mrb_nil_value());
+  OBJECT_SET(mrb, self, "method", mrb_str_new_cstr(mrb, "GET"));
+  return self;
+}
+
+static mrb_value
+mrb_http_object_status_code_get(mrb_state *mrb, mrb_value self)
+{
+  return OBJECT_GET(mrb, self, "status_code");
+}
+
+static mrb_value
+mrb_http_object_message_get(mrb_state *mrb, mrb_value self)
+{
+  const char* message = NULL;
+  switch(mrb_fixnum(OBJECT_GET(mrb, self, "status_code"))) {
+    case 100: message = "Continue"; break;
+    case 101: message = "Switching Protocols"; break;
+    case 200: message = "OK"; break;
+    case 201: message = "Created"; break;
+    case 202: message = "Accepted"; break;
+    case 203: message = "Non-Authoritative Information"; break;
+    case 204: message = "No Content"; break;
+    case 205: message = "Reset Content"; break;
+    case 206: message = "Partial Content"; break;
+    case 300: message = "Multiple Choices"; break;
+    case 301: message = "Moved Permanently"; break;
+    case 302: message = "Found"; break;
+    case 303: message = "See Other"; break;
+    case 304: message = "Not Modified"; break;
+    case 305: message = "Use Proxy"; break;
+              //case 306: message = "(reserved)"; break;
+    case 307: message = "Temporary Redirect"; break;
+    case 400: message = "Bad Request"; break;
+    case 401: message = "Unauthorized"; break;
+    case 402: message = "Payment Required"; break;
+    case 403: message = "Forbidden"; break;
+    case 404: message = "Not Found"; break;
+    case 405: message = "Method Not Allowed"; break;
+    case 406: message = "Not Acceptable"; break;
+    case 407: message = "Proxy Authentication Required"; break;
+    case 408: message = "Request Timeout"; break;
+    case 409: message = "Conflict"; break;
+    case 410: message = "Gone"; break;
+    case 411: message = "Length Required"; break;
+    case 412: message = "Precondition Failed"; break;
+    case 413: message = "Request Entity Too Large"; break;
+    case 414: message = "Request-URI Too Long"; break;
+    case 415: message = "Unsupported Media Type"; break;
+    case 416: message = "Requested Range Not Satisfiable"; break;
+    case 417: message = "Expectation Failed"; break;
+    case 500: message = "Internal Server Error"; break;
+    case 501: message = "Not Implemented"; break;
+    case 502: message = "Bad Gateway"; break;
+    case 503: message = "Service Unavailable"; break;
+    case 504: message = "Gateway Timeout"; break;
+    case 505: message = "HTTP Version Not Supported"; break;
+    default: mrb_raise(mrb, E_RUNTIME_ERROR, "Not supported status code.");
+  }
+  return mrb_str_new_cstr(mrb, message);
+}
+
+static mrb_value
+mrb_http_object_content_length_get(mrb_state *mrb, mrb_value self)
+{
+  return OBJECT_GET(mrb, self, "content_length");
+}
+
+static mrb_value
+mrb_http_object_schema_get(mrb_state *mrb, mrb_value self)
+{
+  return OBJECT_GET(mrb, self, "schema");
+}
+
+static mrb_value
+mrb_http_object_host_get(mrb_state *mrb, mrb_value self)
+{
+  return OBJECT_GET(mrb, self, "host");
+}
+
+static mrb_value
+mrb_http_object_port_get(mrb_state *mrb, mrb_value self)
+{
+  return OBJECT_GET(mrb, self, "port");
+}
+
+static mrb_value
+mrb_http_object_path_get(mrb_state *mrb, mrb_value self)
+{
+  return OBJECT_GET(mrb, self, "path");
+}
+
+static mrb_value
+mrb_http_object_query_get(mrb_state *mrb, mrb_value self)
+{
+  return OBJECT_GET(mrb, self, "query");
+}
+
+static mrb_value
+mrb_http_object_fragment_get(mrb_state *mrb, mrb_value self)
+{
+  return OBJECT_GET(mrb, self, "fragment");
+}
+
+static mrb_value
+mrb_http_object_headers_get(mrb_state *mrb, mrb_value self)
+{
+  return OBJECT_GET(mrb, self, "headers");
+}
+
+static mrb_value
+mrb_http_object_headers_set_item(mrb_state *mrb, mrb_value self)
+{
+  mrb_value key, value;
+  mrb_get_args(mrb, "SS", &key, &value);
+  mrb_hash_set(mrb, OBJECT_GET(mrb, self, "headers"), key, value);
+  return mrb_nil_value();
+}
+
+static mrb_value
+mrb_http_object_method_get(mrb_state *mrb, mrb_value self)
+{
+  return OBJECT_GET(mrb, self, "method");
+}
+
+static mrb_value
+mrb_http_object_method_set(mrb_state *mrb, mrb_value self)
+{
+  mrb_value arg;
+  mrb_get_args(mrb, "S", &arg);
+  OBJECT_SET(mrb, self, "method", arg);
+  return mrb_nil_value();
+}
+
+static mrb_value
+mrb_http_object_body_get(mrb_state *mrb, mrb_value self)
+{
+  return OBJECT_GET(mrb, self, "body");
+}
+
+static mrb_value
+mrb_http_object_body_set(mrb_state *mrb, mrb_value self)
+{
+  mrb_value arg;
+  mrb_get_args(mrb, "S", &arg);
+  OBJECT_SET(mrb, self, "body", arg);
+  return mrb_nil_value();
+}
+
+/*********************************************************
+ * response
+ *********************************************************/
+
+/*********************************************************
+ * url
+ *********************************************************/
+
+static int
+from_hex(char c) {
+  if (c >= '0' && c <= '9') return (c - '0');
+  if (c >= 'a' && c<= 'f') return (c - 'a' + 10);
+  if (c >= 'A' && c<= 'F') return (c - 'A' + 10);
+  return 256;
+}
+
+static char
+to_hex(char code) {
+  static char hex[] = "0123456789abcdef";
+  return hex[code & 15];
+}
+
+static mrb_value
+mrb_http_url_encode(mrb_state *mrb, mrb_value self) {
+  mrb_value arg;
+  char* str;
+  char *pstr, *buf, *pbuf;
+  size_t len;
+
+  mrb_get_args(mrb, "S", &arg);
+  str = RSTRING_PTR(arg);
+  len = RSTRING_LEN(arg);
+
+  pstr = str;
+  buf = malloc(strlen(str) * 3 + 1);
+  pbuf = buf;
+  while (pstr - str < len) {
+    char c = *pstr;
+    if ((('a' <= c && c <= 'z') ||
+         ('A' <= c && c <= 'Z') ||
+         ('0' <= c && c <= '9')) ||
+        c == '-' || c == '_' || c == '.' || c == '~') 
+      *pbuf++ = *pstr;
+    else if (c == ' ') 
+      *pbuf++ = '+';
+    else 
+      *pbuf++ = '%', *pbuf++ = to_hex(*pstr >> 4), *pbuf++ = to_hex(*pstr & 15);
+    pstr++;
+  }
+  *pbuf = '\0';
+  arg = mrb_str_new(mrb, buf, pbuf - buf);
+  free(buf);
+  return arg;
+}
+
+static mrb_value
+mrb_http_url_decode(mrb_state *mrb, mrb_value self) {
+  mrb_value arg;
+  char* str;
+  char *pstr, *buf, *pbuf;
+  size_t len;
+
+  mrb_get_args(mrb, "S", &arg);
+  str = RSTRING_PTR(arg);
+  len = RSTRING_LEN(arg);
+
+  pstr = str;
+  buf = malloc(len + 1);
+  pbuf = buf;
+  while (pstr - str < len) {
+    if (*pstr == '%' && pstr - str + 2 < len) {
+      int newc  = from_hex(pstr[1]) << 4 | from_hex(pstr[2]);
+      if (newc > 255)
+        *pbuf++ = '%';
+      else {
+        *pbuf++ = newc;
+        pstr += 2;
+      }
+    } else if (*pstr == '+') { 
+      *pbuf++ = ' ';
+    } else {
+      *pbuf++ = *pstr;
+    }
+    pstr++;
+  }
+  *pbuf = '\0';
+  arg = mrb_str_new(mrb, buf, pbuf - buf);
+  free(buf);
+  return arg;
+}
+
+/*********************************************************
+ * register
+ *********************************************************/
+
+void
+mrb_mruby_http_gem_init(mrb_state* mrb) {
+
+  struct RClass* _class_http;
+  struct RClass* _class_http_parser;
+  struct RClass* _class_http_request;
+  struct RClass* _class_http_response;
+  struct RClass *_class_http_url;
+  int ai = mrb_gc_arena_save(mrb);
+
+  _class_http = mrb_define_module(mrb, "HTTP");
+  _class_http_parser = mrb_define_class_under(mrb, _class_http, "Parser", mrb->object_class);
+  mrb_define_method(mrb, _class_http_parser, "initialize", mrb_http_parser_init, ARGS_OPT(1));
+  mrb_define_method(mrb, _class_http_parser, "parse_request", mrb_http_parser_parse_request, ARGS_OPT(2));
+  mrb_define_method(mrb, _class_http_parser, "parse_response", mrb_http_parser_parse_response, ARGS_OPT(2));
+  mrb_define_method(mrb, _class_http_parser, "parse_url", mrb_http_parser_parse_url, ARGS_REQ(1));
+  mrb_define_method(mrb, _class_http_parser, "execute", mrb_http_parser_execute, ARGS_REQ(1));
+  mrb_gc_arena_restore(mrb, ai);
+
+  _class_http_request = mrb_define_class_under(mrb, _class_http, "Request", mrb->object_class);
+  mrb_define_method(mrb, _class_http_request, "initialize", mrb_http_object_initialize, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_request, "schema", mrb_http_object_schema_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_request, "host", mrb_http_object_host_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_request, "port", mrb_http_object_port_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_request, "path", mrb_http_object_path_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_request, "query", mrb_http_object_query_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_request, "headers", mrb_http_object_headers_get, ARGS_NONE());
+  //mrb_define_method(mrb, _class_http_request, "headers[]=", mrb_http_object_headers_set_item, ARGS_REQ(2));
+  mrb_define_method(mrb, _class_http_request, "method", mrb_http_object_method_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_request, "method=", mrb_http_object_method_set, ARGS_REQ(1));
+  mrb_define_method(mrb, _class_http_request, "body", mrb_http_object_body_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_request, "body=", mrb_http_object_body_set, ARGS_REQ(1));
+  mrb_gc_arena_restore(mrb, ai);
+
+  _class_http_response = mrb_define_class_under(mrb, _class_http, "Response", mrb->object_class);
+  mrb_define_method(mrb, _class_http_response, "initialize", mrb_http_object_initialize, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_response, "status_code", mrb_http_object_status_code_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_response, "message", mrb_http_object_message_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_response, "content_length", mrb_http_object_content_length_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_response, "schema", mrb_http_object_schema_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_response, "host", mrb_http_object_host_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_response, "port", mrb_http_object_port_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_response, "path", mrb_http_object_path_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_response, "query", mrb_http_object_query_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_response, "headers", mrb_http_object_headers_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_response, "method", mrb_http_object_method_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_response, "body", mrb_http_object_body_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_response, "body=", mrb_http_object_body_set, ARGS_REQ(1));
+  mrb_gc_arena_restore(mrb, ai);
+
+  _class_http_url = mrb_define_class_under(mrb, _class_http, "URL", mrb->object_class);
+  mrb_define_method(mrb, _class_http_url, "schema", mrb_http_object_schema_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_url, "host", mrb_http_object_host_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_url, "port", mrb_http_object_port_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_url, "path", mrb_http_object_path_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_url, "query", mrb_http_object_query_get, ARGS_NONE());
+  mrb_define_method(mrb, _class_http_url, "fragment", mrb_http_object_fragment_get, ARGS_NONE());
+  //mrb_define_method(mrb, _class_http_url, "to_url", mrb_http_url_to_url, ARGS_NONE());
+  mrb_define_class_method(mrb, _class_http_url, "encode", mrb_http_url_encode, ARGS_REQ(1));
+  mrb_define_class_method(mrb, _class_http_url, "decode", mrb_http_url_decode, ARGS_REQ(1));
+  mrb_gc_arena_restore(mrb, ai);
+}
+
+void
+mrb_mruby_http_gem_final(mrb_state* mrb) {
+}
+
+/* vim:set et ts=2 sts=2 sw=2 tw=0: */
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/HEAD	2014-06-20 19:04:01.294491316 -0700
@@ -0,0 +1 @@
+ref: refs/heads/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/config mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/config
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/config	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/config	2014-06-20 19:04:01.294491316 -0700
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = https://github.com/iij/mruby-io.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/description mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/description
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/description	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/description	2014-06-20 19:03:57.261142142 -0700
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/applypatch-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/applypatch-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/applypatch-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/applypatch-msg.sample	2014-06-20 19:03:57.261142142 -0700
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/commit-msg" &&
+	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
+:
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/commit-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/commit-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/commit-msg.sample	2014-06-20 19:03:57.261142142 -0700
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/post-update.sample mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/post-update.sample
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/post-update.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/post-update.sample	2014-06-20 19:03:57.261142142 -0700
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/pre-applypatch.sample mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/pre-applypatch.sample
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/pre-applypatch.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/pre-applypatch.sample	2014-06-20 19:03:57.261142142 -0700
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
+:
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/pre-commit.sample mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/pre-commit.sample
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/pre-commit.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/pre-commit.sample	2014-06-20 19:03:57.261142142 -0700
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/pre-push.sample mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/pre-push.sample
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/pre-push.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/pre-push.sample	2014-06-20 19:03:57.261142142 -0700
@@ -0,0 +1,54 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+IFS=' '
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/pre-rebase.sample mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/pre-rebase.sample
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/pre-rebase.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/pre-rebase.sample	2014-06-20 19:03:57.261142142 -0700
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up-to-date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+exit 0
+
+################################################################
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/prepare-commit-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/prepare-commit-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/prepare-commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/prepare-commit-msg.sample	2014-06-20 19:03:57.261142142 -0700
@@ -0,0 +1,36 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples.  The first comments out the
+# "Conflicts:" part of a merge commit.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+case "$2,$3" in
+  merge,)
+    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
+
+# ,|template,)
+#   /usr/bin/perl -i.bak -pe '
+#      print "\n" . `git diff --cached --name-status -r`
+#	 if /^#/ && $first++ == 0' "$1" ;;
+
+  *) ;;
+esac
+
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/update.sample mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/update.sample
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/hooks/update.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/hooks/update.sample	2014-06-20 19:03:57.261142142 -0700
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to blocks unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
Binary files mruby-1.0.0/build/mrbgems/mruby-io/.git/index and mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/index differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/info/exclude mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/info/exclude
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/info/exclude	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/info/exclude	2014-06-20 19:03:57.261142142 -0700
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/logs/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/logs/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/logs/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/logs/HEAD	2014-06-20 19:04:01.294491316 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 ddfc4eb5ef170e7eabc7b545366cac389139f044 Daniel Bittman <danielbittman1@gmail.com> 1403316241 -0700	clone: from https://github.com/iij/mruby-io.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/logs/refs/heads/master mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/logs/refs/heads/master
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/logs/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/logs/refs/heads/master	2014-06-20 19:04:01.294491316 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 ddfc4eb5ef170e7eabc7b545366cac389139f044 Daniel Bittman <danielbittman1@gmail.com> 1403316241 -0700	clone: from https://github.com/iij/mruby-io.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/logs/refs/remotes/origin/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/logs/refs/remotes/origin/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/logs/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/logs/refs/remotes/origin/HEAD	2014-06-20 19:04:01.294491316 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 ddfc4eb5ef170e7eabc7b545366cac389139f044 Daniel Bittman <danielbittman1@gmail.com> 1403316241 -0700	clone: from https://github.com/iij/mruby-io.git
Binary files mruby-1.0.0/build/mrbgems/mruby-io/.git/objects/pack/pack-2592ff283d2e427935b6bee51a3ac4f0a4f330a6.idx and mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/objects/pack/pack-2592ff283d2e427935b6bee51a3ac4f0a4f330a6.idx differ
Binary files mruby-1.0.0/build/mrbgems/mruby-io/.git/objects/pack/pack-2592ff283d2e427935b6bee51a3ac4f0a4f330a6.pack and mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/objects/pack/pack-2592ff283d2e427935b6bee51a3ac4f0a4f330a6.pack differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/packed-refs mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/packed-refs
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/packed-refs	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/packed-refs	2014-06-20 19:04:01.294491316 -0700
@@ -0,0 +1,2 @@
+# pack-refs with: peeled fully-peeled 
+ddfc4eb5ef170e7eabc7b545366cac389139f044 refs/remotes/origin/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/refs/heads/master mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/refs/heads/master
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/refs/heads/master	2014-06-20 19:04:01.294491316 -0700
@@ -0,0 +1 @@
+ddfc4eb5ef170e7eabc7b545366cac389139f044
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.git/refs/remotes/origin/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/refs/remotes/origin/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-io/.git/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.git/refs/remotes/origin/HEAD	2014-06-20 19:04:01.294491316 -0700
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.gitignore mruby-1.0.0-seaos/build/mrbgems/mruby-io/.gitignore
--- mruby-1.0.0/build/mrbgems/mruby-io/.gitignore	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.gitignore	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1 @@
+/tmp
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/.travis.yml mruby-1.0.0-seaos/build/mrbgems/mruby-io/.travis.yml
--- mruby-1.0.0/build/mrbgems/mruby-io/.travis.yml	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/.travis.yml	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1,2 @@
+script:
+  - "ruby run_test.rb all test"
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/README.md mruby-1.0.0-seaos/build/mrbgems/mruby-io/README.md
--- mruby-1.0.0/build/mrbgems/mruby-io/README.md	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/README.md	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1,185 @@
+mruby-io
+========
+
+IO, File module for mruby
+
+
+## Implemented methods
+
+### IO
+ - http://doc.ruby-lang.org/ja/1.9.3/class/IO.html
+
+| method                     | mruby-io | memo |
+| -------------------------  | -------- | ---- |
+| IO.binread                 |          |      |
+| IO.binwrite                |          |      |
+| IO.copy_stream             |          |      |
+| IO.new, IO.for_fd, IO.open |  o  |     |
+| IO.foreach                 |          |      |
+| IO.pipe                    |          |      |
+| IO.popen                   |    o     |      |
+| IO.read                    |    o     |      |
+| IO.readlines               |          |      |
+| IO.select                  |          |      |
+| IO.sysopen                 |    o     |      |
+| IO.try_convert             |          |      |
+| IO.write                   |          |      |
+| IO#<<                      |          |      |
+| IO#advise                  |          |      |
+| IO#autoclose=              |          |      |
+| IO#autoclose?              |          |      |
+| IO#binmode                 |          |      |
+| IO#binmode?                |          |      |
+| IO#bytes                   |          | obsolete |
+| IO#chars                   |          | obsolete |
+| IO#clone, IO#dup           |          |      |
+| IO#close                   |    o     |      |
+| IO#close_on_exec=          |          |      |
+| IO#close_on_exec?          |          |      |
+| IO#close_read              |          |      |
+| IO#close_write             |          |      |
+| IO#closed?                 |    o     |      |
+| IO#codepoints              |          | obsolete |
+| IO#each_byte               |    o     |      |
+| IO#each_char               |    o     |      |
+| IO#each_codepoint          |          |      |
+| IO#each_line               |    o     |      |
+| IO#eof, IO#eof?            |    o     |      |
+| IO#external_encoding       |          |      |
+| IO#fcntl                   |          |      |
+| IO#fdatasync               |          |      |
+| IO#fileno, IO#to_i         |          |      |
+| IO#flush                   |          |      |
+| IO#fsync                   |          |      |
+| IO#getbyte                 |          |      |
+| IO#getc                    |    o     |      |
+| IO#gets                    |    o     |      |
+| IO#internal_encoding       |          |      |
+| IO#ioctl                   |          |      |
+| IO#isatty, IO#tty?         |          |      |
+| IO#lineno                  |          |      |
+| IO#lineno=                 |          |      |
+| IO#lines                   |          | obsolete |
+| IO#pid                     |    o     |      |
+| IO#pos, IO#tell            |    o     |      |
+| IO#pos=                    |    o     |      |
+| IO#print                   |    o     |      |
+| IO#printf                  |    o     |      |
+| IO#putc                    |          |      |
+| IO#puts                    |    o     |      |
+| IO#read                    |    o     |      |
+| IO#read_nonblock           |          |      |
+| IO#readbyte                |          |      |
+| IO#readchar                |    o     |      |
+| IO#readline                |    o     |      |
+| IO#readlines               |    o     |      |
+| IO#readpartial             |          |      |
+| IO#reopen                  |          |      |
+| IO#rewind                  |          |      |
+| IO#seek                    |    o     |      |
+| IO#set_encoding            |          |      |
+| IO#stat                    |          |      |
+| IO#sync                    |          |      |
+| IO#sync=                   |          |      |
+| IO#sysread                 |    o     |      |
+| IO#sysseek                 |    o     |      |
+| IO#syswrite                |    o     |      |
+| IO#to_io                   |          |      |
+| IO#ungetbyte               |          |      |
+| IO#ungetc                  |    o     |      |
+| IO#write                   |    o     |      |
+| IO#write_nonblock          |          |      |
+
+### File
+ - http://doc.ruby-lang.org/ja/1.9.3/class/File.html
+
+| method                      | mruby-io | memo |
+| --------------------------- | -------- | ---- |
+| File.absolute_path          |          |      |
+| File.atime                  |          |      |
+| File.basename               |   o      |      |
+| File.blockdev?              |          | FileTest |
+| File.chardev?               |          | FileTest |
+| File.chmod                  |          |      |
+| File.chown                  |          |      |
+| File.ctime                  |          |      |
+| File.delete, File.unlink    |   o      |      |
+| File.directory?             |   o      | FileTest |
+| File.dirname                |   o      |      |
+| File.executable?            |          | FileTest |
+| File.executable_real?       |          | FileTest |
+| File.exist?, exists?        |   o      | FileTest |
+| File.expand_path            |          |      |
+| File.extname                |   o      |      |
+| File.file?                  |   o      | FileTest |
+| File.fnmatch, File.fnmatch? |          |      |
+| File.ftype                  |          |      |
+| File.grpowned?              |          | FileTest |
+| File.identical?             |          | FileTest |
+| File.join                   |   o      |      |
+| File.lchmod                 |          |      |
+| File.lchown                 |          |      |
+| File.link                   |          |      |
+| File.lstat                  |          |      |
+| File.mtime                  |          |      |
+| File.new, File.open         |   o      |      |
+| File.owned?                 |          | FileTest |
+| File.path                   |          |      |
+| File.pipe?                  |   o      | FileTest |
+| File.readable?              |          | FileTest |
+| File.readable_real?         |          | FileTest |
+| File.readlink               |          |      |
+| File.realdirpath            |          |      |
+| File.realpath               |   o      |      |
+| File.rename                 |   o      |      |
+| File.setgid?                |          | FileTest |
+| File.setuid?                |          | FileTest |
+| File.size                   |   o      |      |
+| File.size?                  |   o      | FileTest |
+| File.socket?                |   o      | FileTest |
+| File.split                  |          |      |
+| File.stat                   |          |      |
+| File.sticky?                |          | FileTest |
+| File.symlink                |          |      |
+| File.symlink?               |   o      | FileTest |
+| File.truncate               |          |      |
+| File.umask                  |   o      |      |
+| File.utime                  |          |      |
+| File.world_readable?        |          |      |
+| File.world_writable?        |          |      |
+| File.writable?              |          | FileTest |
+| File.writable_real?         |          | FileTest |
+| File.zero?                  |   o      | FileTest |
+| File#atime                  |          |      |
+| File#chmod                  |          |      |
+| File#chown                  |          |      |
+| File#ctime                  |          |      |
+| File#flock                  |   o      |      |
+| File#lstat                  |          |      |
+| File#mtime                  |          |      |
+| File#path, File#to_path     |   o      |      |
+| File#size                   |          |      |
+| File#truncate               |          |      |
+
+
+## License
+
+Copyright (c) 2013 Internet Initiative Japan Inc.
+
+Permission is hereby granted, free of charge, to any person obtaining a 
+copy of this software and associated documentation files (the "Software"), 
+to deal in the Software without restriction, including without limitation 
+the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+and/or sell copies of the Software, and to permit persons to whom the 
+Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in 
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+DEALINGS IN THE SOFTWARE.
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/include/mruby/ext/io.h mruby-1.0.0-seaos/build/mrbgems/mruby-io/include/mruby/ext/io.h
--- mruby-1.0.0/build/mrbgems/mruby-io/include/mruby/ext/io.h	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/include/mruby/ext/io.h	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1,36 @@
+/*
+** io.h - IO class
+*/
+
+#ifndef MRUBY_IO_H
+#define MRUBY_IO_H
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+struct mrb_io {
+  int fd;   /* file descriptor, or -1 */
+  int fd2;  /* file descriptor to write if it's different from fd, or -1 */
+  int pid;  /* child's pid (for pipes)  */
+  unsigned int writable:1;
+};
+
+#define FMODE_READABLE             0x00000001
+#define FMODE_WRITABLE             0x00000002
+#define FMODE_READWRITE            (FMODE_READABLE|FMODE_WRITABLE)
+#define FMODE_BINMODE              0x00000004
+#define FMODE_SYNC                 0x00000008
+#define FMODE_APPEND               0x00000040
+#define FMODE_CREATE               0x00000080
+#define FMODE_TRUNC                0x00000800
+
+#define E_IO_ERROR                 (mrb_class_get(mrb, "IOError"))
+#define E_EOF_ERROR                (mrb_class_get(mrb, "EOFError"))
+
+mrb_value mrb_io_fileno(mrb_state *mrb, mrb_value io);
+
+#if defined(__cplusplus)
+} /* extern "C" { */
+#endif
+#endif /* MRUBY_IO_H */
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/mrbgem.rake mruby-1.0.0-seaos/build/mrbgems/mruby-io/mrbgem.rake
--- mruby-1.0.0/build/mrbgems/mruby-io/mrbgem.rake	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/mrbgem.rake	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1,14 @@
+MRuby::Gem::Specification.new('mruby-io') do |spec|
+  spec.license = 'MIT'
+  spec.authors = 'Internet Initiative Japan Inc.'
+
+  spec.cc.include_paths << "#{build.root}/src"
+  
+  case RUBY_PLATFORM
+  when /mingw|mswin/
+    spec.linker.libraries += ['Ws2_32']
+    #spec.cc.include_paths += ["C:/Windows/system/include"]
+    spec.linker.library_paths += ["C:/Windows/system"]
+  end
+
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/mrblib/file.rb mruby-1.0.0-seaos/build/mrbgems/mruby-io/mrblib/file.rb
--- mruby-1.0.0/build/mrbgems/mruby-io/mrblib/file.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/mrblib/file.rb	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1,176 @@
+class File < IO
+  include Enumerable
+
+  class FileError < Exception; end
+  class NoFileError < FileError; end
+  class UnableToStat < FileError; end
+  class PermissionError < FileError; end
+
+  attr_accessor :path
+
+  def initialize(fd_or_path, mode = "r", perm = 0666)
+    if fd_or_path.kind_of? Fixnum
+      super(fd_or_path, mode)
+    else
+      @path = fd_or_path
+      begin
+        fd = IO.sysopen(@path, mode, perm)
+      rescue RuntimeError => e
+        raise FileError, "Could not open file (#{e})"
+      rescue Errno::EMFILE, Errno::ENFILE
+        GC.start
+        fd = IO.sysopen(@path, mode, perm)
+      end
+      super(fd, mode)
+    end
+  end
+
+  def self.join(*names)
+    if names.size == 0
+      ""
+    elsif names.size == 1
+      names[0]
+    else
+      if names[0][-1] == File::SEPARATOR
+        s = names[0][0..-2]
+      else
+        s = names[0].dup
+      end
+      (1..names.size-2).each { |i|
+        t = names[i]
+        if t[0] == File::SEPARATOR and t[-1] == File::SEPARATOR
+          t = t[1..-2]
+        elsif t[0] == File::SEPARATOR
+          t = t[1..-1]
+        elsif t[-1] == File::SEPARATOR
+          t = t[0..-2]
+        end
+        s += File::SEPARATOR + t if t != ""
+      }
+      if names[-1][0] == File::SEPARATOR
+        s += File::SEPARATOR + names[-1][1..-1]
+      else
+        s += File::SEPARATOR + names[-1]
+      end
+      s
+    end
+  end
+
+  def self.expand_path(path, default_dir = '.')
+    def concat_path(path, base_path)
+      if path[0] == "/" || path[1] == ':' # Windows root!
+        expanded_path = path
+      elsif path[0] == "~"
+        if (path[1] == "/" || path[1] == nil)
+          dir = path[1, path.size]
+          home_dir = _gethome
+
+          unless home_dir
+            raise ArgumentError, "couldn't find HOME environment -- expanding '~'"
+          end
+
+          expanded_path = home_dir
+          expanded_path += dir if dir
+          expanded_path += "/"
+        else
+          splitted_path = path.split("/")
+          user = splitted_path[0][1, splitted_path[0].size]
+          dir = "/" + splitted_path[1, splitted_path.size].join("/")
+
+          home_dir = _gethome(user)
+
+          unless home_dir
+            raise ArgumentError, "user #{user} doesn't exist"
+          end
+
+          expanded_path = home_dir
+          expanded_path += dir if dir
+          expanded_path += "/"
+        end
+      else
+        expanded_path = concat_path(base_path, _getwd)
+        expanded_path += "/" + path
+      end
+
+      expanded_path
+    end
+
+    expanded_path = concat_path(path, default_dir)
+    expand_path_array = []
+    while expanded_path.include?('//')
+      expanded_path = expanded_path.gsub('//', '/')
+    end
+
+    if expanded_path == "/"
+      expanded_path
+    else
+      expanded_path.split('/').each do |path_token|
+        if path_token == '..'
+          if expand_path_array.size > 1
+            expand_path_array.pop
+          end
+        elsif path_token == '.'
+          # nothing to do.
+        else
+          expand_path_array << path_token
+        end
+      end
+
+      expand_path = expand_path_array.join("/")
+      expand_path.empty? ? '/' : expand_path
+    end
+  end
+
+  def self.foreach(file)
+    if block_given?
+      self.open(file) do |f|
+        f.each {|l| yield l}
+      end
+    else
+      return self.new(file)
+    end
+  end
+
+  def self.directory?(file)
+    FileTest.directory?(file)
+  end
+
+  def self.exist?(file)
+    FileTest.exist?(file)
+  end
+
+  def self.exists?(file)
+    FileTest.exists?(file)
+  end
+
+  def self.file?(file)
+    FileTest.file?(file)
+  end
+
+  def self.pipe?(file)
+    FileTest.pipe?(file)
+  end
+
+  def self.size?(file)
+    FileTest.size?(file)
+  end
+
+  def self.socket?(file)
+    FileTest.socket?(file)
+  end
+
+  def self.symlink?(file)
+    FileTest.symlink?(file)
+  end
+
+  def self.zero?(file)
+    FileTest.zero?(file)
+  end
+
+  def self.extname(filename)
+    fname = self.basename(filename)
+    return '' if fname[0] == '.' || fname.index('.').nil?
+    ext = fname.split('.').last
+    ext.empty? ? '' : ".#{ext}"
+  end
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/mrblib/file_constants.rb mruby-1.0.0-seaos/build/mrbgems/mruby-io/mrblib/file_constants.rb
--- mruby-1.0.0/build/mrbgems/mruby-io/mrblib/file_constants.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/mrblib/file_constants.rb	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1,31 @@
+class File
+  module Constants
+    NULL = "/dev/null"
+
+    RDONLY   = 0
+    WRONLY   = 1
+    RDWR     = 2
+    NONBLOCK = 4
+    APPEND   = 8
+
+    BINARY   = 0
+    SYNC     = 128
+    NOFOLLOW = 256
+    CREAT    = 512
+    TRUNC    = 1024
+    EXCL     = 2048
+
+    NOCTTY   = 131072
+    DSYNC    = 4194304
+
+    FNM_SYSCASE  = 0
+    FNM_NOESCAPE = 1
+    FNM_PATHNAME = 2
+    FNM_DOTMATCH = 4
+    FNM_CASEFOLD = 8
+  end
+end
+
+class File
+  include File::Constants
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/mrblib/io.rb mruby-1.0.0-seaos/build/mrbgems/mruby-io/mrblib/io.rb
--- mruby-1.0.0/build/mrbgems/mruby-io/mrblib/io.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/mrblib/io.rb	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1,374 @@
+##
+# IO
+
+class IOError < StandardError; end
+class EOFError < IOError; end
+
+class IO
+  SEEK_SET = 0
+  SEEK_CUR = 1
+  SEEK_END = 2
+
+  BUF_SIZE = 4096
+
+  def self.for_fd *args
+    self.new(*args)
+  end
+
+  def self.open(*args, &block)
+    io = self.new(*args)
+
+    return io unless block
+
+    begin
+      yield io
+    ensure
+      begin
+        io.close unless io.closed?
+      rescue StandardError
+      end
+    end
+  end
+
+  def self.popen(command, mode = 'r', &block)
+    io = self._popen(command, mode)
+    return io unless block
+
+    begin
+      yield io
+    ensure
+      begin
+        io.close unless io.closed?
+      rescue IOError
+        # nothing
+      end
+    end
+  end
+
+
+  def self.read(path, length=nil, offset=nil, opt=nil)
+    if not opt.nil?        # 4 arguments
+      offset ||= 0
+    elsif not offset.nil?  # 3 arguments
+      if offset.is_a? Hash
+        opt = offset
+        offset = 0
+      else
+        opt = {}
+      end
+    elsif not length.nil?  # 2 arguments
+      if length.is_a? Hash
+        opt = length
+        offset = 0
+        length = nil
+      else
+        offset = 0
+        opt = {}
+      end
+    else                   # only 1 argument
+      opt = {}
+      offset = 0
+      length = nil
+    end
+
+    str = ""
+    fd = -1
+    io = nil
+    begin
+      if path[0] == "|"
+        io = IO.popen(path[1..-1], (opt[:mode] || "r"))
+      else
+        fd = IO.sysopen(path)
+        io = IO.open(fd, opt[:mode] || "r")
+      end
+      io.seek(offset) if offset > 0
+      str = io.read(length)
+    ensure
+      if io
+        io.close
+      elsif fd != -1
+        IO._sysclose(fd)
+      end
+    end
+    str
+  end
+
+  def flush
+    # mruby-io always writes immediately (no output buffer).
+    raise IOError, "closed stream" if self.closed?
+    self
+  end
+
+  def write(string)
+    str = string.is_a?(String) ? string : string.to_s
+    return str.size unless str.size > 0
+
+    len = syswrite(str)
+    if len != -1
+      @pos += len
+      return len
+    end
+
+    raise IOError
+  end
+
+  def eof?
+    return true if @buf && @buf.size > 0
+
+    ret = false
+    char = ''
+
+    begin
+      char = sysread(1)
+    rescue EOFError => e
+      ret = true
+    ensure
+      _ungets(char)
+    end
+
+    ret
+  end
+  alias_method :eof, :eof?
+
+  def pos
+    raise IOError if closed?
+    @pos
+  end
+  alias_method :tell, :pos
+
+  def pos=(i)
+    seek(i, SEEK_SET)
+  end
+
+  def seek(i, whence = SEEK_SET)
+    raise IOError if closed?
+    @pos = sysseek(i, whence)
+    @buf = ''
+    0
+  end
+
+  def _read_buf
+    return @buf if @buf && @buf.size > 0
+    @buf = sysread(BUF_SIZE)
+  end
+
+  def _ungets(substr)
+    raise TypeError.new "expect String, got #{substr.class}" unless substr.is_a?(String)
+    raise IOError if @pos == 0 || @pos.nil?
+    @pos -= substr.size
+    if @buf.empty?
+      @buf = substr
+    else
+      @buf = substr + @buf
+    end
+    nil
+  end
+
+  def ungetc(char)
+    raise IOError if @pos == 0 || @pos.nil?
+    _ungets(char)
+    nil
+  end
+
+  def read(length = nil)
+    unless length.nil?
+      unless length.is_a? Fixnum
+        raise TypeError.new "can't convert #{length.class} into Integer"
+      end
+      if length < 0
+        raise ArgumentError.new "negative length: #{length} given"
+      end
+      if length == 0
+        return ""   # easy case
+      end
+    end
+
+    str = ''
+    while 1
+      begin
+        _read_buf
+      rescue EOFError => e
+        str = nil if str.empty? and (not length.nil?) and length != 0
+        break
+      end
+
+      if length && (str.size + @buf.size) >= length
+        len = length - str.size
+        str += @buf[0, len]
+        @pos += len
+        @buf = @buf[len, @buf.size - len]
+        break
+      else
+        str += @buf
+        @pos += @buf.size
+        @buf = ''
+      end
+    end
+
+    str
+  end
+
+  def readline(arg = $/, limit = nil)
+    case arg
+    when String
+      rs = arg
+    when Fixnum
+      rs = $/
+      limit = arg
+    else
+      raise ArgumentError
+    end
+
+    if rs.nil?
+      return read
+    end
+
+    if rs == ""
+      rs = $/ + $/
+    end
+
+    str = ""
+    while 1
+      begin
+        _read_buf
+      rescue EOFError => e
+        str = nil  if str.empty?
+        break
+      end
+
+      if limit && (str.size + @buf.size) >= limit
+        len = limit - str.size
+        str += @buf[0, len]
+        @pos += len
+        @buf = @buf[len, @buf.size - len]
+        break
+      elsif idx = @buf.index(rs)
+        len = idx + rs.size
+        str += @buf[0, len]
+        @pos += len
+        @buf = @buf[len, @buf.size - len]
+        break
+      else
+        str += @buf
+        @pos += @buf.size
+        @buf = ''
+      end
+    end
+
+    raise EOFError.new "end of file reached" if str.nil?
+
+    str
+  end
+
+  def gets(*args)
+    begin
+      readline(*args)
+    rescue EOFError => e
+      nil
+    end
+  end
+
+  def readchar
+    _read_buf
+    c = @buf[0]
+    @buf = @buf[1, @buf.size]
+    @pos += 1
+    c
+  end
+
+  def getc
+    begin
+      readchar
+    rescue EOFError => e
+      nil
+    end
+  end
+
+  # 15.2.20.5.3
+  def each(&block)
+    while line = self.gets
+      block.call(line)
+    end
+    self
+  end
+
+  # 15.2.20.5.4
+  def each_byte(&block)
+    while char = self.getc
+      block.call(char)
+    end
+    self
+  end
+
+  # 15.2.20.5.5
+  alias each_line each
+
+  alias each_char each_byte
+
+  def readlines
+    ary = []
+    while (line = gets)
+      ary << line
+    end
+    ary
+  end
+
+  def puts(*args)
+    i = 0
+    len = args.size
+    while i < len
+      s = args[i].to_s
+      write s
+      write "\n" if (s[-1] != "\n")
+      i += 1
+    end
+    write "\n" if len == 0
+    nil
+  end
+
+  def print(*args)
+    i = 0
+    len = args.size
+    while i < len
+      write args[i].to_s
+      i += 1
+    end
+  end
+
+  def printf(*args)
+    write sprintf(*args)
+    nil
+  end
+
+  alias_method :to_i, :fileno
+end
+
+STDIN  = IO.open(0, "r")
+STDOUT = IO.open(1, "w")
+STDERR = IO.open(2, "w")
+
+$stdin  = STDIN
+$stdout = STDOUT
+$stderr = STDERR
+
+module Kernel
+  def print(*args)
+    STDOUT.print(*args)
+  end
+
+  def puts(*args)
+    STDOUT.puts(*args)
+  end
+
+  def printf(*args)
+    STDOUT.printf(*args)
+  end
+
+  def gets(*args)
+    STDIN.gets(*args)
+  end
+
+  def getc(*args)
+    STDIN.getc(*args)
+  end
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/mrblib/kernel.rb mruby-1.0.0-seaos/build/mrbgems/mruby-io/mrblib/kernel.rb
--- mruby-1.0.0/build/mrbgems/mruby-io/mrblib/kernel.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/mrblib/kernel.rb	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1,15 @@
+module Kernel
+  def self.`(cmd)
+    IO.popen(cmd) { |io| io.read }
+  end
+
+  def open(file, *rest, &block)
+    raise ArgumentError unless file.is_a?(String)
+
+    if file[0] == "|"
+      IO.popen(file[1..-1], *rest, &block)
+    else
+      File.open(file, *rest, &block)
+    end
+  end
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/run_test.rb mruby-1.0.0-seaos/build/mrbgems/mruby-io/run_test.rb
--- mruby-1.0.0/build/mrbgems/mruby-io/run_test.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/run_test.rb	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1,25 @@
+#!/usr/bin/env ruby
+#
+# mrbgems test runner
+#
+
+if __FILE__ == $0
+  repository, dir = 'https://github.com/mruby/mruby.git', 'tmp/mruby'
+  build_args = ARGV
+
+  Dir.mkdir 'tmp'  unless File.exist?('tmp')
+  unless File.exist?(dir)
+    system "git clone #{repository} #{dir}"
+  end
+
+  exit system(%Q[cd #{dir}; MRUBY_CONFIG=#{File.expand_path __FILE__} ruby minirake #{build_args.join(' ')}])
+end
+
+MRuby::Build.new do |conf|
+  toolchain :gcc
+  conf.gembox 'default'
+
+  conf.gem :git => 'https://github.com/iij/mruby-env.git'
+
+  conf.gem File.expand_path(File.dirname(__FILE__))
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/src/file.c mruby-1.0.0-seaos/build/mrbgems/mruby-io/src/file.c
--- mruby-1.0.0/build/mrbgems/mruby-io/src/file.c	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/src/file.c	2014-06-20 20:39:29.960398613 -0700
@@ -0,0 +1,349 @@
+/*
+** file.c - File class
+*/
+
+#include "mruby.h"
+#include "mruby/class.h"
+#include "mruby/data.h"
+#include "mruby/string.h"
+#include "mruby/ext/io.h"
+
+#if MRUBY_RELEASE_NO < 10000
+#include "error.h"
+#else
+#include "mruby/error.h"
+#endif
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <fcntl.h>
+#include <limits.h>
+#include <unistd.h>
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#if defined(_WIN32) || defined(_WIN64)
+  #define UNLINK _unlink
+  #define GETCWD _getcwd
+  #define CHMOD(a, b) 0
+  #define MAXPATHLEN 1024
+ #if !defined(PATH_MAX)
+  #define PATH_MAX MAX_PATH
+ #endif
+  #define realpath(N,R) _fullpath((R),(N),_MAX_PATH)
+  #include <direct.h>
+#else
+  #define UNLINK unlink
+  #define GETCWD getcwd
+  #define CHMOD(a, b) chmod(a,b)
+  #include <sys/file.h>
+  #include <libgen.h>
+  #include <sys/param.h>
+  #include <pwd.h>
+#endif
+
+#define FILE_SEPARATOR "/"
+
+#ifndef LOCK_SH
+#define LOCK_SH 1
+#endif
+#ifndef LOCK_EX
+#define LOCK_EX 2
+#endif
+#ifndef LOCK_NB
+#define LOCK_NB 4
+#endif
+#ifndef LOCK_UN
+#define LOCK_UN 8
+#endif
+
+#define STAT(p, s)        stat(p, s)
+
+
+mrb_value
+mrb_file_s_umask(mrb_state *mrb, mrb_value klass)
+{
+#if defined(_WIN32) || defined(_WIN64)
+  /* nothing to do on windows */
+  return mrb_fixnum_value(0);
+
+#else
+  mrb_int mask, omask;
+  if (mrb_get_args(mrb, "|i", &mask) == 0) {
+    omask = umask(0);
+    umask(omask);
+  } else {
+    omask = umask(mask);
+  }
+  return mrb_fixnum_value(omask);
+#endif
+}
+
+static mrb_value
+mrb_file_s_unlink(mrb_state *mrb, mrb_value obj)
+{
+  mrb_value *argv;
+  mrb_value pathv;
+  int argc, i;
+  const char *path;
+
+  mrb_get_args(mrb, "*", &argv, &argc);
+  for (i = 0; i < argc; i++) {
+    pathv = mrb_convert_type(mrb, argv[i], MRB_TT_STRING, "String", "to_str");
+    path = mrb_string_value_cstr(mrb, &pathv);;
+    if (UNLINK(path) < 0) {
+      mrb_sys_fail(mrb, path);
+    }
+  }
+  return mrb_fixnum_value(argc);
+}
+
+static mrb_value
+mrb_file_s_rename(mrb_state *mrb, mrb_value obj)
+{
+  mrb_value from, to;
+  const char *src, *dst;
+
+  mrb_get_args(mrb, "SS", &from, &to);
+  src = mrb_string_value_cstr(mrb, &from);
+  dst = mrb_string_value_cstr(mrb, &to);
+  if (rename(src, dst) < 0) {
+    if (CHMOD(dst, 0666) == 0 && UNLINK(dst) == 0 && rename(src, dst) == 0) {
+      return mrb_fixnum_value(0);
+    }
+    mrb_sys_fail(mrb, mrb_str_to_cstr(mrb, mrb_format(mrb, "(%S, %S)", from, to)));
+  }
+  return mrb_fixnum_value(0);
+}
+
+static mrb_value
+mrb_file_dirname(mrb_state *mrb, mrb_value klass)
+{
+  #if defined(_WIN32) || defined(_WIN64)
+  char dname[_MAX_DIR], vname[_MAX_DRIVE];
+  char buffer[_MAX_DRIVE + _MAX_DIR];
+  char *path;
+  mrb_value s;
+  mrb_get_args(mrb, "S", &s);
+  path = mrb_str_to_cstr(mrb, s);
+  _splitpath((const char*)path, vname, dname, NULL, NULL);
+  snprintf(buffer, _MAX_DRIVE + _MAX_DIR, "%s%s", vname, dname);
+  return mrb_str_new_cstr(mrb, buffer);
+  #else
+  char *dname, *path;
+  mrb_value s;
+  mrb_get_args(mrb, "S", &s);
+  path = mrb_str_to_cstr(mrb, s);
+
+  if ((dname = dirname(path)) == NULL) {
+    mrb_sys_fail(mrb, "dirname");
+  }
+  #endif
+  return mrb_str_new_cstr(mrb, dname);
+}
+
+static mrb_value
+mrb_file_basename(mrb_state *mrb, mrb_value klass)
+{
+  #if defined(_WIN32) || defined(_WIN64)
+  char bname[_MAX_DIR];
+  char extname[_MAX_EXT];
+  char *path;
+  char buffer[_MAX_DIR + _MAX_EXT];
+  mrb_value s;
+  mrb_get_args(mrb, "S", &s);
+  path = mrb_str_to_cstr(mrb, s);
+  _splitpath((const char*)path, NULL, NULL, bname, extname);
+  snprintf(buffer, _MAX_DIR + _MAX_EXT, "%s%s", bname, extname);
+  return mrb_str_new_cstr(mrb, buffer);
+  #else
+  char *bname, *path;
+  mrb_value s;
+  mrb_get_args(mrb, "S", &s);
+  path = mrb_str_to_cstr(mrb, s);
+  if ((bname = basename(path)) == NULL) {
+    mrb_sys_fail(mrb, "basename");
+  }
+  return mrb_str_new_cstr(mrb, bname);
+  #endif
+}
+
+static char *arealpath(char *a, char *b)
+{
+  strcpy(b, a);
+  return b;
+}
+
+static mrb_value
+mrb_file_realpath(mrb_state *mrb, mrb_value klass)
+{
+  mrb_value pathname, dir_string, s, result;
+  int argc;
+  char *cpath;
+
+  argc = mrb_get_args(mrb, "S|S", &pathname, &dir_string);
+  if (argc == 2) {
+    s = mrb_str_dup(mrb, dir_string);
+    s = mrb_str_append(mrb, s, mrb_str_new_cstr(mrb, FILE_SEPARATOR));
+    s = mrb_str_append(mrb, s, pathname);
+    pathname = s;
+  }
+  cpath = mrb_str_to_cstr(mrb, pathname);
+  result = mrb_str_buf_new(mrb, PATH_MAX);
+  if (arealpath(cpath, RSTRING_PTR(result)) == NULL)
+    mrb_sys_fail(mrb, cpath);
+  mrb_str_resize(mrb, result, strlen(RSTRING_PTR(result)));
+  return result;
+}
+
+static mrb_value
+mrb_file_size(mrb_state *mrb, mrb_value klass)
+{
+  char *cp;
+  FILE *fp;
+  mrb_int filesize;
+  mrb_value s;
+  int saved_errno;
+
+  mrb_get_args(mrb, "S", &s);
+  cp = mrb_str_to_cstr(mrb, s);
+  fp = fopen(cp, "rb");
+  if (fp == NULL) {
+    mrb_sys_fail(mrb, "fopen");
+    return mrb_nil_value();
+  }
+  if (fseek(fp, 0, SEEK_END) != 0) {
+    saved_errno = errno;
+    fclose(fp);
+    errno = saved_errno;
+    mrb_sys_fail(mrb, "fseek");
+    return mrb_nil_value();
+  }
+  filesize = (mrb_int) ftell(fp);
+  fclose(fp);
+  return mrb_fixnum_value(filesize);
+}
+
+mrb_value
+mrb_file__getwd(mrb_state *mrb, mrb_value klass)
+{
+  mrb_value path;
+
+  path = mrb_str_buf_new(mrb, MAXPATHLEN);
+  if (GETCWD(RSTRING_PTR(path), MAXPATHLEN) == NULL) {
+    mrb_sys_fail(mrb, "getcwd(2)");
+  }
+  mrb_str_resize(mrb, path, strlen(RSTRING_PTR(path)));
+  return path;
+}
+
+static int
+mrb_file_is_absolute_path(const char *path)
+{
+  return (path[0] == '/');
+}
+
+static mrb_value
+mrb_file__gethome(mrb_state *mrb, mrb_value klass)
+{
+#ifndef _WIN32
+  mrb_value username;
+  int argc;
+  char *home;
+
+  argc = mrb_get_args(mrb, "|S", &username);
+  if (argc == 0) {
+    home = getenv("HOME");
+    if (home == NULL) {
+      return mrb_nil_value();
+    }
+    if (!mrb_file_is_absolute_path(home)) {
+      mrb_raise(mrb, E_ARGUMENT_ERROR, "non-absolute home");
+    }
+  } else {
+    const char *cuser = mrb_str_to_cstr(mrb, username);
+    struct passwd *pwd = getpwnam(cuser);
+    if (pwd == NULL) {
+      return mrb_nil_value();
+    }
+    home = pwd->pw_dir;
+    if (!mrb_file_is_absolute_path(home)) {
+      mrb_raisef(mrb, E_ARGUMENT_ERROR, "non-absolute home of ~%S", username);
+    }
+  }
+  return mrb_str_new_cstr(mrb, home);
+#else
+  
+  return mrb_nil_value();
+#endif
+}
+
+#ifndef _WIN32
+mrb_value
+mrb_file_flock(mrb_state *mrb, mrb_value self)
+{
+#if 1
+  mrb_raise(mrb, E_RUNTIME_ERROR, "flock is not supported on Illumos/Solaris");
+#else
+  mrb_int operation;
+  int fd;
+
+  mrb_get_args(mrb, "i", &operation);
+  fd = mrb_fixnum(mrb_io_fileno(mrb, self));
+
+  while (flock(fd, operation) == -1) {
+    switch (errno) {
+      case EINTR:
+        /* retry */
+        break;
+      case EAGAIN:      /* NetBSD */
+#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
+      case EWOULDBLOCK: /* FreeBSD OpenBSD Linux */
+#endif
+        if (operation & LOCK_NB) {
+          return mrb_false_value();
+        }
+        /* FALLTHRU - should not happen */
+      default:
+        mrb_sys_fail(mrb, "flock failed");
+        break;
+    }
+  }
+#endif
+  return mrb_fixnum_value(0);
+}
+#endif
+
+void
+mrb_init_file(mrb_state *mrb)
+{
+  struct RClass *io, *file, *cnst;
+
+  io   = mrb_class_get(mrb, "IO");
+  file = mrb_define_class(mrb, "File", io);
+  MRB_SET_INSTANCE_TT(file, MRB_TT_DATA);
+  mrb_define_class_method(mrb, file, "umask",  mrb_file_s_umask, MRB_ARGS_REQ(1));
+  mrb_define_class_method(mrb, file, "delete", mrb_file_s_unlink, MRB_ARGS_ANY());
+  mrb_define_class_method(mrb, file, "unlink", mrb_file_s_unlink, MRB_ARGS_ANY());
+  mrb_define_class_method(mrb, file, "rename", mrb_file_s_rename, MRB_ARGS_REQ(2));
+
+  mrb_define_class_method(mrb, file, "dirname",   mrb_file_dirname,    MRB_ARGS_REQ(1));
+  mrb_define_class_method(mrb, file, "basename",  mrb_file_basename,   MRB_ARGS_REQ(1));
+  mrb_define_class_method(mrb, file, "realpath",  mrb_file_realpath,   MRB_ARGS_REQ(1)|MRB_ARGS_OPT(1));
+  mrb_define_class_method(mrb, file, "size",      mrb_file_size,       MRB_ARGS_REQ(1));
+  mrb_define_class_method(mrb, file, "_getwd",    mrb_file__getwd,     MRB_ARGS_NONE());
+  mrb_define_class_method(mrb, file, "_gethome",  mrb_file__gethome,   MRB_ARGS_OPT(1));
+
+  #ifndef _WIN32
+  mrb_define_method(mrb, file, "flock", mrb_file_flock, MRB_ARGS_REQ(1));
+  #endif
+  
+  cnst = mrb_define_module_under(mrb, file, "Constants");
+  mrb_define_const(mrb, cnst, "LOCK_SH", mrb_fixnum_value(LOCK_SH));
+  mrb_define_const(mrb, cnst, "LOCK_EX", mrb_fixnum_value(LOCK_EX));
+  mrb_define_const(mrb, cnst, "LOCK_UN", mrb_fixnum_value(LOCK_UN));
+  mrb_define_const(mrb, cnst, "LOCK_NB", mrb_fixnum_value(LOCK_NB));
+  mrb_define_const(mrb, cnst, "SEPARATOR", mrb_str_new_cstr(mrb, FILE_SEPARATOR));
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/src/file_test.c mruby-1.0.0-seaos/build/mrbgems/mruby-io/src/file_test.c
--- mruby-1.0.0/build/mrbgems/mruby-io/src/file_test.c	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/src/file_test.c	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1,342 @@
+/*
+** file.c - File class
+*/
+
+#include "mruby.h"
+#include "mruby/class.h"
+#include "mruby/data.h"
+#include "mruby/string.h"
+#include "mruby/ext/io.h"
+
+#if MRUBY_RELEASE_NO < 10000
+#include "error.h"
+#else
+#include "mruby/error.h"
+#endif
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#if defined(_WIN32) || defined(_WIN64)
+  #define LSTAT stat
+  #include <winsock.h>
+#else
+  #define LSTAT lstat
+  #include <sys/file.h>
+  #include <sys/param.h>
+  #include <sys/wait.h>
+  #include <libgen.h>
+  #include <pwd.h>
+  #include <unistd.h>
+#endif
+
+#include <fcntl.h>
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+extern struct mrb_data_type mrb_io_type;
+
+static int
+mrb_stat0(mrb_state *mrb, mrb_value obj, struct stat *st, int do_lstat)
+{
+  mrb_value tmp;
+  mrb_value io_klass, str_klass;
+
+  io_klass  = mrb_obj_value(mrb_class_get(mrb, "IO"));
+  str_klass = mrb_obj_value(mrb_class_get(mrb, "String"));
+
+  tmp = mrb_funcall(mrb, obj, "is_a?", 1, io_klass);
+  if (mrb_test(tmp)) {
+    struct mrb_io *fptr;
+    fptr = (struct mrb_io *)mrb_get_datatype(mrb, obj, &mrb_io_type);
+
+    if (fptr && fptr->fd >= 0) {
+      return fstat(fptr->fd, st);
+    }
+
+    mrb_raise(mrb, E_IO_ERROR, "closed stream");
+    return -1;
+  }
+
+  tmp = mrb_funcall(mrb, obj, "is_a?", 1, str_klass);
+  if (mrb_test(tmp)) {
+    if (do_lstat) {
+      return LSTAT(mrb_str_to_cstr(mrb, obj), st);
+    } else {
+      return stat(mrb_str_to_cstr(mrb, obj), st);
+    }
+  }
+
+  return -1;
+}
+
+static int
+mrb_stat(mrb_state *mrb, mrb_value obj, struct stat *st)
+{
+  return mrb_stat0(mrb, obj, st, 0);
+}
+
+static int
+mrb_lstat(mrb_state *mrb, mrb_value obj, struct stat *st)
+{
+  return mrb_stat0(mrb, obj, st, 1);
+}
+
+/*
+ * Document-method: directory?
+ *
+ * call-seq:
+ *   File.directory?(file_name)   ->  true or false
+ *
+ * Returns <code>true</code> if the named file is a directory,
+ * or a symlink that points at a directory, and <code>false</code>
+ * otherwise.
+ *
+ *    File.directory?(".")
+ */
+
+mrb_value
+mrb_filetest_s_directory_p(mrb_state *mrb, mrb_value klass)
+{
+#ifndef S_ISDIR
+#   define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+#endif
+
+  struct stat st;
+  mrb_value obj;
+
+  mrb_get_args(mrb, "o", &obj);
+
+  if (mrb_stat(mrb, obj, &st) < 0)
+    return mrb_false_value();
+  if (S_ISDIR(st.st_mode))
+    return mrb_true_value();
+
+  return mrb_false_value();
+}
+
+/*
+ * call-seq:
+ *   File.pipe?(file_name)   ->  true or false
+ *
+ * Returns <code>true</code> if the named file is a pipe.
+ */
+
+mrb_value
+mrb_filetest_s_pipe_p(mrb_state *mrb, mrb_value klass)
+{
+#ifdef S_IFIFO
+#  ifndef S_ISFIFO
+#    define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
+#  endif
+
+  struct stat st;
+  mrb_value obj;
+
+  mrb_get_args(mrb, "o", &obj);
+
+  if (mrb_stat(mrb, obj, &st) < 0)
+    return mrb_false_value();
+  if (S_ISFIFO(st.st_mode))
+    return mrb_true_value();
+
+#endif
+  return mrb_false_value();
+}
+
+/*
+ * call-seq:
+ *   File.symlink?(file_name)   ->  true or false
+ *
+ * Returns <code>true</code> if the named file is a symbolic link.
+ */
+
+mrb_value
+mrb_filetest_s_symlink_p(mrb_state *mrb, mrb_value klass)
+{
+#ifndef S_ISLNK
+#  ifdef _S_ISLNK
+#    define S_ISLNK(m) _S_ISLNK(m)
+#  else
+#    ifdef _S_IFLNK
+#      define S_ISLNK(m) (((m) & S_IFMT) == _S_IFLNK)
+#    else
+#      ifdef S_IFLNK
+#        define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
+#      endif
+#    endif
+#  endif
+#endif
+
+#ifdef S_ISLNK
+  struct stat st;
+  mrb_value obj;
+
+  mrb_get_args(mrb, "o", &obj);
+
+  if (mrb_lstat(mrb, obj, &st) == -1)
+    return mrb_false_value();
+  if (S_ISLNK(st.st_mode))
+    return mrb_true_value();
+#endif
+
+  return mrb_false_value();
+}
+
+/*
+ * call-seq:
+ *   File.socket?(file_name)   ->  true or false
+ *
+ * Returns <code>true</code> if the named file is a socket.
+ */
+
+mrb_value
+mrb_filetest_s_socket_p(mrb_state *mrb, mrb_value klass)
+{
+#ifndef S_ISSOCK
+#  ifdef _S_ISSOCK
+#    define S_ISSOCK(m) _S_ISSOCK(m)
+#  else
+#    ifdef _S_IFSOCK
+#      define S_ISSOCK(m) (((m) & S_IFMT) == _S_IFSOCK)
+#    else
+#      ifdef S_IFSOCK
+#        define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
+#      endif
+#    endif
+#  endif
+#endif
+
+#ifdef S_ISSOCK
+  struct stat st;
+  mrb_value obj;
+
+  mrb_get_args(mrb, "o", &obj);
+
+  if (mrb_stat(mrb, obj, &st) < 0)
+    return mrb_false_value();
+  if (S_ISSOCK(st.st_mode))
+    return mrb_true_value();
+#endif
+
+  return mrb_false_value();
+}
+
+/*
+ * call-seq:
+ *    File.exist?(file_name)    ->  true or false
+ *    File.exists?(file_name)   ->  true or false
+ *
+ * Return <code>true</code> if the named file exists.
+ */
+
+mrb_value
+mrb_filetest_s_exist_p(mrb_state *mrb, mrb_value klass)
+{
+  struct stat st;
+  mrb_value obj;
+
+  mrb_get_args(mrb, "o", &obj);
+  if (mrb_stat(mrb, obj, &st) < 0)
+    return mrb_false_value();
+
+  return mrb_true_value();
+}
+
+/*
+ * call-seq:
+ *    File.file?(file_name)   -> true or false
+ *
+ * Returns <code>true</code> if the named file exists and is a
+ * regular file.
+ */
+
+mrb_value
+mrb_filetest_s_file_p(mrb_state *mrb, mrb_value klass)
+{
+#ifndef S_ISREG
+#   define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
+#endif
+
+  struct stat st;
+  mrb_value obj;
+
+  mrb_get_args(mrb, "o", &obj);
+
+  if (mrb_stat(mrb, obj, &st) < 0)
+    return mrb_false_value();
+  if (S_ISREG(st.st_mode))
+    return mrb_true_value();
+
+  return mrb_false_value();
+}
+
+/*
+ * call-seq:
+ *    File.zero?(file_name)   -> true or false
+ *
+ * Returns <code>true</code> if the named file exists and has
+ * a zero size.
+ */
+
+mrb_value
+mrb_filetest_s_zero_p(mrb_state *mrb, mrb_value klass)
+{
+  struct stat st;
+  mrb_value obj;
+
+  mrb_get_args(mrb, "o", &obj);
+
+  if (mrb_stat(mrb, obj, &st) < 0)
+    return mrb_false_value();
+  if (st.st_size == 0)
+    return mrb_true_value();
+
+  return mrb_false_value();
+}
+
+/*
+ * call-seq:
+ *    File.size?(file_name)   -> Integer or nil
+ *
+ * Returns +nil+ if +file_name+ doesn't exist or has zero size, the size of the
+ * file otherwise.
+ */
+
+mrb_value
+mrb_filetest_s_size_p(mrb_state *mrb, mrb_value klass)
+{
+  struct stat st;
+  mrb_value obj;
+
+  mrb_get_args(mrb, "o", &obj);
+
+  if (mrb_stat(mrb, obj, &st) < 0)
+    return mrb_nil_value();
+  if (st.st_size == 0)
+    return mrb_nil_value();
+
+  return mrb_fixnum_value(st.st_size);
+}
+
+
+void
+mrb_init_file_test(mrb_state *mrb)
+{
+  struct RClass *f;
+
+  f = mrb_define_class(mrb, "FileTest", mrb->object_class);
+
+  mrb_define_class_method(mrb, f, "directory?", mrb_filetest_s_directory_p, MRB_ARGS_REQ(1));
+  mrb_define_class_method(mrb, f, "exist?",     mrb_filetest_s_exist_p,     MRB_ARGS_REQ(1));
+  mrb_define_class_method(mrb, f, "exists?",    mrb_filetest_s_exist_p,     MRB_ARGS_REQ(1));
+  mrb_define_class_method(mrb, f, "file?",      mrb_filetest_s_file_p,      MRB_ARGS_REQ(1));
+  mrb_define_class_method(mrb, f, "pipe?",      mrb_filetest_s_pipe_p,      MRB_ARGS_REQ(1));
+  mrb_define_class_method(mrb, f, "size?",      mrb_filetest_s_size_p,      MRB_ARGS_REQ(1));
+  mrb_define_class_method(mrb, f, "socket?",    mrb_filetest_s_socket_p,    MRB_ARGS_REQ(1));
+  mrb_define_class_method(mrb, f, "symlink?",   mrb_filetest_s_symlink_p,   MRB_ARGS_REQ(1));
+  mrb_define_class_method(mrb, f, "zero?",      mrb_filetest_s_zero_p,      MRB_ARGS_REQ(1));
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/src/io.c mruby-1.0.0-seaos/build/mrbgems/mruby-io/src/io.c
--- mruby-1.0.0/build/mrbgems/mruby-io/src/io.c	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/src/io.c	2014-06-20 19:08:15.675481563 -0700
@@ -0,0 +1,754 @@
+/*
+** io.c - IO class
+*/
+
+#include "mruby.h"
+#include "mruby/array.h"
+#include "mruby/class.h"
+#include "mruby/data.h"
+#include "mruby/hash.h"
+#include "mruby/string.h"
+#include "mruby/variable.h"
+#include "mruby/ext/io.h"
+
+#if MRUBY_RELEASE_NO < 10000
+#include "error.h"
+#else
+#include "mruby/error.h"
+#endif
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#if defined(_WIN32) || defined(_WIN64)
+  #include <winsock.h>
+  #include <io.h>
+  #define open  _open
+  #define close _close
+  #define read  _read
+  #define write _write
+  #define lseek _lseek
+#else
+  #include <sys/wait.h>
+  #include <unistd.h>
+#endif
+
+#include <fcntl.h>
+
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/time.h>
+#include <sys/select.h>
+
+static int mrb_io_modestr_to_flags(mrb_state *mrb, const char *modestr);
+static int mrb_io_flags_to_modenum(mrb_state *mrb, int flags);
+static void fptr_finalize(mrb_state *mrb, struct mrb_io *fptr, int noraise);
+
+#if MRUBY_RELEASE_NO < 10000
+static struct RClass *
+mrb_module_get(mrb_state *mrb, const char *name)
+{
+  return mrb_class_get(mrb, name);
+}
+#endif
+
+static int
+mrb_io_modestr_to_flags(mrb_state *mrb, const char *mode)
+{
+  int flags = 0;
+  const char *m = mode;
+
+  switch (*m++) {
+    case 'r':
+      flags |= FMODE_READABLE;
+      break;
+    case 'w':
+      flags |= FMODE_WRITABLE | FMODE_CREATE | FMODE_TRUNC;
+      break;
+    case 'a':
+      flags |= FMODE_WRITABLE | FMODE_APPEND | FMODE_CREATE;
+      break;
+    default:
+      mrb_raisef(mrb, E_ARGUMENT_ERROR, "illegal access mode %S", mrb_str_new_cstr(mrb, mode));
+  }
+
+  while (*m) {
+    switch (*m++) {
+      case 'b':
+        flags |= FMODE_BINMODE;
+        break;
+      case '+':
+        flags |= FMODE_READWRITE;
+        break;
+      case ':':
+        /* XXX: PASSTHROUGH*/
+      default:
+        mrb_raisef(mrb, E_ARGUMENT_ERROR, "illegal access mode %S", mrb_str_new_cstr(mrb, mode));
+    }
+  }
+
+  return flags;
+}
+
+static int
+mrb_io_flags_to_modenum(mrb_state *mrb, int flags)
+{
+  int modenum = 0;
+
+  switch(flags & (FMODE_READABLE|FMODE_WRITABLE|FMODE_READWRITE)) {
+    case FMODE_READABLE:
+      modenum = O_RDONLY;
+      break;
+    case FMODE_WRITABLE:
+      modenum = O_WRONLY;
+      break;
+    case FMODE_READWRITE:
+      modenum = O_RDWR;
+      break;
+  }
+
+  if (flags & FMODE_APPEND) {
+    modenum |= O_APPEND;
+  }
+  if (flags & FMODE_TRUNC) {
+    modenum |= O_TRUNC;
+  }
+  if (flags & FMODE_CREATE) {
+    modenum |= O_CREAT;
+  }
+#ifdef O_BINARY
+  if (flags & FMODE_BINMODE) {
+    modenum |= O_BINARY;
+  }
+#endif
+
+  return modenum;
+}
+
+#ifndef _WIN32
+static int
+mrb_proc_exec(const char *pname)
+{
+  const char *s;
+  s = pname;
+
+  while (*s == ' ' || *s == '\t' || *s == '\n')
+    s++;
+
+  if (!*s) {
+    errno = ENOENT;
+    return -1;
+  }
+
+  execl("/bin/sh", "sh", "-c", pname, (char *)NULL);
+  return -1;
+}
+#endif
+
+static void
+mrb_io_free(mrb_state *mrb, void *ptr)
+{
+  struct mrb_io *io = (struct mrb_io *)ptr;
+  if (io != NULL) {
+    fptr_finalize(mrb, io, TRUE);
+    mrb_free(mrb, io);
+  }
+}
+
+struct mrb_data_type mrb_io_type = { "IO", mrb_io_free };
+
+static struct mrb_io *
+mrb_io_alloc(mrb_state *mrb)
+{
+  struct mrb_io *fptr;
+
+  fptr = (struct mrb_io *)mrb_malloc(mrb, sizeof(struct mrb_io));
+  fptr->fd = -1;
+  fptr->fd2 = -1;
+  fptr->pid = 0;
+  fptr->writable = 0;
+  return fptr;
+}
+
+#ifndef NOFILE
+#define NOFILE 64
+#endif
+
+#ifndef _WIN32
+mrb_value
+mrb_io_s_popen(mrb_state *mrb, mrb_value klass)
+{
+  mrb_value cmd, io, result;
+  mrb_value mode = mrb_str_new_cstr(mrb, "r");
+  mrb_value opt  = mrb_hash_new(mrb);
+
+  struct mrb_io *fptr;
+  const char *pname;
+  int pid, flags, fd, write_fd = -1;
+  int pr[2] = { -1, -1 };
+  int pw[2] = { -1, -1 };
+  int doexec;
+  int saved_errno;
+
+  mrb_get_args(mrb, "S|SH", &cmd, &mode, &opt);
+  io = mrb_obj_value(mrb_data_object_alloc(mrb, mrb_class_ptr(klass), NULL, &mrb_io_type));
+
+  pname = mrb_string_value_cstr(mrb, &cmd);
+  flags = mrb_io_modestr_to_flags(mrb, mrb_string_value_cstr(mrb, &mode));
+
+  doexec = (strcmp("-", pname) != 0);
+
+  if ((flags & FMODE_READABLE) && pipe(pr) == -1) {
+    mrb_sys_fail(mrb, "pipe");
+  }
+  if ((flags & FMODE_WRITABLE) && pipe(pw) == -1) {
+    if (pr[0] != -1) close(pr[0]);
+    if (pr[1] != -1) close(pr[1]);
+    mrb_sys_fail(mrb, "pipe");
+  }
+
+  if (!doexec) {
+    // XXX
+    fflush(stdin);
+    fflush(stdout);
+    fflush(stderr);
+  }
+
+  result = mrb_nil_value();
+  switch (pid = fork()) {
+    case 0: /* child */
+      if (flags & FMODE_READABLE) {
+        close(pr[0]);
+        if (pr[1] != 1) {
+          dup2(pr[1], 1);
+          close(pr[1]);
+        }
+      }
+      if (flags & FMODE_WRITABLE) {
+        close(pw[1]);
+        if (pw[0] != 0) {
+          dup2(pw[0], 0);
+          close(pw[0]);
+        }
+      }
+      if (doexec) {
+        for (fd = 3; fd < NOFILE; fd++) {
+          close(fd);
+        }
+        mrb_proc_exec(pname);
+        mrb_raisef(mrb, E_IO_ERROR, "command not found: %S", cmd);
+        _exit(127);
+      }
+      result = mrb_nil_value();
+      break;
+
+    default: /* parent */
+      if ((flags & FMODE_READABLE) && (flags & FMODE_WRITABLE)) {
+        close(pr[1]);
+        fd = pr[0];
+        close(pw[0]);
+        write_fd = pw[1];
+      } else if (flags & FMODE_READABLE) {
+        close(pr[1]);
+        fd = pr[0];
+      } else {
+        close(pw[0]);
+        fd = pw[1];
+      }
+
+      mrb_iv_set(mrb, io, mrb_intern_cstr(mrb, "@buf"), mrb_str_new_cstr(mrb, ""));
+      mrb_iv_set(mrb, io, mrb_intern_cstr(mrb, "@pos"), mrb_fixnum_value(0));
+
+      fptr = mrb_io_alloc(mrb);
+      fptr->fd = fd;
+      fptr->fd2 = write_fd;
+      fptr->pid = pid;
+      fptr->writable = ((flags & FMODE_WRITABLE) != 0);
+
+      DATA_TYPE(io) = &mrb_io_type;
+      DATA_PTR(io)  = fptr;
+      result = io;
+      break;
+
+    case -1: /* error */
+      saved_errno = errno;
+      if (flags & FMODE_READABLE) {
+        close(pr[0]);
+        close(pr[1]);
+      }
+      if (flags & FMODE_WRITABLE) {
+        close(pw[0]);
+        close(pw[1]);
+      }
+      errno = saved_errno;
+      mrb_sys_fail(mrb, "pipe_open failed.");
+      break;
+  }
+  return result;
+}
+#endif
+
+mrb_value
+mrb_io_initialize(mrb_state *mrb, mrb_value io)
+{
+  struct mrb_io *fptr;
+  mrb_int fd;
+  mrb_value mode, opt;
+  int flags;
+
+  mode = opt = mrb_nil_value();
+
+  mrb_get_args(mrb, "i|So", &fd, &mode, &opt);
+  if (mrb_nil_p(mode)) {
+    mode = mrb_str_new_cstr(mrb, "r");
+  }
+  if (mrb_nil_p(opt)) {
+    opt = mrb_hash_new(mrb);
+  }
+
+  flags = mrb_io_modestr_to_flags(mrb, mrb_string_value_cstr(mrb, &mode));
+
+  mrb_iv_set(mrb, io, mrb_intern_cstr(mrb, "@buf"), mrb_str_new_cstr(mrb, ""));
+  mrb_iv_set(mrb, io, mrb_intern_cstr(mrb, "@pos"), mrb_fixnum_value(0));
+
+  fptr = DATA_PTR(io);
+  if (fptr != NULL) {
+    fptr_finalize(mrb, fptr, 0);
+    mrb_free(mrb, fptr);
+  }
+  fptr = mrb_io_alloc(mrb);
+
+  DATA_TYPE(io) = &mrb_io_type;
+  DATA_PTR(io) = fptr;
+
+  fptr->fd = fd;
+  fptr->writable = ((flags & FMODE_WRITABLE) != 0);
+  return io;
+}
+
+static void
+fptr_finalize(mrb_state *mrb, struct mrb_io *fptr, int noraise)
+{
+  int n = 0;
+
+  if (fptr == NULL) {
+    return;
+  }
+
+  if (fptr->fd > 2) {
+    n = close(fptr->fd);
+    if (n == 0) {
+      fptr->fd = -1;
+    }
+  }
+  if (fptr->fd2 > 2) {
+    n = close(fptr->fd2);
+    if (n == 0) {
+      fptr->fd2 = -1;
+    }
+  }
+
+  if (!noraise && n != 0) {
+    mrb_sys_fail(mrb, "fptr_finalize failed.");
+  }
+}
+
+mrb_value
+mrb_io_s_sysclose(mrb_state *mrb, mrb_value klass)
+{
+  mrb_int fd;
+  mrb_get_args(mrb, "i", &fd);
+  if (close(fd) == -1) {
+    mrb_sys_fail(mrb, "close");
+  }
+  return mrb_fixnum_value(0);
+}
+
+mrb_value
+mrb_io_s_sysopen(mrb_state *mrb, mrb_value klass)
+{
+  mrb_value path = mrb_nil_value();
+  mrb_value mode = mrb_nil_value();
+  mrb_int fd, flags, perm = -1;
+  const char *pat;
+  int modenum;
+
+  mrb_get_args(mrb, "S|Si", &path, &mode, &perm);
+  if (mrb_nil_p(mode)) {
+    mode = mrb_str_new_cstr(mrb, "r");
+  }
+  if (perm < 0) {
+    perm = 0666;
+  }
+
+  pat = mrb_string_value_cstr(mrb, &path);
+  flags = mrb_io_modestr_to_flags(mrb, mrb_string_value_cstr(mrb, &mode));
+  modenum = mrb_io_flags_to_modenum(mrb, flags);
+
+  fd = open(pat, modenum, perm);
+  if (fd == -1) {
+    mrb_sys_fail(mrb, pat);
+  }
+
+  return mrb_fixnum_value(fd);
+}
+
+mrb_value
+mrb_io_sysread(mrb_state *mrb, mrb_value io)
+{
+  struct mrb_io *fptr;
+  mrb_value buf = mrb_nil_value();
+  int maxlen, ret;
+
+  mrb_get_args(mrb, "i|S", &maxlen, &buf);
+  if (maxlen < 0) {
+    return mrb_nil_value();
+  }
+
+  if (mrb_nil_p(buf)) {
+    buf = mrb_str_new(mrb, "", maxlen);
+  }
+  if (RSTRING_LEN(buf) != maxlen) {
+    buf = mrb_str_resize(mrb, buf, maxlen);
+  }
+
+  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);
+  ret = read(fptr->fd, RSTRING_PTR(buf), maxlen);
+  switch (ret) {
+    case 0: /* EOF */
+      if (maxlen == 0) {
+        buf = mrb_str_new_cstr(mrb, "");
+      } else {
+        mrb_raise(mrb, E_EOF_ERROR, "sysread failed: End of File");
+      }
+      break;
+    case -1: /* Error */
+      mrb_raise(mrb, E_IO_ERROR, "sysread failed");
+      break;
+    default:
+      if (RSTRING_LEN(buf) != ret) {
+        buf = mrb_str_resize(mrb, buf, ret);
+      }
+      break;
+  }
+
+  return buf;
+}
+
+mrb_value
+mrb_io_sysseek(mrb_state *mrb, mrb_value io)
+{
+  struct mrb_io *fptr;
+  int pos, offset, whence = -1;
+
+  mrb_get_args(mrb, "i|i", &offset, &whence);
+  if (whence < 0) {
+    whence = 0;
+  }
+
+  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);
+  pos = lseek(fptr->fd, offset, whence);
+  if (pos < 0) {
+    mrb_raise(mrb, E_IO_ERROR, "sysseek faield");
+  }
+
+  return mrb_fixnum_value(pos);
+}
+
+mrb_value
+mrb_io_syswrite(mrb_state *mrb, mrb_value io)
+{
+  struct mrb_io *fptr;
+  mrb_value str, buf;
+  int fd, length;
+
+  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);
+  if (! fptr->writable) {
+    mrb_raise(mrb, E_IO_ERROR, "not opened for writing");
+  }
+
+  mrb_get_args(mrb, "S", &str);
+  if (mrb_type(str) != MRB_TT_STRING) {
+    buf = mrb_funcall(mrb, str, "to_s", 0);
+  } else {
+    buf = str;
+  }
+
+  if (fptr->fd2 == -1) {
+    fd = fptr->fd;
+  } else {
+    fd = fptr->fd2;
+  }
+  length = write(fd, RSTRING_PTR(buf), RSTRING_LEN(buf));
+
+  return mrb_fixnum_value(length);
+}
+
+mrb_value
+mrb_io_close(mrb_state *mrb, mrb_value io)
+{
+  struct mrb_io *fptr;
+  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);
+  if (fptr && fptr->fd < 0) {
+    mrb_raise(mrb, E_IO_ERROR, "closed stream.");
+  }
+  fptr_finalize(mrb, fptr, FALSE);
+  return mrb_nil_value();
+}
+
+mrb_value
+mrb_io_closed(mrb_state *mrb, mrb_value io)
+{
+  struct mrb_io *fptr;
+  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);
+  if (fptr->fd >= 0) {
+    return mrb_false_value();
+  }
+
+  return mrb_true_value();
+}
+
+mrb_value
+mrb_io_pid(mrb_state *mrb, mrb_value io)
+{
+  struct mrb_io *fptr;
+  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);
+
+  if (fptr->pid > 0) {
+    return mrb_fixnum_value(fptr->pid);
+  }
+
+  return mrb_nil_value();
+}
+
+static struct timeval
+time2timeval(mrb_state *mrb, mrb_value time)
+{
+  struct timeval t = { 0, 0 };
+
+  switch (mrb_type(time)) {
+    case MRB_TT_FIXNUM:
+      t.tv_sec = mrb_fixnum(time);
+      t.tv_usec = 0;
+      break;
+
+    case MRB_TT_FLOAT:
+      t.tv_sec = mrb_float(time);
+      t.tv_usec = (mrb_float(time) - t.tv_sec) * 1000000.0;
+      break;
+
+    default:
+      mrb_raise(mrb, E_TYPE_ERROR, "wrong argument class");
+  }
+
+  return t;
+}
+
+static int
+mrb_io_read_data_pending(mrb_state *mrb, mrb_value io)
+{
+  mrb_value buf = mrb_iv_get(mrb, io, mrb_intern_cstr(mrb, "@buf"));
+  if (mrb_type(buf) == MRB_TT_STRING && RSTRING_LEN(buf) > 0) {
+    return 1;
+  }
+  return 0;
+}
+
+static mrb_value
+mrb_io_s_select(mrb_state *mrb, mrb_value klass)
+{
+  mrb_value *argv;
+  int argc;
+  mrb_value read, read_io, write, except, timeout, list;
+  struct timeval *tp, timerec;
+  fd_set pset, rset, wset, eset;
+  fd_set *rp, *wp, *ep;
+  struct mrb_io *fptr;
+  int pending = 0;
+  mrb_value result;
+  int max = 0;
+  int interrupt_flag = 0;
+  int i, n;
+
+  mrb_get_args(mrb, "*", &argv, &argc);
+
+  if (argc < 1 || argc > 4) {
+    mrb_raisef(mrb, E_ARGUMENT_ERROR, "wrong number of arguments (%S for 1..4)", mrb_fixnum_value(argc));
+  }
+
+  timeout = mrb_nil_value();
+  except = mrb_nil_value();
+  write = mrb_nil_value();
+  if (argc > 3)
+    timeout = argv[3];
+  if (argc > 2)
+    except = argv[2];
+  if (argc > 1)
+    write = argv[1];
+  read = argv[0];
+
+  if (mrb_nil_p(timeout)) {
+    tp = NULL;
+  } else {
+    timerec = time2timeval(mrb, timeout);
+    tp = &timerec;
+  }
+
+  FD_ZERO(&pset);
+  if (!mrb_nil_p(read)) {
+    mrb_check_type(mrb, read, MRB_TT_ARRAY);
+    rp = &rset;
+    FD_ZERO(rp);
+    for (i = 0; i < RARRAY_LEN(read); i++) {
+      read_io = RARRAY_PTR(read)[i];
+      fptr = (struct mrb_io *)mrb_get_datatype(mrb, read_io, &mrb_io_type);
+      FD_SET(fptr->fd, rp);
+      if (mrb_io_read_data_pending(mrb, read_io)) {
+        pending++;
+        FD_SET(fptr->fd, &pset);
+      }
+      if (max < fptr->fd)
+        max = fptr->fd;
+    }
+    if (pending) {
+      timerec.tv_sec = timerec.tv_usec = 0;
+      tp = &timerec;
+    }
+  } else {
+    rp = NULL;
+  }
+
+  if (!mrb_nil_p(write)) {
+    mrb_check_type(mrb, write, MRB_TT_ARRAY);
+    wp = &wset;
+    FD_ZERO(wp);
+    for (i = 0; i < RARRAY_LEN(write); i++) {
+      fptr = (struct mrb_io *)mrb_get_datatype(mrb, RARRAY_PTR(write)[i], &mrb_io_type);
+      FD_SET(fptr->fd, wp);
+      if (max < fptr->fd)
+        max = fptr->fd;
+      if (fptr->fd2 >= 0) {
+        FD_SET(fptr->fd2, wp);
+        if (max < fptr->fd2)
+          max = fptr->fd2;
+      }
+    }
+  } else {
+    wp = NULL;
+  }
+
+  if (!mrb_nil_p(except)) {
+    mrb_check_type(mrb, except, MRB_TT_ARRAY);
+    ep = &eset;
+    FD_ZERO(ep);
+    for (i = 0; i < RARRAY_LEN(except); i++) {
+      fptr = (struct mrb_io *)mrb_get_datatype(mrb, RARRAY_PTR(except)[i], &mrb_io_type);
+      FD_SET(fptr->fd, ep);
+      if (max < fptr->fd)
+        max = fptr->fd;
+      if (fptr->fd2 >= 0) {
+        FD_SET(fptr->fd2, ep);
+        if (max < fptr->fd2)
+          max = fptr->fd2;
+      }
+    }
+  } else {
+    ep = NULL;
+  }
+
+  max++;
+
+retry:
+  n = select(max, rp, wp, ep, tp);
+  if (n < 0) {
+    if (errno != EINTR)
+      mrb_sys_fail(mrb, "select failed");
+    if (tp == NULL)
+      goto retry;
+    interrupt_flag = 1;
+  }
+
+  if (!pending && n == 0)
+    return mrb_nil_value();
+
+  result = mrb_ary_new_capa(mrb, 3);
+  mrb_ary_push(mrb, result, rp? mrb_ary_new(mrb) : mrb_ary_new_capa(mrb, 0));
+  mrb_ary_push(mrb, result, wp? mrb_ary_new(mrb) : mrb_ary_new_capa(mrb, 0));
+  mrb_ary_push(mrb, result, ep? mrb_ary_new(mrb) : mrb_ary_new_capa(mrb, 0));
+
+  if (interrupt_flag == 0) {
+    if (rp) {
+      list = RARRAY_PTR(result)[0];
+      for (i = 0; i < RARRAY_LEN(read); i++) {
+        fptr = (struct mrb_io *)mrb_get_datatype(mrb, RARRAY_PTR(read)[i], &mrb_io_type);
+        if (FD_ISSET(fptr->fd, rp) ||
+            FD_ISSET(fptr->fd, &pset)) {
+          mrb_ary_push(mrb, list, RARRAY_PTR(read)[i]);
+        }
+      }
+    }
+
+    if (wp) {
+      list = RARRAY_PTR(result)[1];
+      for (i = 0; i < RARRAY_LEN(write); i++) {
+        fptr = (struct mrb_io *)mrb_get_datatype(mrb, RARRAY_PTR(write)[i], &mrb_io_type);
+        if (FD_ISSET(fptr->fd, wp)) {
+          mrb_ary_push(mrb, list, RARRAY_PTR(write)[i]);
+        } else if (fptr->fd2 >= 0 && FD_ISSET(fptr->fd2, wp)) {
+          mrb_ary_push(mrb, list, RARRAY_PTR(write)[i]);
+        }
+      }
+    }
+
+    if (ep) {
+      list = RARRAY_PTR(result)[2];
+      for (i = 0; i < RARRAY_LEN(except); i++) {
+        fptr = (struct mrb_io *)mrb_get_datatype(mrb, RARRAY_PTR(except)[i], &mrb_io_type);
+        if (FD_ISSET(fptr->fd, ep)) {
+          mrb_ary_push(mrb, list, RARRAY_PTR(except)[i]);
+        } else if (fptr->fd2 >= 0 && FD_ISSET(fptr->fd2, wp)) {
+          mrb_ary_push(mrb, list, RARRAY_PTR(except)[i]);
+        }
+      }
+    }
+  }
+
+  return result;
+}
+
+mrb_value
+mrb_io_fileno(mrb_state *mrb, mrb_value io)
+{
+  struct mrb_io *fptr;
+  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);
+  return mrb_fixnum_value(fptr->fd);
+}
+
+void
+mrb_init_io(mrb_state *mrb)
+{
+  struct RClass *io;
+
+  io      = mrb_define_class(mrb, "IO", mrb->object_class);
+  MRB_SET_INSTANCE_TT(io, MRB_TT_DATA);
+
+  mrb_include_module(mrb, io, mrb_module_get(mrb, "Enumerable")); /* 15.2.20.3 */
+#ifndef _WIN32
+  mrb_define_class_method(mrb, io, "_popen",  mrb_io_s_popen,   MRB_ARGS_ANY());
+  mrb_define_class_method(mrb, io, "_sysclose",  mrb_io_s_sysclose, MRB_ARGS_REQ(1));
+#endif
+  mrb_define_class_method(mrb, io, "select",  mrb_io_s_select,  MRB_ARGS_ANY());
+  mrb_define_class_method(mrb, io, "sysopen", mrb_io_s_sysopen, MRB_ARGS_ANY());
+
+  mrb_define_method(mrb, io, "initialize", mrb_io_initialize, MRB_ARGS_ANY());    /* 15.2.20.5.21 (x)*/
+  mrb_define_method(mrb, io, "sysread",    mrb_io_sysread,    MRB_ARGS_ANY());
+  mrb_define_method(mrb, io, "sysseek",    mrb_io_sysseek,    MRB_ARGS_REQ(1));
+  mrb_define_method(mrb, io, "syswrite",   mrb_io_syswrite,   MRB_ARGS_REQ(1));
+  mrb_define_method(mrb, io, "close",      mrb_io_close,      MRB_ARGS_NONE());   /* 15.2.20.5.1 */
+  mrb_define_method(mrb, io, "closed?",    mrb_io_closed,     MRB_ARGS_NONE());   /* 15.2.20.5.2 */
+  mrb_define_method(mrb, io, "pid",        mrb_io_pid,        MRB_ARGS_NONE());   /* 15.2.20.5.2 */
+  mrb_define_method(mrb, io, "fileno",     mrb_io_fileno,     MRB_ARGS_NONE());
+
+  mrb_gv_set(mrb, mrb_intern_cstr(mrb, "$/"), mrb_str_new_cstr(mrb, "\n"));
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/src/mruby_io_gem.c mruby-1.0.0-seaos/build/mrbgems/mruby-io/src/mruby_io_gem.c
--- mruby-1.0.0/build/mrbgems/mruby-io/src/mruby_io_gem.c	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/src/mruby_io_gem.c	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1,20 @@
+#include "mruby.h"
+
+void mrb_init_io(mrb_state *mrb);
+void mrb_init_file(mrb_state *mrb);
+void mrb_init_file_test(mrb_state *mrb);
+
+#define DONE mrb_gc_arena_restore(mrb, 0)
+
+void
+mrb_mruby_io_gem_init(mrb_state* mrb)
+{
+  mrb_init_io(mrb); DONE;
+  mrb_init_file(mrb); DONE;
+  mrb_init_file_test(mrb); DONE;
+}
+
+void
+mrb_mruby_io_gem_final(mrb_state* mrb)
+{
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/test/file.rb mruby-1.0.0-seaos/build/mrbgems/mruby-io/test/file.rb
--- mruby-1.0.0/build/mrbgems/mruby-io/test/file.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/test/file.rb	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1,114 @@
+##
+# IO Test
+
+assert('File', '15.2.21') do
+  File.class == Class
+end
+
+assert('File', '15.2.21.2') do
+  File.superclass == IO
+end
+
+assert('File TEST SETUP') do
+  MRubyIOTestUtil.io_test_setup
+end
+
+assert('File#initialize', '15.2.21.4.1') do
+  io = File.open($mrbtest_io_rfname, "r")
+  assert_nil io.close
+  assert_raise IOError do
+    io.close
+  end
+end
+
+assert('File#path', '15.2.21.4.2') do
+  io = File.open($mrbtest_io_rfname, "r")
+  assert_equal $mrbtest_io_msg, io.read
+  assert_equal $mrbtest_io_rfname, io.path
+  io.close
+  assert_equal $mrbtest_io_rfname, io.path
+  io.closed?
+end
+
+assert('File.basename') do
+  assert_equal '/', File.basename('//')
+  assert_equal 'a', File.basename('/a/')
+  assert_equal 'b', File.basename('/a/b')
+  assert_equal 'b', File.basename('../a/b')
+end
+
+assert('File.dirname') do
+  assert_equal '.',    File.dirname('')
+  assert_equal '.',    File.dirname('a')
+  assert_equal '/',    File.dirname('/a')
+  assert_equal 'a',    File.dirname('a/b')
+  assert_equal '/a',   File.dirname('/a/b')
+end
+
+assert('File.extname') do
+  assert_equal '.txt', File.extname('foo/foo.txt')
+  assert_equal '.gz',  File.extname('foo/foo.tar.gz')
+  assert_equal '', File.extname('foo/bar')
+  assert_equal '', File.extname('foo/.bar')
+  assert_equal '', File.extname('foo.txt/bar')
+  assert_equal '', File.extname('.foo')
+end
+
+assert('IO#flock') do
+  f = File.open $mrbtest_io_rfname
+  assert_equal(f.flock(File::LOCK_SH), 0)
+  assert_equal(f.flock(File::LOCK_UN), 0)
+  assert_equal(f.flock(File::LOCK_EX | File::LOCK_NB), 0)
+  assert_equal(f.flock(File::LOCK_UN), 0)
+  f.close
+  true
+end
+
+
+assert('File.size') do
+  File.size($mrbtest_io_rfname) == $mrbtest_io_msg.size and
+  File.size($mrbtest_io_wfname) == 0
+end
+
+assert('File.join') do
+  File.join() == "" and
+  File.join("a") == "a" and
+  File.join("/a") == "/a" and
+  File.join("a/") == "a/" and
+  File.join("a", "b", "c") == "a/b/c" and
+  File.join("/a", "b", "c") == "/a/b/c" and
+  File.join("a", "b", "c/") == "a/b/c/" and
+  File.join("a/", "/b/", "/c") == "a/b/c"
+end
+
+assert('File.realpath') do
+  usrbin = IO.popen("cd bin; /bin/pwd -P") { |f| f.read.chomp }
+  assert_equal usrbin, File.realpath("bin")
+end
+
+assert('File TEST CLEANUP') do
+  assert_nil MRubyIOTestUtil.io_test_cleanup
+end
+
+assert('File.expand_path') do
+  assert_equal "/",    File.expand_path("..", "/tmp"),       "parent path with base_dir (1)"
+  assert_equal "/tmp", File.expand_path("..", "/tmp/mruby"), "parent path with base_dir (2)"
+
+  assert_equal "/home", File.expand_path("/home"),      "absolute"
+  assert_equal "/home", File.expand_path("/home", "."), "absolute with base_dir"
+
+  assert_equal "/hoge", File.expand_path("/tmp/..//hoge")
+  assert_equal "/hoge", File.expand_path("////tmp/..///////hoge")
+
+  assert_equal "/", File.expand_path("../../../..", "/")
+  assert_equal "/", File.expand_path(([".."] * 100).join("/"))
+end
+
+assert('File.expand_path (with ENV)') do
+  skip unless Object.const_defined?(:ENV) && ENV['HOME']
+
+  assert_equal ENV['HOME'], File.expand_path("~/"),      "home"
+  assert_equal ENV['HOME'], File.expand_path("~/", "/"), "home with base_dir"
+
+  assert_equal "#{ENV['HOME']}/user", File.expand_path("user", ENV['HOME']), "relative with base_dir"
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/test/file_test.rb mruby-1.0.0-seaos/build/mrbgems/mruby-io/test/file_test.rb
--- mruby-1.0.0/build/mrbgems/mruby-io/test/file_test.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/test/file_test.rb	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1,90 @@
+##
+# FileTest
+
+assert('FileTest TEST SETUP') do
+  MRubyIOTestUtil.io_test_setup
+end
+
+assert("FileTest.directory?") do
+  assert_equal true,  FileTest.directory?("/tmp")
+  assert_equal false, FileTest.directory?("/bin/sh")
+end
+
+assert("FileTest.exist?") do
+  assert_equal true,  FileTest.exist?($mrbtest_io_rfname), "filename - exist"
+  assert_equal false, FileTest.exist?($mrbtest_io_rfname + "-"), "filename - not exist"
+  io = IO.new(IO.sysopen($mrbtest_io_rfname))
+  assert_equal true,  FileTest.exist?(io), "io obj - exist"
+  io.close
+  assert_equal true, io.closed?
+  assert_raise IOError do
+    FileTest.exist?(io)
+  end
+end
+
+assert("FileTest.file?") do
+  assert_equal false, FileTest.file?("/tmp")
+  assert_equal true,  FileTest.file?("/bin/sh")
+end
+
+assert("FileTest.pipe?") do
+  io = IO.popen("ls")
+  assert_equal true,  FileTest.pipe?(io)
+  assert_equal false, FileTest.pipe?("/tmp")
+end
+
+assert("FileTest.size?") do
+  assert_equal $mrbtest_io_msg.size, FileTest.size?($mrbtest_io_rfname)
+  assert_equal nil, FileTest.size?($mrbtest_io_wfname)
+  assert_equal nil, FileTest.size?("not-exist-test-target-file")
+
+  fp1 = File.open($mrbtest_io_rfname)
+  fp2 = File.open($mrbtest_io_wfname)
+  assert_equal $mrbtest_io_msg.size,  FileTest.size?(fp1)
+  assert_equal nil, FileTest.size?(fp2)
+  fp1.close
+  fp2.close
+
+  assert_raise IOError do
+    FileTest.size?(fp1)
+  end
+  assert_raise IOError do
+    FileTest.size?(fp2)
+  end
+
+  fp1.closed? && fp2.closed?
+end
+
+assert("FileTest.socket?") do
+  assert_true FileTest.socket?($mrbtest_io_socketname)
+end
+
+assert("FileTest.symlink?") do
+  assert_true FileTest.symlink?($mrbtest_io_symlinkname)
+end
+
+assert("FileTest.zero?") do
+  assert_equal false, FileTest.zero?($mrbtest_io_rfname)
+  assert_equal true,  FileTest.zero?($mrbtest_io_wfname)
+  assert_equal false, FileTest.zero?("not-exist-test-target-file")
+
+  fp1 = File.open($mrbtest_io_rfname)
+  fp2 = File.open($mrbtest_io_wfname)
+  assert_equal false, FileTest.zero?(fp1)
+  assert_equal true,  FileTest.zero?(fp2)
+  fp1.close
+  fp2.close
+
+  assert_raise IOError do
+    FileTest.zero?(fp1)
+  end
+  assert_raise IOError do
+    FileTest.zero?(fp2)
+  end
+
+  fp1.closed? && fp2.closed?
+end
+
+assert('FileTest TEST CLEANUP') do
+  assert_nil MRubyIOTestUtil.io_test_cleanup
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/test/gc_filedes.sh mruby-1.0.0-seaos/build/mrbgems/mruby-io/test/gc_filedes.sh
--- mruby-1.0.0/build/mrbgems/mruby-io/test/gc_filedes.sh	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/test/gc_filedes.sh	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1,4 @@
+#!/bin/sh
+
+ulimit -n 20
+mruby -e '100.times { File.open "'$0'" }'
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/test/io.rb mruby-1.0.0-seaos/build/mrbgems/mruby-io/test/io.rb
--- mruby-1.0.0/build/mrbgems/mruby-io/test/io.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/test/io.rb	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1,351 @@
+##
+# IO Test
+
+assert('IO TEST SETUP') do
+  MRubyIOTestUtil.io_test_setup
+end
+
+assert('IO', '15.2.20') do
+  assert_equal(Class, IO.class)
+end
+
+assert('IO', '15.2.20.2') do
+  assert_equal(Object, IO.superclass)
+end
+
+assert('IO', '15.2.20.3') do
+  assert_include(IO.included_modules, Enumerable)
+end
+
+assert('IO.open', '15.2.20.4.1') do
+  fd = IO.sysopen $mrbtest_io_rfname
+  assert_equal Fixnum, fd.class
+  io = IO.open fd
+  assert_equal IO, io.class
+  assert_equal $mrbtest_io_msg, io.read
+  io.close
+
+  fd = IO.sysopen $mrbtest_io_rfname
+  IO.open(fd) do |io|
+    assert_equal $mrbtest_io_msg, io.read
+  end
+
+  true
+end
+
+assert('IO#close', '15.2.20.5.1') do
+  io = IO.new(IO.sysopen($mrbtest_io_rfname))
+  assert_nil io.close
+end
+
+assert('IO#closed?', '15.2.20.5.2') do
+  io = IO.new(IO.sysopen($mrbtest_io_rfname))
+  assert_false io.closed?
+  io.close
+  assert_true io.closed?
+end
+
+#assert('IO#each', '15.2.20.5.3') do
+#assert('IO#each_byte', '15.2.20.5.4') do
+#assert('IO#each_line', '15.2.20.5.5') do
+
+assert('IO#eof?', '15.2.20.5.6') do
+  io = IO.new(IO.sysopen($mrbtest_io_rfname))
+  $mrbtest_io_msg.each_char { |ch|
+    # XXX
+    #assert_false io.eof?
+    io.getc
+  }
+  assert_true io.eof?
+  io.close
+  true
+end
+
+assert('IO#flush', '15.2.20.5.7') do
+  # Note: mruby-io does not have any buffer to be flushed now.
+  io = IO.new(IO.sysopen($mrbtest_io_wfname))
+  assert_equal io, io.flush
+  io.close
+  assert_raise(IOError) do
+    io.flush
+  end
+end
+
+assert('IO#getc', '15.2.20.5.8') do
+  io = IO.new(IO.sysopen($mrbtest_io_rfname))
+  $mrbtest_io_msg.each_char { |ch|
+    assert_equal ch, io.getc
+  }
+  assert_equal nil, io.getc
+  io.close
+  true
+end
+
+#assert('IO#gets', '15.2.20.5.9') do
+#assert('IO#initialize_copy', '15.2.20.5.10') do
+#assert('IO#print', '15.2.20.5.11') do
+#assert('IO#putc', '15.2.20.5.12') do
+#assert('IO#puts', '15.2.20.5.13') do
+
+assert('IO#read', '15.2.20.5.14') do
+  IO.open(IO.sysopen($mrbtest_io_rfname)) do |io|
+    assert_raise(ArgumentError) { io.read(-5) }
+    assert_raise(TypeError) { io.read("str") }
+
+    len = $mrbtest_io_msg.length
+    assert_equal '', io.read(0)
+    assert_equal 'mruby', io.read(5)
+    assert_equal $mrbtest_io_msg[5,len], io.read(len)
+
+    assert_equal "", io.read
+    assert_nil io.read(1)
+  end
+
+  IO.open(IO.sysopen($mrbtest_io_rfname)) do |io|
+    assert_equal $mrbtest_io_msg, io.read
+  end
+end
+
+assert('IO#readchar', '15.2.20.5.15') do
+  # almost same as IO#getc
+  IO.open(IO.sysopen($mrbtest_io_rfname)) do |io|
+    $mrbtest_io_msg.each_char { |ch|
+      assert_equal ch, io.readchar
+    }
+    assert_raise(EOFError) do
+      io.readchar
+    end
+  end
+end
+
+#assert('IO#readline', '15.2.20.5.16') do
+#assert('IO#readlines', '15.2.20.5.17') do
+#assert('IO#sync', '15.2.20.5.18') do
+#assert('IO#sync=', '15.2.20.5.19') do
+
+assert('IO#write', '15.2.20.5.20') do
+  io = IO.open(IO.sysopen($mrbtest_io_wfname))
+  assert_equal 0, io.write("")
+  io.close
+  true
+end
+
+assert('IO.for_fd') do
+  fd = IO.sysopen($mrbtest_io_rfname)
+  io = IO.for_fd(fd)
+    assert_equal $mrbtest_io_msg, io.read
+  io.close
+  true
+end
+
+assert('IO.new') do
+  io = IO.new(0)
+  io.close
+  true
+end
+
+assert('IO gc check') do
+  100.times { IO.new(0) }
+end
+
+assert('IO.sysopen("./nonexistent")') do
+  if Object.const_defined? :Errno
+    eclass = Errno::ENOENT
+  else
+    eclass = RuntimeError
+  end
+  assert_raise eclass do
+    fd = IO.sysopen "./nonexistent"
+    IO._sysclose fd
+  end
+end
+
+assert('IO.sysopen, IO#sysread') do
+  fd = IO.sysopen $mrbtest_io_rfname
+  io = IO.new fd
+  str1 = "     "
+  str2 = io.sysread(5, str1)
+  assert_equal $mrbtest_io_msg[0,5], str1
+  assert_equal $mrbtest_io_msg[0,5], str2
+  assert_raise EOFError do
+    io.sysread(10000)
+    io.sysread(10000)
+  end
+  io.close
+  io.closed?
+end
+
+assert('IO.sysopen, IO#syswrite') do
+  fd = IO.sysopen $mrbtest_io_wfname, "w"
+  io = IO.new fd, "w"
+  str = "abcdefg"
+  len = io.syswrite(str)
+  assert_equal str.size, len
+  io.close
+
+  io = IO.new(IO.sysopen($mrbtest_io_rfname), "r")
+  assert_raise(IOError) { io.syswrite("a") }
+  io.close
+
+  true
+end
+
+assert('IO#_read_buf') do
+  fd = IO.sysopen $mrbtest_io_rfname
+  io = IO.new fd
+  def io._buf
+    @buf
+  end
+  msg_len = $mrbtest_io_msg.size
+  assert_equal '', io._buf
+  assert_equal $mrbtest_io_msg, io._read_buf
+  assert_equal $mrbtest_io_msg, io._buf
+  assert_equal 'mruby', io.read(5)
+  assert_equal 5, io.pos
+  assert_equal msg_len - 5, io._buf.size
+  assert_equal $mrbtest_io_msg[5,100], io.read
+  assert_equal 0, io._buf.size
+  assert_raise EOFError do
+    io._read_buf
+  end
+  assert_equal true, io.eof
+  assert_equal true, io.eof?
+  io.close
+  io.closed?
+end
+
+assert('IO#pos=, IO#seek') do
+  fd = IO.sysopen $mrbtest_io_rfname
+  io = IO.new fd
+  def io._buf
+    @buf
+  end
+  assert_equal 'm', io.getc
+  assert_equal 1, io.pos
+  assert_equal 0, io.seek(0)
+  assert_equal 0, io.pos
+  io.close
+  io.closed?
+end
+
+assert('IO#gets') do
+  fd = IO.sysopen $mrbtest_io_rfname
+  io = IO.new fd
+
+  # gets without arguments
+  assert_equal $mrbtest_io_msg, io.gets, "gets without arguments"
+  assert_equal nil, io.gets, "gets returns nil, when EOF"
+
+  # gets with limit
+  io.pos = 0
+  assert_equal $mrbtest_io_msg[0, 5], io.gets(5), "gets with limit"
+
+  # gets with rs
+  io.pos = 0
+  assert_equal $mrbtest_io_msg[0, 6], io.gets(' '), "gets with rs"
+
+  # gets with rs, limit
+  io.pos = 0
+  assert_equal $mrbtest_io_msg[0, 5], io.gets(' ', 5), "gets with rs, limit"
+  io.close
+  assert_equal true, io.closed?, "close success"
+
+  # reading many-lines file.
+  fd = IO.sysopen $mrbtest_io_wfname, "w"
+  io = IO.new fd, "w"
+  io.write "0123456789" * 2 + "\na"
+  assert_equal 22, io.pos
+  io.close
+  assert_equal true, io.closed?
+
+  fd = IO.sysopen $mrbtest_io_wfname
+  io = IO.new fd
+  line = io.gets
+
+  # gets first line
+  assert_equal "0123456789" * 2 + "\n", line, "gets first line"
+  assert_equal 21, line.size
+  assert_equal 21, io.pos
+
+  # gets second line
+  assert_equal "a", io.gets, "gets second line"
+
+  # gets third line
+  assert_equal nil, io.gets, "gets third line; returns nil"
+
+  io.close
+  io.closed?
+end
+
+assert('IO#gets - paragraph mode') do
+  fd = IO.sysopen $mrbtest_io_wfname, "w"
+  io = IO.new fd, "w"
+  io.write "0" * 10 + "\n"
+  io.write "1" * 10 + "\n\n"
+  io.write "2" * 10 + "\n"
+  assert_equal 34, io.pos
+  io.close
+  assert_equal true, io.closed?
+
+  fd = IO.sysopen $mrbtest_io_wfname
+  io = IO.new fd
+  para1 = "#{'0' * 10}\n#{'1' * 10}\n\n"
+  text1 = io.gets("")
+  assert_equal para1, text1
+  para2 = "#{'2' * 10}\n"
+  text2 = io.gets("")
+  assert_equal para2, text2
+  io.close
+  io.closed?
+end
+
+assert('IO.popen') do
+  io = IO.popen("ls")
+  assert_equal Fixnum, io.pid.class
+  ls = io.read
+  assert_equal ls.class, String
+  assert_include ls, 'AUTHORS'
+  assert_include ls, 'mrblib'
+  io.close
+  io.closed?
+end
+
+assert('IO.read') do
+  # empty file
+  fd = IO.sysopen $mrbtest_io_wfname, "w"
+  io = IO.new fd, "w"
+  io.close
+  assert_equal "",  IO.read($mrbtest_io_wfname)
+  assert_equal nil, IO.read($mrbtest_io_wfname, 1)
+
+  # one byte file
+  fd = IO.sysopen $mrbtest_io_wfname, "w"
+  io = IO.new fd, "w"
+  io.write "123"
+  io.close
+  assert_equal "123", IO.read($mrbtest_io_wfname)
+  assert_equal "",    IO.read($mrbtest_io_wfname, 0)
+  assert_equal "1",   IO.read($mrbtest_io_wfname, 1)
+  assert_equal "",    IO.read($mrbtest_io_wfname, 0, 10)
+  assert_equal "23",  IO.read($mrbtest_io_wfname, 2, 1)
+  assert_equal "23",  IO.read($mrbtest_io_wfname, 10, 1)
+  assert_equal "",    IO.read($mrbtest_io_wfname, nil, 10)
+  assert_equal nil,   IO.read($mrbtest_io_wfname, 1, 10)
+end
+
+assert('IO#fileno') do
+  fd = IO.sysopen $mrbtest_io_rfname
+  io = IO.new fd
+  assert_equal io.fileno, fd
+  assert_equal io.to_i, fd
+  io.close
+  io.closed?
+end
+
+assert('`cmd`') do
+  assert_equal `echo foo`, "foo\n"
+end
+
+assert('IO TEST CLEANUP') do
+  assert_nil MRubyIOTestUtil.io_test_cleanup
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-io/test/mruby_io_test.c mruby-1.0.0-seaos/build/mrbgems/mruby-io/test/mruby_io_test.c
--- mruby-1.0.0/build/mrbgems/mruby-io/test/mruby_io_test.c	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-io/test/mruby_io_test.c	2014-06-20 19:04:01.327824780 -0700
@@ -0,0 +1,141 @@
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/un.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "mruby.h"
+#include "mruby/array.h"
+#include "mruby/string.h"
+#include "mruby/variable.h"
+
+static mrb_value
+mrb_io_test_io_setup(mrb_state *mrb, mrb_value self)
+{
+  char rfname[]      = "tmp.mruby-io-test.XXXXXXXX";
+  char wfname[]      = "tmp.mruby-io-test.XXXXXXXX";
+  char symlinkname[] = "tmp.mruby-io-test.XXXXXXXX";
+  char socketname[]  = "tmp.mruby-io-test.XXXXXXXX";
+  char msg[] = "mruby io test\n";
+  mode_t mask;
+  int fd0, fd1, fd2, fd3;
+  FILE *fp;
+  struct sockaddr_un sun0;
+
+  mask = umask(077);
+  fd0 = mkstemp(rfname);
+  fd1 = mkstemp(wfname);
+  fd2 = mkstemp(symlinkname);
+  fd3 = mkstemp(socketname);
+  if (fd0 == -1 || fd1 == -1 || fd2 == -1 || fd3 == -1) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "can't create temporary file");
+    return mrb_nil_value();
+  }
+  umask(mask);
+
+  mrb_gv_set(mrb, mrb_intern_cstr(mrb, "$mrbtest_io_rfname"), mrb_str_new_cstr(mrb, rfname));
+  mrb_gv_set(mrb, mrb_intern_cstr(mrb, "$mrbtest_io_wfname"), mrb_str_new_cstr(mrb, wfname));
+  mrb_gv_set(mrb, mrb_intern_cstr(mrb, "$mrbtest_io_symlinkname"), mrb_str_new_cstr(mrb, symlinkname));
+  mrb_gv_set(mrb, mrb_intern_cstr(mrb, "$mrbtest_io_socketname"), mrb_str_new_cstr(mrb, socketname));
+  mrb_gv_set(mrb, mrb_intern_cstr(mrb, "$mrbtest_io_msg"), mrb_str_new_cstr(mrb, msg));
+
+  fp = fopen(rfname, "w");
+  if (fp == NULL) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "can't open temporary file");
+    return mrb_nil_value();
+  }
+  fputs(msg, fp);
+  fclose(fp);
+
+  fp = fopen(wfname, "w");
+  if (fp == NULL) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "can't open temporary file");
+    return mrb_nil_value();
+  }
+  fclose(fp);
+
+  unlink(symlinkname);
+  close(fd2);
+  if (symlink("hoge", symlinkname) == -1) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "can't make a symbolic link");
+  }
+
+  unlink(socketname);
+  close(fd3);
+  fd3 = socket(AF_UNIX, SOCK_STREAM, 0);
+  if (fd3 == -1) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "can't make a socket");
+  }
+  sun0.sun_family = AF_UNIX;
+  snprintf(sun0.sun_path, sizeof(sun0.sun_path), "%s", socketname);
+  if (bind(fd3, (struct sockaddr *)&sun0, sizeof(sun0)) == -1) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "can't make a socket bi");
+  }
+  close(fd3);
+
+  return mrb_true_value();
+}
+
+static mrb_value
+mrb_io_test_io_cleanup(mrb_state *mrb, mrb_value self)
+{
+  mrb_value rfname = mrb_gv_get(mrb, mrb_intern_cstr(mrb, "$mrbtest_io_rfname"));
+  mrb_value wfname = mrb_gv_get(mrb, mrb_intern_cstr(mrb, "$mrbtest_io_wfname"));
+  mrb_value symlinkname = mrb_gv_get(mrb, mrb_intern_cstr(mrb, "$mrbtest_io_symlinkname"));
+  mrb_value socketname = mrb_gv_get(mrb, mrb_intern_cstr(mrb, "$mrbtest_io_socketname"));
+
+  if (mrb_type(rfname) == MRB_TT_STRING) {
+    remove(RSTRING_PTR(rfname));
+  }
+  if (mrb_type(wfname) == MRB_TT_STRING) {
+    remove(RSTRING_PTR(wfname));
+  }
+  if (mrb_type(symlinkname) == MRB_TT_STRING) {
+    remove(RSTRING_PTR(symlinkname));
+  }
+  if (mrb_type(socketname) == MRB_TT_STRING) {
+    remove(RSTRING_PTR(socketname));
+  }
+
+  mrb_gv_set(mrb, mrb_intern_cstr(mrb, "$mrbtest_io_rfname"), mrb_nil_value());
+  mrb_gv_set(mrb, mrb_intern_cstr(mrb, "$mrbtest_io_wfname"), mrb_nil_value());
+  mrb_gv_set(mrb, mrb_intern_cstr(mrb, "$mrbtest_io_symlinkname"), mrb_nil_value());
+  mrb_gv_set(mrb, mrb_intern_cstr(mrb, "$mrbtest_io_socketname"), mrb_nil_value());
+  mrb_gv_set(mrb, mrb_intern_cstr(mrb, "$mrbtest_io_msg"), mrb_nil_value());
+
+  return mrb_nil_value();
+}
+
+static mrb_value
+mrb_io_test_file_setup(mrb_state *mrb, mrb_value self)
+{
+  mrb_value ary = mrb_io_test_io_setup(mrb, self);
+  if (symlink("/usr/bin", "test-bin") == -1) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "can't make a symbolic link");
+  }
+
+  return ary;
+}
+
+static mrb_value
+mrb_io_test_file_cleanup(mrb_state *mrb, mrb_value self)
+{
+  mrb_io_test_io_cleanup(mrb, self);
+  remove("test-bin");
+
+  return mrb_nil_value();
+}
+
+void
+mrb_mruby_io_gem_test(mrb_state* mrb)
+{
+  struct RClass *io_test = mrb_define_module(mrb, "MRubyIOTestUtil");
+  mrb_define_class_method(mrb, io_test, "io_test_setup", mrb_io_test_io_setup, MRB_ARGS_NONE());
+  mrb_define_class_method(mrb, io_test, "io_test_cleanup", mrb_io_test_io_cleanup, MRB_ARGS_NONE());
+
+  mrb_define_class_method(mrb, io_test, "file_test_setup", mrb_io_test_file_setup, MRB_ARGS_NONE());
+  mrb_define_class_method(mrb, io_test, "file_test_cleanup", mrb_io_test_file_cleanup, MRB_ARGS_NONE());
+
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/HEAD	2014-06-20 19:34:10.814070591 -0700
@@ -0,0 +1 @@
+ref: refs/heads/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/config mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/config
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/config	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/config	2014-06-20 19:34:10.814070591 -0700
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = https://github.com/iij/mruby-require.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/description mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/description
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/description	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/description	2014-06-20 19:34:09.924068131 -0700
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/applypatch-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/applypatch-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/applypatch-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/applypatch-msg.sample	2014-06-20 19:34:09.924068131 -0700
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/commit-msg" &&
+	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
+:
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/commit-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/commit-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/commit-msg.sample	2014-06-20 19:34:09.924068131 -0700
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/post-update.sample mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/post-update.sample
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/post-update.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/post-update.sample	2014-06-20 19:34:09.924068131 -0700
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/pre-applypatch.sample mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/pre-applypatch.sample
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/pre-applypatch.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/pre-applypatch.sample	2014-06-20 19:34:09.924068131 -0700
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
+:
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/pre-commit.sample mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/pre-commit.sample
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/pre-commit.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/pre-commit.sample	2014-06-20 19:34:09.924068131 -0700
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/pre-push.sample mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/pre-push.sample
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/pre-push.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/pre-push.sample	2014-06-20 19:34:09.924068131 -0700
@@ -0,0 +1,54 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+IFS=' '
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/pre-rebase.sample mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/pre-rebase.sample
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/pre-rebase.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/pre-rebase.sample	2014-06-20 19:34:09.924068131 -0700
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up-to-date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+exit 0
+
+################################################################
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/prepare-commit-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/prepare-commit-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/prepare-commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/prepare-commit-msg.sample	2014-06-20 19:34:09.924068131 -0700
@@ -0,0 +1,36 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples.  The first comments out the
+# "Conflicts:" part of a merge commit.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+case "$2,$3" in
+  merge,)
+    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
+
+# ,|template,)
+#   /usr/bin/perl -i.bak -pe '
+#      print "\n" . `git diff --cached --name-status -r`
+#	 if /^#/ && $first++ == 0' "$1" ;;
+
+  *) ;;
+esac
+
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/update.sample mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/update.sample
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/hooks/update.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/hooks/update.sample	2014-06-20 19:34:09.924068131 -0700
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to blocks unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
Binary files mruby-1.0.0/build/mrbgems/mruby-require/.git/index and mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/index differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/info/exclude mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/info/exclude
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/info/exclude	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/info/exclude	2014-06-20 19:34:09.924068131 -0700
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/logs/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/logs/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/logs/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/logs/HEAD	2014-06-20 19:34:10.814070591 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 2a2103bc2bc48b2a396b402ca94b05429f16f629 Daniel Bittman <danielbittman1@gmail.com> 1403318050 -0700	clone: from https://github.com/iij/mruby-require.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/logs/refs/heads/master mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/logs/refs/heads/master
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/logs/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/logs/refs/heads/master	2014-06-20 19:34:10.814070591 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 2a2103bc2bc48b2a396b402ca94b05429f16f629 Daniel Bittman <danielbittman1@gmail.com> 1403318050 -0700	clone: from https://github.com/iij/mruby-require.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/logs/refs/remotes/origin/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/logs/refs/remotes/origin/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/logs/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/logs/refs/remotes/origin/HEAD	2014-06-20 19:34:10.814070591 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 2a2103bc2bc48b2a396b402ca94b05429f16f629 Daniel Bittman <danielbittman1@gmail.com> 1403318050 -0700	clone: from https://github.com/iij/mruby-require.git
Binary files mruby-1.0.0/build/mrbgems/mruby-require/.git/objects/pack/pack-4c7624b3be141271b911fb0b9a057f80ec687307.idx and mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/objects/pack/pack-4c7624b3be141271b911fb0b9a057f80ec687307.idx differ
Binary files mruby-1.0.0/build/mrbgems/mruby-require/.git/objects/pack/pack-4c7624b3be141271b911fb0b9a057f80ec687307.pack and mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/objects/pack/pack-4c7624b3be141271b911fb0b9a057f80ec687307.pack differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/packed-refs mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/packed-refs
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/packed-refs	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/packed-refs	2014-06-20 19:34:10.814070591 -0700
@@ -0,0 +1,3 @@
+# pack-refs with: peeled fully-peeled 
+de16485ff5dbe3b7dc8883b7111adb565f17d6cb refs/remotes/origin/fix_api_name
+2a2103bc2bc48b2a396b402ca94b05429f16f629 refs/remotes/origin/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/refs/heads/master mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/refs/heads/master
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/refs/heads/master	2014-06-20 19:34:10.814070591 -0700
@@ -0,0 +1 @@
+2a2103bc2bc48b2a396b402ca94b05429f16f629
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.git/refs/remotes/origin/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/refs/remotes/origin/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-require/.git/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.git/refs/remotes/origin/HEAD	2014-06-20 19:34:10.814070591 -0700
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.gitignore mruby-1.0.0-seaos/build/mrbgems/mruby-require/.gitignore
--- mruby-1.0.0/build/mrbgems/mruby-require/.gitignore	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.gitignore	2014-06-20 19:34:10.817403933 -0700
@@ -0,0 +1 @@
+/tmp
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/.travis.yml mruby-1.0.0-seaos/build/mrbgems/mruby-require/.travis.yml
--- mruby-1.0.0/build/mrbgems/mruby-require/.travis.yml	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/.travis.yml	2014-06-20 19:34:10.817403933 -0700
@@ -0,0 +1,2 @@
+script:
+  - "ruby run_test.rb all test"
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/README.md mruby-1.0.0-seaos/build/mrbgems/mruby-require/README.md
--- mruby-1.0.0/build/mrbgems/mruby-require/README.md	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/README.md	2014-06-20 19:34:10.817403933 -0700
@@ -0,0 +1,59 @@
+mruby-require
+=============
+
+"mruby-require" is a mrbgem, provides
+[require](http://docs.ruby-lang.org/ja/2.0.0/class/Kernel.html#M_REQUIRE) and
+[load](http://docs.ruby-lang.org/ja/2.0.0/class/Kernel.html#M_LOAD) for mruby.
+
+### Example:
+
+```Ruby
+# a.rb
+
+require "b"
+
+b = Bclass.new
+p b.method
+```
+```Ruby
+# b.rb
+
+class Bclass
+  def method
+    "BBB"
+  end
+end
+```
+```sh
+% mruby a.rb
+"BBB"
+```
+
+
+### To run the tests:
+
+    ruby run_test.rb
+
+
+## License
+
+Copyright (c) 2013 Internet Initiative Japan Inc.
+
+Permission is hereby granted, free of charge, to any person obtaining a 
+copy of this software and associated documentation files (the "Software"), 
+to deal in the Software without restriction, including without limitation 
+the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+and/or sell copies of the Software, and to permit persons to whom the 
+Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in 
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+DEALINGS IN THE SOFTWARE.
+
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/mrbgem.rake mruby-1.0.0-seaos/build/mrbgems/mruby-require/mrbgem.rake
--- mruby-1.0.0/build/mrbgems/mruby-require/mrbgem.rake	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/mrbgem.rake	2014-06-20 19:34:10.817403933 -0700
@@ -0,0 +1,11 @@
+MRuby::Gem::Specification.new('mruby-require') do |spec|
+  spec.license = 'MIT'
+  spec.authors = 'Internet Initiative Japan Inc.'
+
+  ['mruby-array-ext', 'mruby-io', 'mruby-dir', 'mruby-tempfile'].each do |v|
+    add_dependency v
+  end
+
+  spec.cc.include_paths << "#{build.root}/src"
+end
+
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/mrblib/require.rb mruby-1.0.0-seaos/build/mrbgems/mruby-require/mrblib/require.rb
--- mruby-1.0.0/build/mrbgems/mruby-require/mrblib/require.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/mrblib/require.rb	2014-06-20 19:34:10.817403933 -0700
@@ -0,0 +1,85 @@
+class LoadError < ScriptError; end
+
+module Kernel
+  def load(path)
+    raise NotImplementedError.new "'require' method depends on File"  unless Object.const_defined?(:File)
+    raise TypeError  unless path.class == String
+
+    if File.exist?(path) && File.extname(path) == ".mrb"
+      _load_mrb_file path
+    elsif File.exist?(path)
+      _load_rb_str File.open(path).read.to_s, path
+    else
+      raise LoadError.new "File not found -- #{path}"
+    end
+  end
+
+  def require(path)
+    raise NotImplementedError.new "'require' method depends on File"  unless Object.const_defined?(:File)
+    raise TypeError  unless path.class == String
+
+    # require method can load .rb, .mrb or without-ext filename only.
+    unless ["", ".rb", ".mrb"].include? File.extname(path)
+      raise LoadError.new "cannot load such file -- #{path}"
+    end
+
+    filenames = []
+    if File.extname(path).size == 0
+      filenames << "#{path}.rb"
+      filenames << "#{path}.mrb"
+    else
+      filenames << path
+    end
+
+    dir = nil
+    filename = nil
+    if ['/', '.'].include? path[0]
+      path0 = filenames.find do |fname|
+        File.file?(fname) && File.exist?(fname)
+      end
+    else
+      dir = ($LOAD_PATH || []).find do |dir0|
+        filename = filenames.find do |fname|
+          path0 = File.join dir0, fname
+          File.file?(path0) && File.exist?(path0)
+        end
+      end
+      path0 = dir && filename ? File.join(dir, filename) : nil
+    end
+
+    if path0 && File.exist?(path0) && File.file?(path0)
+      __require__ path0
+    else
+      raise LoadError.new "cannot load such file -- #{path}"
+    end
+  end
+
+  def __require__(realpath)
+    raise LoadError.new "File not found -- #{realpath}"  unless File.exist? realpath
+    $" ||= []
+    $__mruby_loading_files__ ||= []
+
+    # already required
+    return false  if ($" + $__mruby_loading_files__).include?(realpath)
+
+    $__mruby_loading_files__ << realpath
+    load realpath
+    $" << realpath
+    $__mruby_loading_files__.delete realpath
+
+    true
+  end
+end
+
+
+$LOAD_PATH ||= []
+$LOAD_PATH << '.'
+
+if Object.const_defined?(:ENV)
+  $LOAD_PATH.unshift(*ENV['MRBLIB'].split(':')) unless ENV['MRBLIB'].nil?
+end
+
+$LOAD_PATH.uniq!
+
+$" ||= []
+$__mruby_loading_files__ ||= []
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/run_test.rb mruby-1.0.0-seaos/build/mrbgems/mruby-require/run_test.rb
--- mruby-1.0.0/build/mrbgems/mruby-require/run_test.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/run_test.rb	2014-06-20 19:34:10.817403933 -0700
@@ -0,0 +1,28 @@
+#!/usr/bin/env ruby
+#
+# mrbgems test runner
+#
+
+if __FILE__ == $0
+  repository, dir = 'https://github.com/mruby/mruby.git', 'tmp/mruby'
+
+  build_args = ARGV
+
+  Dir.mkdir 'tmp'  unless File.exist?('tmp')
+  unless File.exist?(dir)
+    system "git clone #{repository} #{dir}"
+  end
+
+  exit system(%Q[cd #{dir}; MRUBY_CONFIG=#{File.expand_path __FILE__} ruby minirake #{build_args.join(' ')}])
+end
+
+MRuby::Build.new do |conf|
+  toolchain :gcc
+  conf.gembox 'default'
+
+  conf.gem :git => 'https://github.com/iij/mruby-io.git'
+  conf.gem :git => 'https://github.com/iij/mruby-dir.git'
+  conf.gem :git => 'https://github.com/iij/mruby-tempfile.git'
+
+  conf.gem File.expand_path(File.dirname(__FILE__))
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/src/require.c mruby-1.0.0-seaos/build/mrbgems/mruby-require/src/require.c
--- mruby-1.0.0/build/mrbgems/mruby-require/src/require.c	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/src/require.c	2014-06-20 19:38:22.988098592 -0700
@@ -0,0 +1,206 @@
+
+#include <fcntl.h>
+#include <setjmp.h>
+#include <unistd.h>
+
+#include "mruby.h"
+#include "mruby/compile.h"
+#include "mruby/dump.h"
+#include "mruby/string.h"
+#include "mruby/proc.h"
+
+#include "opcode.h"
+#include "error.h"
+
+#include <stdlib.h>
+#include <sys/stat.h>
+
+#define E_LOAD_ERROR (mrb_class_get(mrb, "LoadError"))
+
+#if MRUBY_RELEASE_NO < 10000
+mrb_value mrb_yield_internal(mrb_state *mrb, mrb_value b, int argc, mrb_value *argv, mrb_value self, struct RClass *c);
+#define mrb_yield_with_class mrb_yield_internal
+#endif
+
+#if defined(_WIN32) || defined(_WIN64)
+  #include <windows.h>
+  int mkstemp(char *template)
+  {
+    DWORD pathSize;
+    char pathBuffer[1000];
+    char tempFilename[MAX_PATH];
+    UINT uniqueNum;
+    pathSize = GetTempPath(1000, pathBuffer);
+    if (pathSize < 1000) { pathBuffer[pathSize] = 0; }
+    else                 { pathBuffer[0] = 0; }
+    uniqueNum = GetTempFileName(pathBuffer, template, 0, tempFilename);
+    if (uniqueNum == 0) return -1;
+    strncpy(template, tempFilename, MAX_PATH);
+    return open(tempFilename, _O_RDWR|_O_BINARY);
+  }
+#endif
+
+static void
+replace_stop_with_return(mrb_state *mrb, mrb_irep *irep)
+{
+  if (irep->iseq[irep->ilen - 1] == MKOP_A(OP_STOP, 0)) {
+    irep->iseq = mrb_realloc(mrb, irep->iseq, (irep->ilen + 1) * sizeof(mrb_code));
+    irep->iseq[irep->ilen - 1] = MKOP_A(OP_LOADNIL, 0);
+    irep->iseq[irep->ilen] = MKOP_AB(OP_RETURN, 0, OP_R_NORMAL);
+    irep->ilen++;
+  }
+}
+
+static int
+compile_rb2mrb(mrb_state *mrb0, const char *code, int code_len, const char *path, FILE* tmpfp)
+{
+  mrb_state *mrb = mrb_open();
+  mrb_value result;
+  mrbc_context *c;
+  int ret = -1;
+  int debuginfo = 1;
+  mrb_irep *irep;
+
+  c = mrbc_context_new(mrb);
+  c->no_exec = 1;
+  if (path != NULL) {
+    mrbc_filename(mrb, c, path);
+  }
+
+  result = mrb_load_nstring_cxt(mrb, code, code_len, c);
+  if (mrb_undef_p(result)) {
+    mrbc_context_free(mrb, c);
+    mrb_close(mrb);
+    return MRB_DUMP_GENERAL_FAILURE;
+  }
+
+  irep = mrb_proc_ptr(result)->body.irep;
+  ret = mrb_dump_irep_binary(mrb, irep, debuginfo, tmpfp);
+
+  mrbc_context_free(mrb, c);
+  mrb_close(mrb);
+
+  return ret;
+}
+
+static void
+eval_load_irep(mrb_state *mrb, mrb_irep *irep)
+{
+  int ai;
+  struct RProc *proc;
+
+  replace_stop_with_return(mrb, irep);
+  proc = mrb_proc_new(mrb, irep);
+  proc->target_class = mrb->object_class;
+
+  ai = mrb_gc_arena_save(mrb);
+  mrb_yield_with_class(mrb, mrb_obj_value(proc), 0, NULL, mrb_top_self(mrb), mrb->object_class);
+  mrb_gc_arena_restore(mrb, ai);
+}
+
+static mrb_value
+mrb_require_load_rb_str(mrb_state *mrb, mrb_value self)
+{
+  char *path_ptr = NULL;
+#if defined(_WIN32) || defined(_WIN64)
+  char tmpname[MAX_PATH] = "tmp.XXXXXXXX";
+#else
+  char tmpname[] = "tmp.XXXXXXXX";
+#endif
+  mode_t mask;
+  FILE *tmpfp = NULL;
+  int fd = -1, ret;
+  mrb_irep *irep;
+  mrb_value code, path = mrb_nil_value();
+
+  mrb_get_args(mrb, "S|S", &code, &path);
+  if (!mrb_string_p(path)) {
+    path = mrb_str_new_cstr(mrb, "-");
+  }
+  path_ptr = mrb_str_to_cstr(mrb, path);
+
+  mask = umask(077);
+  fd = mkstemp(tmpname);
+  if (fd == -1) {
+    mrb_sys_fail(mrb, "can't create mkstemp() at mrb_require_load_rb_str");
+  }
+  umask(mask);
+
+  tmpfp = fdopen(fd, "r+");
+  if (tmpfp == NULL) {
+    close(fd);
+    mrb_sys_fail(mrb, "can't open temporay file at mrb_require_load_rb_str");
+  }
+
+  ret = compile_rb2mrb(mrb, RSTRING_PTR(code), RSTRING_LEN(code), path_ptr, tmpfp);
+  if (ret != MRB_DUMP_OK) {
+    fclose(tmpfp);
+    remove(tmpname);
+    mrb_raisef(mrb, E_LOAD_ERROR, "can't load file -- %S", path);
+    return mrb_nil_value();
+  }
+
+  rewind(tmpfp);
+  irep = mrb_read_irep_file(mrb, tmpfp);
+  fclose(tmpfp);
+  remove(tmpname);
+
+  if (irep) {
+    eval_load_irep(mrb, irep);
+  } else if (mrb->exc) {
+    // fail to load
+    longjmp(*(jmp_buf*)mrb->jmp, 1);
+  } else {
+    mrb_raisef(mrb, E_LOAD_ERROR, "can't load file -- %S", path);
+    return mrb_nil_value();
+  }
+
+  return mrb_true_value();
+}
+
+static mrb_value
+mrb_require_load_mrb_file(mrb_state *mrb, mrb_value self)
+{
+  char *path_ptr = NULL;
+  FILE *fp = NULL;
+  mrb_irep *irep;
+  mrb_value path;
+
+  mrb_get_args(mrb, "S", &path);
+  path_ptr = mrb_str_to_cstr(mrb, path);
+
+  fp = fopen(path_ptr, "rb");
+  if (fp == NULL) {
+    mrb_raisef(mrb, E_LOAD_ERROR, "can't open file -- %S", path);
+  }
+
+  irep = mrb_read_irep_file(mrb, fp);
+  fclose(fp);
+
+  if (irep) {
+    eval_load_irep(mrb, irep);
+  } else if (mrb->exc) {
+    // fail to load
+    longjmp(*(jmp_buf*)mrb->jmp, 1);
+  } else {
+    mrb_raisef(mrb, E_LOAD_ERROR, "can't load file -- %S", path);
+    return mrb_nil_value();
+  }
+
+  return mrb_true_value();
+}
+
+void
+mrb_mruby_require_gem_init(mrb_state *mrb)
+{
+  struct RClass *krn;
+  krn = mrb->kernel_module;
+
+  mrb_define_method(mrb, krn, "_load_rb_str",   mrb_require_load_rb_str,   MRB_ARGS_ANY());
+  mrb_define_method(mrb, krn, "_load_mrb_file", mrb_require_load_mrb_file, MRB_ARGS_REQ(1));
+}
+
+void
+mrb_mruby_require_gem_final(mrb_state *mrb)
+{
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/test/test.rb mruby-1.0.0-seaos/build/mrbgems/mruby-require/test/test.rb
--- mruby-1.0.0/build/mrbgems/mruby-require/test/test.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/test/test.rb	2014-06-20 19:34:10.817403933 -0700
@@ -0,0 +1,34 @@
+$" = [] # init
+
+assert "Kernel#_load_rb_str" do
+  assert_equal true, self.methods.include?(:_load_rb_str)
+  assert_equal false, Object.const_defined?(:LOAD_RB_STR_TEST)
+  _load_rb_str("LOAD_RB_STR_TEST = 1")
+  assert_equal true, Object.const_defined?(:LOAD_RB_STR_TEST)
+end
+
+assert "$LOAD_PATH check" do
+  assert_equal Array, $LOAD_PATH.class
+end
+
+assert '$" check' do
+  assert_equal [], $"
+end
+
+assert('load - error check') do
+  assert_raise TypeError, "load(nil) should raise TypeError" do
+    load nil
+  end
+  assert_raise LoadError, "load('notfound') should raise LoadError" do
+    load 'notfound'
+  end
+end
+
+assert('require - error check') do
+  assert_raise TypeError, "require(nil) should raise TypeError" do
+    require nil
+  end
+  assert_raise LoadError, "require('notfound') should raise LoadError" do
+    require "notfound"
+  end
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/test/test2.rb mruby-1.0.0-seaos/build/mrbgems/mruby-require/test/test2.rb
--- mruby-1.0.0/build/mrbgems/mruby-require/test/test2.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/test/test2.rb	2014-06-20 19:34:10.817403933 -0700
@@ -0,0 +1,139 @@
+$dir = File.join(Dir.tmpdir, "mruby-require-test-#{Time.now.to_i}.#{Time.now.usec}")
+
+def test_setup
+  Dir.mkdir($dir)  unless File.exist?($dir)
+
+  File.open(File.join($dir, "test.rb"), "w") do |fp|
+    fp.puts "$require_test_variable = 123"
+  end
+
+  File.open(File.join($dir, "test_dir.rb"), "w") do |fp|
+    fp.puts "$test_dir = 'test_dir'"
+  end
+  Dir.mkdir(File.join($dir, "test_dir"))
+  File.open(File.join($dir, "test_dir", "test_dir.rb"), "w") do |fp|
+    fp.puts "$test_dir2 = 'test_dir/test_dir'"
+  end
+
+  File.open(File.join($dir, "test_conf.conf"), "w") do |fp|
+    fp.puts "$test_conf = 'test_conf'"
+  end
+
+  File.open(File.join($dir, "empty.rb"), "w")
+
+  test_reset
+end
+
+def test_reset
+  $require_test_variable = nil
+  $test_dir = nil
+  $test_dir2 = nil
+  $test_conf = nil
+  $LOAD_PATH = [$dir]
+  $" = []
+end
+
+def remove_file_recursive(path)
+  if File.directory? path
+    Dir.entries(path).each do |entry|
+      next if ['.', '..'].include?(entry)
+      remove_file_recursive File.join(path, entry)
+    end
+    Dir.unlink path
+  else
+    File.unlink path
+  end
+end
+
+def test_cleanup
+  if $dir && File.exist?($dir)
+    remove_file_recursive $dir
+  end
+end
+
+#####
+test_setup
+#####
+
+assert("require 'test' should be success") do
+  test_reset
+
+  assert_true require("test"), "require returns true when success"
+  assert_equal [File.join($dir, "test.rb")], $"
+  assert_equal 123, $require_test_variable
+  $require_test_variable = 789
+  assert_false require("test"), "2nd require should returns false"
+  assert_equal 789, $require_test_variable
+
+  test_reset
+
+  assert_true require("test.rb"), "require should be success with '.rb'"
+  assert_equal [File.join($dir, "test.rb")], $"
+end
+
+assert("require with absolute path should be success") do
+  test_reset
+  assert_true require(File.join($dir, "test"))
+  assert_equal [File.join($dir, "test.rb")], $"
+
+  test_reset
+  assert_true require(File.join($dir, "test.rb"))
+  assert_equal [File.join($dir, "test.rb")], $"
+end
+
+assert("require with absolute path && empty load_path") do
+  test_reset
+  $LOAD_PATH = []
+
+  assert_raise LoadError, "cannot load test.rb" do
+    require "test"
+  end
+  assert_equal true, require(File.join($dir, "test"))
+end
+
+assert("require 'test_dir' should be success") do
+  test_reset
+
+  assert_true require("test_dir"), "require 'test_dir' should be load 'test_dir.rb'"
+  assert_equal [File.join($dir, "test_dir.rb")], $"
+  assert_true require("test_dir/test_dir"), "require 'test_dir/test_dir' should be success"
+  assert_equal 'test_dir/test_dir', $test_dir2
+end
+
+assert("require 'test_conf' should be fail") do
+  test_reset
+
+  assert_raise LoadError, "require 'test_conf.conf' should be fail" do
+    require("test_conf.conf")
+  end
+  assert_raise LoadError, "require method can't load *.conf" do
+    require File.join($dir, "test_conf.conf")
+  end
+end
+
+assert("require 'empty' should be success") do
+  test_reset
+
+  assert_true require("empty")
+  assert_equal 0, File.size(File.join($dir, "empty.rb"))
+end
+
+assert("load 'test.rb' should be success") do
+  test_reset
+
+  assert_true load(File.join($dir, "test.rb"))
+  assert_equal 123, $require_test_variable
+  assert_true $".empty?
+end
+
+assert("load 'test_conf.conf' should be success") do
+  test_reset
+
+  assert_equal true, load(File.join($dir, "test_conf.conf"))
+  assert_equal "test_conf", $test_conf
+end
+
+
+#####
+test_cleanup
+#####
diff -uprN mruby-1.0.0/build/mrbgems/mruby-require/test/test_nest_loop.rb mruby-1.0.0-seaos/build/mrbgems/mruby-require/test/test_nest_loop.rb
--- mruby-1.0.0/build/mrbgems/mruby-require/test/test_nest_loop.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-require/test/test_nest_loop.rb	2014-06-20 19:34:10.817403933 -0700
@@ -0,0 +1,58 @@
+$dir = File.join(Dir.tmpdir, "mruby-require-test-#{Time.now.to_i}.#{Time.now.usec}")
+
+def test_setup
+  Dir.mkdir($dir)
+
+  File.open(File.join($dir, "loop1.rb"), "w") do |fp|
+    fp.puts "require 'loop2.rb'"
+    fp.puts "$loop1 = 'loop1'"
+  end
+  File.open(File.join($dir, "loop2.rb"), "w") do |fp|
+    fp.puts "require 'loop1.rb'"
+    fp.puts "$loop2 = 'loop2'"
+  end
+
+  $require_test_count = 10
+  (1..$require_test_count-1).each do |i|
+    File.open(File.join($dir, "#{i+1}.rb"), "w") do |fp|
+      fp.puts "require '#{i}'"
+      fp.puts "s = 0"
+      (0..100).each{|num| fp.puts "s += #{num}" }
+    end
+  end
+  File.open(File.join($dir, "1.rb"), "w") do |fp|
+    fp.puts "$require_test_0 = 123"
+  end
+
+  $LOAD_PATH = [$dir]
+end
+
+def test_cleanup
+  if $dir && File.exist?($dir)
+    Dir.entries($dir).each do |e|
+      next if ['.', '..'].include? e
+      File.unlink File.join($dir,e)
+    end
+    Dir.unlink $dir
+  end
+end
+
+#####
+test_setup
+#####
+
+assert("require loop check") do
+  require 'loop1'
+  assert_equal 'loop1', $loop1
+  assert_equal 'loop2', $loop2
+end
+
+assert("require nest") do
+  before = $".size
+  require "#{$require_test_count}"
+  assert_equal before + $require_test_count, $".size
+end
+
+#####
+test_cleanup
+#####
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/HEAD	2014-06-20 19:36:39.651147831 -0700
@@ -0,0 +1 @@
+ref: refs/heads/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/config mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/config
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/config	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/config	2014-06-20 19:36:39.651147831 -0700
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = https://github.com/iij/mruby-tempfile.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/description mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/description
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/description	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/description	2014-06-20 19:36:36.217805045 -0700
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/applypatch-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/applypatch-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/applypatch-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/applypatch-msg.sample	2014-06-20 19:36:36.217805045 -0700
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/commit-msg" &&
+	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
+:
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/commit-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/commit-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/commit-msg.sample	2014-06-20 19:36:36.217805045 -0700
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/post-update.sample mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/post-update.sample
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/post-update.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/post-update.sample	2014-06-20 19:36:36.217805045 -0700
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/pre-applypatch.sample mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/pre-applypatch.sample
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/pre-applypatch.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/pre-applypatch.sample	2014-06-20 19:36:36.217805045 -0700
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
+:
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/pre-commit.sample mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/pre-commit.sample
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/pre-commit.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/pre-commit.sample	2014-06-20 19:36:36.217805045 -0700
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/pre-push.sample mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/pre-push.sample
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/pre-push.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/pre-push.sample	2014-06-20 19:36:36.217805045 -0700
@@ -0,0 +1,54 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+IFS=' '
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/pre-rebase.sample mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/pre-rebase.sample
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/pre-rebase.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/pre-rebase.sample	2014-06-20 19:36:36.217805045 -0700
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up-to-date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+exit 0
+
+################################################################
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/prepare-commit-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/prepare-commit-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/prepare-commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/prepare-commit-msg.sample	2014-06-20 19:36:36.217805045 -0700
@@ -0,0 +1,36 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples.  The first comments out the
+# "Conflicts:" part of a merge commit.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+case "$2,$3" in
+  merge,)
+    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
+
+# ,|template,)
+#   /usr/bin/perl -i.bak -pe '
+#      print "\n" . `git diff --cached --name-status -r`
+#	 if /^#/ && $first++ == 0' "$1" ;;
+
+  *) ;;
+esac
+
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/update.sample mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/update.sample
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/hooks/update.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/hooks/update.sample	2014-06-20 19:36:36.217805045 -0700
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to blocks unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
Binary files mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/index and mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/index differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/info/exclude mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/info/exclude
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/info/exclude	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/info/exclude	2014-06-20 19:36:36.217805045 -0700
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/logs/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/logs/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/logs/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/logs/HEAD	2014-06-20 19:36:39.651147831 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 fe923befe98932f8f65d908d309a6a95ea1d2603 Daniel Bittman <danielbittman1@gmail.com> 1403318199 -0700	clone: from https://github.com/iij/mruby-tempfile.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/logs/refs/heads/master mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/logs/refs/heads/master
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/logs/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/logs/refs/heads/master	2014-06-20 19:36:39.651147831 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 fe923befe98932f8f65d908d309a6a95ea1d2603 Daniel Bittman <danielbittman1@gmail.com> 1403318199 -0700	clone: from https://github.com/iij/mruby-tempfile.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/logs/refs/remotes/origin/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/logs/refs/remotes/origin/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/logs/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/logs/refs/remotes/origin/HEAD	2014-06-20 19:36:39.651147831 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 fe923befe98932f8f65d908d309a6a95ea1d2603 Daniel Bittman <danielbittman1@gmail.com> 1403318199 -0700	clone: from https://github.com/iij/mruby-tempfile.git
Binary files mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/objects/pack/pack-fc3aad1807f204b7e351199ceeddf6d13b13202c.idx and mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/objects/pack/pack-fc3aad1807f204b7e351199ceeddf6d13b13202c.idx differ
Binary files mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/objects/pack/pack-fc3aad1807f204b7e351199ceeddf6d13b13202c.pack and mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/objects/pack/pack-fc3aad1807f204b7e351199ceeddf6d13b13202c.pack differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/packed-refs mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/packed-refs
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/packed-refs	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/packed-refs	2014-06-20 19:36:39.651147831 -0700
@@ -0,0 +1,3 @@
+# pack-refs with: peeled fully-peeled 
+c20b6731f599f10bb7a5e4bd27fa44443dd33645 refs/remotes/origin/feature_remove_tempfile_finalizing_instance
+fe923befe98932f8f65d908d309a6a95ea1d2603 refs/remotes/origin/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/refs/heads/master mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/refs/heads/master
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/refs/heads/master	2014-06-20 19:36:39.651147831 -0700
@@ -0,0 +1 @@
+fe923befe98932f8f65d908d309a6a95ea1d2603
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/refs/remotes/origin/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/refs/remotes/origin/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.git/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.git/refs/remotes/origin/HEAD	2014-06-20 19:36:39.651147831 -0700
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.gitignore mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.gitignore
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.gitignore	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.gitignore	2014-06-20 19:36:39.654481173 -0700
@@ -0,0 +1,22 @@
+# Object files
+*.o
+
+# Libraries
+*.lib
+*.a
+
+# Shared objects (inc. Windows DLLs)
+*.dll
+*.so
+*.so.*
+*.dylib
+
+# Executables
+*.exe
+*.out
+*.app
+
+.*.swp
+/tmp
+
+*~
\ No newline at end of file
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/.travis.yml mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.travis.yml
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/.travis.yml	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/.travis.yml	2014-06-20 19:36:39.654481173 -0700
@@ -0,0 +1,2 @@
+script:
+  - "ruby run_test.rb all test"
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/README.md mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/README.md
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/README.md	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/README.md	2014-06-20 19:36:39.654481173 -0700
@@ -0,0 +1,44 @@
+mruby-tempfile
+==============
+
+Tempfile class for mruby (experimental)
+
+depend on mruby-io(iij/mruby, mruby-support-io branch), mruby-dir, mrub-simple-random, mruby-sprintf, mruby-time
+
+## Implemented methods
+
+### Tempfile
+ - http://docs.ruby-lang.org/ja/1.9.3/class/Tempfile.html
+
+| method                           | mruby-tempfile | memo |
+| -------------------------------- | -------------- | ---- |
+| Tempfile.new, Tempfile.open      | o              |      |
+| Tempfile#close                   | o              |      |
+| Tempfile#close!                  | o              |      |
+| Tempfile#delete, Tempfile#unlink | o              |      |
+| Tempfile#length, Tempfile#size   | o              |      |
+| Tempfile#open                    | x              |      |
+| Tempfile#path                    | o              |      |
+
+
+## License
+
+Copyright (c) 2013 Internet Initiative Japan Inc.
+
+Permission is hereby granted, free of charge, to any person obtaining a 
+copy of this software and associated documentation files (the "Software"), 
+to deal in the Software without restriction, including without limitation 
+the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+and/or sell copies of the Software, and to permit persons to whom the 
+Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in 
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+DEALINGS IN THE SOFTWARE.
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/mrbgem.rake mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/mrbgem.rake
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/mrbgem.rake	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/mrbgem.rake	2014-06-20 19:36:39.654481173 -0700
@@ -0,0 +1,9 @@
+MRuby::Gem::Specification.new('mruby-tempfile') do |spec|
+  spec.license = 'MIT'
+  spec.author  = 'Internet Initiative Japan Inc.'
+
+  spec.add_dependency 'mruby-dir'
+  #spec.add_dependency 'mruby-env'      # not mandatory
+  spec.add_dependency 'mruby-io'
+  #spec.add_dependency 'mruby-random'   # or 'mruby-simple-random'
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/mrblib/tempfile.rb mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/mrblib/tempfile.rb
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/mrblib/tempfile.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/mrblib/tempfile.rb	2014-06-20 19:36:39.654481173 -0700
@@ -0,0 +1,93 @@
+# -*- coding: utf-8 -*-
+
+class Tempfile < File
+  def initialize(basename, tempdir = Dir::tmpdir)
+    @deleted = false
+    @basename = basename
+    @mode = "w+"
+    @perm = 0600
+    @path = @path || make_tmpname(basename, tempdir)
+
+    @entity = TempfilePath.new(@path)
+    super(@path, @mode, @perm)
+  end
+
+  def make_tmpname(basename, tempdir, n=nil)
+    rand_max = 0x100000000
+    t = Time.now
+    ymd = sprintf("%04d%02d%02d", t.year, t.month, t.day)
+    pid = Tempfile._getpid
+
+    rand_str = rand(t.usec).to_s(36)
+
+    while rand_str.size < 7
+      rand_str += rand(Time.now.usec).to_s(36)
+    end
+
+    rand_str = rand_str[0, 7]
+
+    if Array === basename
+      prefix = basename[0]
+      suffix = basename[1]
+    elsif String === basename
+      prefix = basename
+      suffix = nil
+    else
+      raise ArgumentError, "basename is invalied."
+    end
+
+    path = "#{tempdir}/#{prefix}#{ymd}-#{pid}-#{rand_str}"
+    path += "-#{suffix}" if suffix
+
+    while File.exist?(path)
+      n = n || 0
+      path = "#{tempdir}/#{prefix}#{ymd}-#{pid}-#{rand_str}-#{n}{suffix}"
+      n.succ!
+    end
+
+    path
+  end
+
+  def close(real=false)
+    super
+    delete if real
+
+    nil
+  end
+
+  def close!
+    close(true)
+  end
+
+  def delete
+    File.delete(@path)
+    @deleted = true
+
+    self
+  end
+
+  alias :unlink :delete
+
+  def deleted?
+    @deleted
+  end
+
+  def size
+    File.size(@path)
+  end
+
+  alias :length :size
+
+  def path
+    deleted? ? nil : @path
+  end
+
+  def inspect
+    ret = "<#{self.class}:#{@path}"
+    ret += " (closed)" if closed?
+    ret += ">"
+
+    ret
+  end
+
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/mrblib/tmpdir.rb mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/mrblib/tmpdir.rb
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/mrblib/tmpdir.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/mrblib/tmpdir.rb	2014-06-20 19:36:39.654481173 -0700
@@ -0,0 +1,12 @@
+class Dir
+  def self.mktmpdir
+
+  end
+
+  def self.tmpdir
+    tmpdir = "/tmp" || ENV['TMPDIR'] || ENV['TMP'] || ENV['TEMP'] || ENV['USERPROFILE']
+
+    tmpdir
+  end
+end
+
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/run_test.rb mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/run_test.rb
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/run_test.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/run_test.rb	2014-06-20 19:36:39.654481173 -0700
@@ -0,0 +1,31 @@
+#!/usr/bin/env ruby
+#
+# mrbgems test runner
+#
+
+gemname = File.basename(File.dirname(File.expand_path __FILE__))
+
+if __FILE__ == $0
+  repository, dir = 'https://github.com/mruby/mruby.git', 'tmp/mruby'
+
+  build_args = ARGV
+  build_args = ['all', 'test']  if build_args.nil? or build_args.empty?
+
+  Dir.mkdir 'tmp'  unless File.exist?('tmp')
+  unless File.exist?(dir)
+    system "git clone #{repository} #{dir}"
+  end
+
+  exit system(%Q[cd #{dir}; MRUBY_CONFIG=#{File.expand_path __FILE__} ruby minirake #{build_args.join(' ')}])
+end
+
+MRuby::Build.new do |conf|
+  toolchain :gcc
+  conf.gembox 'default'
+
+  conf.gem github: 'iij/mruby-dir'
+  conf.gem github: 'iij/mruby-env'
+  conf.gem github: 'iij/mruby-io'
+
+  conf.gem File.expand_path(File.dirname(__FILE__))
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/src/tempfile.c mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/src/tempfile.c
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/src/tempfile.c	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/src/tempfile.c	2014-06-20 19:36:39.654481173 -0700
@@ -0,0 +1,93 @@
+/*
+** tempfile.c - Tempfile
+**
+** See Copyright Notice in mruby.h
+*/
+#include "mruby.h"
+#include "mruby/class.h"
+#include "mruby/value.h"
+#include "mruby/variable.h"
+#include "mruby/string.h"
+#include "mruby/data.h"
+
+//#include <stdlib.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+static void mrb_tempfile_path_free(mrb_state *, void *);
+
+struct tempfile_path {
+  char *pathname;
+};
+
+const static struct mrb_data_type mrb_tempfile_path_type = { "TempfilePath", mrb_tempfile_path_free };
+
+static void
+mrb_tempfile_path_free(mrb_state *mrb, void *self)
+{
+  struct tempfile_path *tp = self;
+
+  if ( ! access(tp->pathname, F_OK) ) {
+    unlink(tp->pathname);
+  }
+
+  mrb_free(mrb, self);
+}
+
+mrb_value
+mrb_tempfile_path_init(mrb_state *mrb, mrb_value self)
+{
+  mrb_value path;
+  struct tempfile_path *tp;
+
+  tp = (struct tempfile_path *)mrb_malloc(mrb, sizeof(struct tempfile_path));
+
+  mrb_get_args(mrb, "S", &path);
+  tp->pathname = mrb_string_value_cstr(mrb, &path);
+
+  DATA_TYPE(self) = &mrb_tempfile_path_type;
+  DATA_PTR(self) = tp;
+
+  return self;
+}
+
+mrb_value
+mrb_tempfile_getpid(mrb_state *mrb, mrb_value self)
+{
+  mrb_value value;
+
+  value = mrb_fixnum_value(getpid());
+
+  return value;
+}
+
+void
+mrb_init_tempfile_path(mrb_state *mrb)
+{
+  struct RClass *tempfile_path_class;
+
+  tempfile_path_class = mrb_define_class(mrb, "TempfilePath", mrb->object_class);
+  MRB_SET_INSTANCE_TT(tempfile_path_class, MRB_TT_DATA);
+
+  mrb_define_method(mrb, tempfile_path_class, "initialize", mrb_tempfile_path_init, MRB_ARGS_REQ(1));
+}
+
+void
+mrb_mruby_tempfile_gem_init(mrb_state *mrb)
+{
+  struct RClass *tempfile_class;
+  struct RClass *file;
+
+  file = mrb_class_get(mrb, "File");
+  tempfile_class = mrb_define_class(mrb, "Tempfile", file);
+
+  MRB_SET_INSTANCE_TT(tempfile_class, MRB_TT_DATA);
+
+  mrb_define_class_method(mrb, tempfile_class, "_getpid", mrb_tempfile_getpid, MRB_ARGS_NONE());
+
+  mrb_init_tempfile_path(mrb);
+}
+
+void
+mrb_mruby_tempfile_gem_final(mrb_state* mrb) {
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-tempfile/test/test_tempfile.rb mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/test/test_tempfile.rb
--- mruby-1.0.0/build/mrbgems/mruby-tempfile/test/test_tempfile.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-tempfile/test/test_tempfile.rb	2014-06-20 19:36:39.654481173 -0700
@@ -0,0 +1,18 @@
+assert('Tempfile remove tempfile (when GC run)') do
+  t = Tempfile.new 'test'
+  path = t.path
+  assert_true File.exist?(path)
+  t.close false
+  assert_true File.exist?(path)
+  t = nil
+  GC.start
+  assert_false File.exist?(path)
+end
+
+assert('Tempfile remove tempfile (call Tempfile#close with real = true)') do
+  t = Tempfile.new 'test'
+  path = t.path
+  assert_true File.exist?(path)
+  t.close true
+  assert_false File.exist?(path)
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/HEAD	2014-06-21 11:59:14.004412940 -0700
@@ -0,0 +1 @@
+ref: refs/heads/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/config mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/config
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/config	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/config	2014-06-21 11:59:14.007746268 -0700
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = https://github.com/mattn/mruby-thread.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/description mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/description
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/description	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/description	2014-06-21 11:59:13.164414133 -0700
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/applypatch-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/applypatch-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/applypatch-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/applypatch-msg.sample	2014-06-21 11:59:13.164414133 -0700
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/commit-msg" &&
+	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
+:
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/commit-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/commit-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/commit-msg.sample	2014-06-21 11:59:13.164414133 -0700
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/post-update.sample mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/post-update.sample
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/post-update.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/post-update.sample	2014-06-21 11:59:13.164414133 -0700
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/pre-applypatch.sample mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/pre-applypatch.sample
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/pre-applypatch.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/pre-applypatch.sample	2014-06-21 11:59:13.164414133 -0700
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
+:
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/pre-commit.sample mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/pre-commit.sample
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/pre-commit.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/pre-commit.sample	2014-06-21 11:59:13.164414133 -0700
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/pre-push.sample mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/pre-push.sample
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/pre-push.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/pre-push.sample	2014-06-21 11:59:13.164414133 -0700
@@ -0,0 +1,54 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+IFS=' '
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/pre-rebase.sample mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/pre-rebase.sample
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/pre-rebase.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/pre-rebase.sample	2014-06-21 11:59:13.164414133 -0700
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up-to-date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+exit 0
+
+################################################################
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/prepare-commit-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/prepare-commit-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/prepare-commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/prepare-commit-msg.sample	2014-06-21 11:59:13.164414133 -0700
@@ -0,0 +1,36 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples.  The first comments out the
+# "Conflicts:" part of a merge commit.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+case "$2,$3" in
+  merge,)
+    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
+
+# ,|template,)
+#   /usr/bin/perl -i.bak -pe '
+#      print "\n" . `git diff --cached --name-status -r`
+#	 if /^#/ && $first++ == 0' "$1" ;;
+
+  *) ;;
+esac
+
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/update.sample mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/update.sample
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/hooks/update.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/hooks/update.sample	2014-06-21 11:59:13.164414133 -0700
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to blocks unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
Binary files mruby-1.0.0/build/mrbgems/mruby-thread/.git/index and mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/index differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/info/exclude mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/info/exclude
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/info/exclude	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/info/exclude	2014-06-21 11:59:13.164414133 -0700
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/logs/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/logs/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/logs/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/logs/HEAD	2014-06-21 11:59:14.007746268 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 f0595da2c0ba093760b85d81a37509f7215df1ad Daniel Bittman <danielbittman1@gmail.com> 1403377154 -0700	clone: from https://github.com/mattn/mruby-thread.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/logs/refs/heads/master mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/logs/refs/heads/master
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/logs/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/logs/refs/heads/master	2014-06-21 11:59:14.004412940 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 f0595da2c0ba093760b85d81a37509f7215df1ad Daniel Bittman <danielbittman1@gmail.com> 1403377154 -0700	clone: from https://github.com/mattn/mruby-thread.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/logs/refs/remotes/origin/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/logs/refs/remotes/origin/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/logs/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/logs/refs/remotes/origin/HEAD	2014-06-21 11:59:14.004412940 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 f0595da2c0ba093760b85d81a37509f7215df1ad Daniel Bittman <danielbittman1@gmail.com> 1403377154 -0700	clone: from https://github.com/mattn/mruby-thread.git
Binary files mruby-1.0.0/build/mrbgems/mruby-thread/.git/objects/pack/pack-b7fa170d98ec5105cfec9497f0f38e55ad16c131.idx and mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/objects/pack/pack-b7fa170d98ec5105cfec9497f0f38e55ad16c131.idx differ
Binary files mruby-1.0.0/build/mrbgems/mruby-thread/.git/objects/pack/pack-b7fa170d98ec5105cfec9497f0f38e55ad16c131.pack and mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/objects/pack/pack-b7fa170d98ec5105cfec9497f0f38e55ad16c131.pack differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/packed-refs mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/packed-refs
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/packed-refs	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/packed-refs	2014-06-21 11:59:14.004412940 -0700
@@ -0,0 +1,2 @@
+# pack-refs with: peeled fully-peeled 
+f0595da2c0ba093760b85d81a37509f7215df1ad refs/remotes/origin/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/refs/heads/master mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/refs/heads/master
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/refs/heads/master	2014-06-21 11:59:14.004412940 -0700
@@ -0,0 +1 @@
+f0595da2c0ba093760b85d81a37509f7215df1ad
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/.git/refs/remotes/origin/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/refs/remotes/origin/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-thread/.git/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/.git/refs/remotes/origin/HEAD	2014-06-21 11:59:14.004412940 -0700
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/example/lock.rb mruby-1.0.0-seaos/build/mrbgems/mruby-thread/example/lock.rb
--- mruby-1.0.0/build/mrbgems/mruby-thread/example/lock.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/example/lock.rb	2014-06-21 11:59:14.007746268 -0700
@@ -0,0 +1,20 @@
+#require 'mruby-thread'
+
+m = Mutex.new
+v = "foo"
+th = Thread.new(v, m) do |v, m|
+  for num in 1..3 do
+    m.lock
+    print("thread: num = ", num, "\n")
+    m.unlock
+    Thread.sleep 1
+  end
+  nil
+end
+for num in 1..3 do
+  m.lock
+  print("main: num = ", num, "\n")
+  m.unlock
+  Thread.sleep 1
+end
+th.join
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/example/simple.rb mruby-1.0.0-seaos/build/mrbgems/mruby-thread/example/simple.rb
--- mruby-1.0.0/build/mrbgems/mruby-thread/example/simple.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/example/simple.rb	2014-06-21 11:59:14.007746268 -0700
@@ -0,0 +1,13 @@
+#!mruby
+
+v = "foo"
+th = Thread.new(v) do |x|
+  puts "in thread: x is #{x}"
+  puts "in thread: v is #{v.inspect}" # should be nil
+  v = "bar" # shouldn't be updated
+  "baz"
+end
+
+r = th.join
+puts "in main: v is #{v}" # should be remained as foo
+puts "in main: r is #{r}" # should be remained as baz
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/mrbgem.rake mruby-1.0.0-seaos/build/mrbgems/mruby-thread/mrbgem.rake
--- mruby-1.0.0/build/mrbgems/mruby-thread/mrbgem.rake	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/mrbgem.rake	2014-06-21 11:59:14.007746268 -0700
@@ -0,0 +1,6 @@
+MRuby::Gem::Specification.new('mruby-thread') do |spec|
+  spec.license = 'MIT'
+  spec.authors = 'mattn'
+
+  spec.linker.libraries << ['pthread']
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/src/mrb_thread.c mruby-1.0.0-seaos/build/mrbgems/mruby-thread/src/mrb_thread.c
--- mruby-1.0.0/build/mrbgems/mruby-thread/src/mrb_thread.c	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/src/mrb_thread.c	2014-06-21 11:59:14.007746268 -0700
@@ -0,0 +1,448 @@
+#include <mruby.h>
+#include <mruby/string.h>
+#include <mruby/array.h>
+#include <mruby/hash.h>
+#include <mruby/proc.h>
+#include <mruby/data.h>
+#include <mruby/value.h>
+#include <mruby/variable.h>
+#include <string.h>
+#ifndef _MSC_VER
+#include <strings.h>
+#endif
+#ifdef _WIN32
+#include <windows.h>
+#endif
+#include <ctype.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+typedef struct {
+  int argc;
+  mrb_value* argv;
+  struct RProc* proc;
+  pthread_t thread;
+  mrb_state* mrb_caller;
+  mrb_state* mrb;
+  mrb_value result;
+} mrb_thread_context;
+
+static void
+mrb_thread_context_free(mrb_state *mrb, void *p) {
+  if (p) {
+    mrb_thread_context* context = (mrb_thread_context*) p;
+    if (context->mrb) mrb_close(context->mrb);
+    if (context->argv) free(context->argv);
+    free(p);
+  }
+}
+
+static const struct mrb_data_type mrb_thread_context_type = {
+  "mrb_thread_context", mrb_thread_context_free,
+};
+
+typedef struct {
+  pthread_mutex_t mutex;
+  int locked;
+} mrb_mutex_context;
+
+static void
+mrb_mutex_context_free(mrb_state *mrb, void *p) {
+  if (p) {
+    mrb_mutex_context* context = (mrb_mutex_context*) p;
+    pthread_mutex_destroy(&context->mutex);
+    free(p);
+  }
+}
+
+static const struct mrb_data_type mrb_mutex_context_type = {
+  "mrb_mutex_context", mrb_mutex_context_free,
+};
+
+typedef struct {
+  pthread_mutex_t mutex;
+  mrb_value queue;
+} mrb_queue_context;
+
+static void
+mrb_queue_context_free(mrb_state *mrb, void *p) {
+  if (p) {
+    mrb_queue_context* context = (mrb_queue_context*) p;
+    pthread_mutex_destroy(&context->mutex);
+    free(p);
+  }
+}
+
+static const struct mrb_data_type mrb_queue_context_type = {
+  "mrb_queue_context", mrb_queue_context_free,
+};
+
+// based on https://gist.github.com/3066997
+static mrb_value
+migrate_simple_value(mrb_state *mrb, mrb_value v, mrb_state *mrb2) {
+  mrb_value nv = mrb_nil_value();
+
+  nv.tt = v.tt;
+  switch (mrb_type(v)) {
+  case MRB_TT_OBJECT:
+    nv.value.p = v.value.p;
+    break;
+  case MRB_TT_FALSE:
+  case MRB_TT_TRUE:
+  case MRB_TT_FIXNUM:
+    nv.value.i = v.value.i;
+    break;
+  case MRB_TT_SYMBOL:
+    {
+      mrb_int len;
+      const char *p = mrb_sym2name_len(mrb, mrb_symbol(v), &len);
+      nv = mrb_symbol_value(mrb_intern_str(mrb2, mrb_str_new_static(mrb2, p, len)));
+    }
+    break;
+  case MRB_TT_FLOAT:
+    nv.value.f = v.value.f;
+    break;
+  case MRB_TT_STRING:
+    nv = mrb_str_new(mrb2, RSTRING_PTR(v), RSTRING_LEN(v));
+    break;
+  case MRB_TT_ARRAY:
+    {
+      struct RArray *a0, *a1;
+      int i;
+
+      a0 = mrb_ary_ptr(v);
+      nv = mrb_ary_new_capa(mrb2, a0->len);
+      a1 = mrb_ary_ptr(nv);
+      for (i=0; i<a0->len; i++) {
+        int ai = mrb_gc_arena_save(mrb2);
+        a1->ptr[i] = migrate_simple_value(mrb, a0->ptr[i], mrb2);
+        a1->len++;
+        mrb_gc_arena_restore(mrb2, ai);
+      }
+    }
+    break;
+  case MRB_TT_HASH:
+    {
+      mrb_value ka;
+      int i, l;
+
+      nv = mrb_hash_new(mrb2);
+      ka = mrb_hash_keys(mrb, v);
+      l = RARRAY_LEN(ka);
+      for (i = 0; i < l; i++) {
+        int ai = mrb_gc_arena_save(mrb2);
+        mrb_value k = migrate_simple_value(mrb, mrb_ary_entry(ka, i), mrb2);
+        mrb_value o = migrate_simple_value(mrb, mrb_hash_get(mrb, v, k), mrb2);
+        mrb_hash_set(mrb2, nv, k, o);
+        mrb_gc_arena_restore(mrb2, ai);
+      }
+    }
+    break;
+  case MRB_TT_DATA:
+    nv = v;
+    DATA_PTR(nv) = DATA_PTR(v);
+    DATA_TYPE(nv) = DATA_TYPE(v);
+    break;
+  default:
+    mrb_raise(mrb, E_TYPE_ERROR, "cannot migrate object");
+    break;
+  }
+  return nv;
+}
+
+static void*
+mrb_thread_func(void* data) {
+  mrb_thread_context* context = (mrb_thread_context*) data;
+  mrb_state* mrb = context->mrb;
+  context->result = mrb_yield_argv(mrb, mrb_obj_value(context->proc), context->argc, context->argv);
+  return NULL;
+}
+
+static mrb_value
+mrb_thread_init(mrb_state* mrb, mrb_value self) {
+  mrb_value proc = mrb_nil_value();
+  int argc;
+  mrb_value* argv;
+  mrb_get_args(mrb, "&*", &proc, &argv, &argc);
+  if (!mrb_nil_p(proc)) {
+    int i, l;
+    mrb_thread_context* context = (mrb_thread_context*) malloc(sizeof(mrb_thread_context));
+    context->mrb_caller = mrb;
+    context->mrb = mrb_open();
+    context->proc = mrb_proc_ptr(proc);
+    context->argc = argc;
+    context->argv = calloc(sizeof (mrb_value), context->argc);
+    context->result = mrb_nil_value();
+    for (i = 0; i < context->argc; i++) {
+      context->argv[i] = migrate_simple_value(mrb, argv[i], context->mrb);
+    }
+
+    {
+      mrb_value gv = mrb_funcall(mrb, self, "global_variables", 0, NULL);
+      l = RARRAY_LEN(gv);
+      for (i = 0; i < l; i++) {
+        mrb_int len;
+        int ai = mrb_gc_arena_save(mrb);
+        mrb_value k = mrb_ary_entry(gv, i);
+        mrb_value o = mrb_gv_get(mrb, mrb_symbol(k));
+        const char *p = mrb_sym2name_len(mrb, mrb_symbol(k), &len);
+        mrb_gv_set(context->mrb,
+          mrb_intern_static(context->mrb, p, len),
+          migrate_simple_value(mrb, o, context->mrb));
+        mrb_gc_arena_restore(mrb, ai);
+      }
+    }
+
+    mrb_iv_set(mrb, self, mrb_intern_lit(mrb, "context"), mrb_obj_value(
+      Data_Wrap_Struct(mrb, mrb->object_class,
+      &mrb_thread_context_type, (void*) context)));
+
+    pthread_create(&context->thread, NULL, &mrb_thread_func, (void*) context);
+  }
+  return self;
+}
+
+static mrb_value
+mrb_thread_join(mrb_state* mrb, mrb_value self) {
+  mrb_value value_context = mrb_iv_get(mrb, self, mrb_intern_lit(mrb, "context"));
+  mrb_thread_context* context = NULL;
+  Data_Get_Struct(mrb, value_context, &mrb_thread_context_type, context);
+  pthread_join(context->thread, NULL);
+
+  context->result = migrate_simple_value(mrb, context->result, mrb);
+  mrb_close(context->mrb);
+  context->mrb = NULL;
+  return context->result;
+}
+
+static mrb_value
+mrb_thread_kill(mrb_state* mrb, mrb_value self) {
+  mrb_value value_context = mrb_iv_get(mrb, self, mrb_intern_lit(mrb, "context"));
+  mrb_thread_context* context = NULL;
+  Data_Get_Struct(mrb, value_context, &mrb_thread_context_type, context);
+  pthread_kill(context->thread, 0);
+
+  mrb_close(context->mrb);
+  context->mrb = NULL;
+  return context->result;
+}
+
+static mrb_value
+mrb_thread_alive(mrb_state* mrb, mrb_value self) {
+  mrb_value value_context = mrb_iv_get(mrb, self, mrb_intern_lit(mrb, "context"));
+  mrb_thread_context* context = NULL;
+  Data_Get_Struct(mrb, value_context, &mrb_thread_context_type, context);
+
+  context->mrb = NULL;
+  return context->mrb != NULL ? mrb_true_value() : mrb_false_value();
+}
+
+static mrb_value
+mrb_thread_sleep(mrb_state* mrb, mrb_value self) {
+  mrb_int t;
+  mrb_get_args(mrb, "i", &t);
+#ifndef _WIN32
+  sleep(t);
+#else
+  Sleep(t * 1000);
+#endif
+  return mrb_nil_value();
+}
+
+static mrb_value
+mrb_mutex_init(mrb_state* mrb, mrb_value self) {
+  mrb_mutex_context* context = (mrb_mutex_context*) malloc(sizeof(mrb_mutex_context));
+  pthread_mutex_init(&context->mutex, NULL);
+  context->locked = FALSE;
+  DATA_PTR(self) = context;
+  DATA_TYPE(self) = &mrb_mutex_context_type;
+  return self;
+}
+
+static mrb_value
+mrb_mutex_lock(mrb_state* mrb, mrb_value self) {
+  mrb_mutex_context* context = DATA_PTR(self);
+  if (pthread_mutex_lock(&context->mutex) != 0) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "cannot lock");
+  }
+  context->locked = TRUE;
+  return mrb_nil_value();
+}
+
+static mrb_value
+mrb_mutex_try_lock(mrb_state* mrb, mrb_value self) {
+  mrb_mutex_context* context = DATA_PTR(self);
+  if (pthread_mutex_trylock(&context->mutex) == 0) {
+    context->locked = TRUE;
+    return mrb_true_value();
+  }
+  return mrb_false_value();
+}
+
+static mrb_value
+mrb_mutex_locked(mrb_state* mrb, mrb_value self) {
+  mrb_mutex_context* context = DATA_PTR(self);
+  return context->locked ? mrb_true_value() : mrb_false_value();
+}
+
+static mrb_value
+mrb_mutex_unlock(mrb_state* mrb, mrb_value self) {
+  mrb_mutex_context* context = DATA_PTR(self);
+  if (pthread_mutex_unlock(&context->mutex) != 0) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "cannot unlock");
+  }
+  context->locked = FALSE;
+  return mrb_nil_value();
+}
+
+static mrb_value
+mrb_mutex_sleep(mrb_state* mrb, mrb_value self) {
+  mrb_int t;
+  mrb_get_args(mrb, "i", &t);
+#ifndef _WIN32
+  sleep(t);
+#else
+  Sleep(t * 1000);
+#endif
+  return mrb_mutex_unlock(mrb, self);
+}
+
+static mrb_value
+mrb_mutex_synchronize(mrb_state* mrb, mrb_value self) {
+  mrb_value proc = mrb_nil_value();
+  mrb_get_args(mrb, "&", &proc);
+  if (!mrb_nil_p(proc)) {
+    mrb_mutex_lock(mrb, self);
+    mrb_yield_argv(mrb, proc, 0, NULL);
+    mrb_mutex_unlock(mrb, self);
+  }
+  return mrb_nil_value();
+}
+
+static mrb_value
+mrb_queue_init(mrb_state* mrb, mrb_value self) {
+  mrb_queue_context* context = (mrb_queue_context*) malloc(sizeof(mrb_queue_context));
+  pthread_mutex_init(&context->mutex, NULL);
+  context->queue = mrb_ary_new(mrb);
+  DATA_PTR(self) = context;
+  DATA_TYPE(self) = &mrb_queue_context_type;
+  return self;
+}
+
+static mrb_value
+mrb_queue_lock(mrb_state* mrb, mrb_value self) {
+  mrb_queue_context* context = DATA_PTR(self);
+  if (pthread_mutex_lock(&context->mutex) != 0) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "cannot lock");
+  }
+  return mrb_nil_value();
+}
+
+
+static mrb_value
+mrb_queue_unlock(mrb_state* mrb, mrb_value self) {
+  mrb_queue_context* context = DATA_PTR(self);
+  if (pthread_mutex_unlock(&context->mutex) != 0) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "cannot unlock");
+  }
+  return mrb_nil_value();
+}
+
+static mrb_value
+mrb_queue_clear(mrb_state* mrb, mrb_value self) {
+  mrb_queue_context* context = DATA_PTR(self);
+  mrb_queue_lock(mrb, self);
+  mrb_ary_clear(mrb, context->queue);
+  mrb_queue_unlock(mrb, self);
+  return mrb_nil_value();
+}
+
+static mrb_value
+mrb_queue_push(mrb_state* mrb, mrb_value self) {
+  mrb_value arg;
+  mrb_queue_context* context = DATA_PTR(self);
+  mrb_get_args(mrb, "o", &arg);
+  mrb_queue_lock(mrb, self);
+  mrb_ary_push(mrb, context->queue, arg);
+  mrb_queue_unlock(mrb, self);
+  return mrb_nil_value();
+}
+
+static mrb_value
+mrb_queue_pop(mrb_state* mrb, mrb_value self) {
+  mrb_value ret;
+  mrb_queue_context* context = DATA_PTR(self);
+  mrb_queue_lock(mrb, self);
+  ret = mrb_ary_pop(mrb, context->queue);
+  mrb_queue_unlock(mrb, self);
+  return ret;
+}
+
+static mrb_value
+mrb_queue_num_waiting(mrb_state* mrb, mrb_value self) {
+  /* TODO */
+  return mrb_fixnum_value(0);
+}
+
+static mrb_value
+mrb_queue_empty_p(mrb_state* mrb, mrb_value self) {
+  mrb_bool ret;
+  mrb_queue_context* context = DATA_PTR(self);
+  mrb_queue_lock(mrb, self);
+  ret = RARRAY_LEN(context->queue) == 0;
+  mrb_queue_unlock(mrb, self);
+  return mrb_bool_value(ret);
+}
+
+static mrb_value
+mrb_queue_size(mrb_state* mrb, mrb_value self) {
+  mrb_int ret;
+  mrb_queue_context* context = DATA_PTR(self);
+  mrb_queue_lock(mrb, self);
+  ret = RARRAY_LEN(context->queue);
+  mrb_queue_unlock(mrb, self);
+  return mrb_fixnum_value(ret);
+}
+
+void
+mrb_mruby_thread_gem_init(mrb_state* mrb) {
+  struct RClass *_class_thread, *_class_mutex, *_class_queue;
+
+  _class_thread = mrb_define_class(mrb, "Thread", mrb->object_class);
+  mrb_define_method(mrb, _class_thread, "initialize", mrb_thread_init, ARGS_OPT(1));
+  mrb_define_method(mrb, _class_thread, "join", mrb_thread_join, ARGS_NONE());
+  mrb_define_method(mrb, _class_thread, "kill", mrb_thread_kill, ARGS_NONE());
+  mrb_define_method(mrb, _class_thread, "terminate", mrb_thread_kill, ARGS_NONE());
+  mrb_define_method(mrb, _class_thread, "alive?", mrb_thread_alive, ARGS_NONE());
+  mrb_define_module_function(mrb, _class_thread, "sleep", mrb_thread_sleep, ARGS_REQ(1));
+
+  _class_mutex = mrb_define_class(mrb, "Mutex", mrb->object_class);
+  mrb_define_method(mrb, _class_mutex, "initialize", mrb_mutex_init, ARGS_NONE());
+  mrb_define_method(mrb, _class_mutex, "lock", mrb_mutex_lock, ARGS_NONE());
+  mrb_define_method(mrb, _class_mutex, "try_lock", mrb_mutex_try_lock, ARGS_NONE());
+  mrb_define_method(mrb, _class_mutex, "locked?", mrb_mutex_locked, ARGS_NONE());
+  mrb_define_method(mrb, _class_mutex, "sleep", mrb_mutex_sleep, ARGS_REQ(1));
+  mrb_define_method(mrb, _class_mutex, "synchronize", mrb_mutex_synchronize, ARGS_REQ(1));
+  mrb_define_method(mrb, _class_mutex, "unlock", mrb_mutex_unlock, ARGS_NONE());
+
+  _class_queue = mrb_define_class(mrb, "Queue", mrb->object_class);
+  mrb_define_method(mrb, _class_queue, "initialize", mrb_queue_init, ARGS_NONE());
+  mrb_define_method(mrb, _class_queue, "clear", mrb_queue_clear, ARGS_NONE());
+  mrb_define_method(mrb, _class_queue, "push", mrb_queue_push, ARGS_NONE());
+  mrb_define_alias(mrb, _class_queue, "<<", "push");
+  mrb_define_alias(mrb, _class_queue, "enq", "push");
+  mrb_define_method(mrb, _class_queue, "pop", mrb_queue_pop, ARGS_OPT(1));
+  mrb_define_alias(mrb, _class_queue, "deq", "pop");
+  mrb_define_alias(mrb, _class_queue, "shift", "pop");
+  mrb_define_method(mrb, _class_queue, "size", mrb_queue_size, ARGS_NONE());
+  mrb_define_method(mrb, _class_queue, "num_waiting", mrb_queue_num_waiting, ARGS_NONE());
+  mrb_define_method(mrb, _class_queue, "empty?", mrb_queue_empty_p, ARGS_NONE());
+}
+
+void
+mrb_mruby_thread_gem_final(mrb_state* mrb) {
+}
+
+/* vim:set et ts=2 sts=2 sw=2 tw=0: */
diff -uprN mruby-1.0.0/build/mrbgems/mruby-thread/test/thread.rb mruby-1.0.0-seaos/build/mrbgems/mruby-thread/test/thread.rb
--- mruby-1.0.0/build/mrbgems/mruby-thread/test/thread.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-thread/test/thread.rb	2014-06-21 11:59:14.007746268 -0700
@@ -0,0 +1,88 @@
+##
+# Thread test
+
+assert('Object.const_defined? :Thread') do
+ Object.const_defined?(:Thread)
+end
+
+assert('Thread returns Fixnum') do
+  a = Thread.new{100}
+  a.join == 100
+end
+
+assert('Thread returns ture') do
+  a = Thread.new{true}
+  a.join == true
+end
+
+assert('Thread returns false') do
+  a = Thread.new{false}
+  a.join == false
+end
+
+assert('Thread returns Float') do
+  a = Thread.new{99.99}
+  a.join == 99.99
+end
+
+assert('Thread returns String') do
+  a = Thread.new{"hello"}
+  a.join == "hello"
+end
+
+assert('Thread returns Symbol') do
+#  a = Thread.new{:context}
+#  a.join == :context
+  true
+end
+
+assert('Thread returns Array') do
+  a = Thread.new{[1,2,3]}
+  a.join == [1,2,3]
+end
+
+assert('Thread returns Hash') do
+  a = Thread.new{{'abc_key' => 'abc_value', 'cba_key' => 'cba_value'}}
+  a.join == {'abc_key' => 'abc_value', 'cba_key' => 'cba_value'}
+end
+
+assert('Thread migrates Fixnum') do
+  a = Thread.new(100){|a| a}
+  a.join == 100
+end
+
+assert('Thread migrates ture') do
+  a = Thread.new(true){|a| a}
+  a.join == true
+end
+
+assert('Thread migrates false') do
+  a = Thread.new(false){|a| a}
+  a.join == false
+end
+
+assert('Thread migrates Float') do
+  a = Thread.new(99.99){|a| a}
+  a.join == 99.99
+end
+
+assert('Thread migrates String') do
+  a = Thread.new("hello"){|a| a}
+  a.join == "hello"
+end
+
+assert('Thread migrates Symbol') do
+#  a = Thread.new(:context){|a| a}
+#  a.join == :context
+  true
+end
+
+assert('Thread migrates Array') do
+  a = Thread.new([1,2,3]){|a| a}
+  a.join == [1,2,3]
+end
+
+assert('Thread migrates Hash') do
+  a = Thread.new({'abc_key' => 'abc_value', 'cba_key' => 'cba_value'}){|a| a}
+  a.join == {'abc_key' => 'abc_value', 'cba_key' => 'cba_value'}
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/HEAD	2014-06-21 11:59:14.747745217 -0700
@@ -0,0 +1 @@
+ref: refs/heads/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/config mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/config
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/config	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/config	2014-06-21 11:59:14.747745217 -0700
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = https://github.com/AndrewBelt/mruby-yaml.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/description mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/description
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/description	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/description	2014-06-21 11:59:14.011079596 -0700
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/applypatch-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/applypatch-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/applypatch-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/applypatch-msg.sample	2014-06-21 11:59:14.011079596 -0700
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/commit-msg" &&
+	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
+:
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/commit-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/commit-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/commit-msg.sample	2014-06-21 11:59:14.011079596 -0700
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/post-update.sample mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/post-update.sample
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/post-update.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/post-update.sample	2014-06-21 11:59:14.011079596 -0700
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/pre-applypatch.sample mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/pre-applypatch.sample
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/pre-applypatch.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/pre-applypatch.sample	2014-06-21 11:59:14.011079596 -0700
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
+:
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/pre-commit.sample mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/pre-commit.sample
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/pre-commit.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/pre-commit.sample	2014-06-21 11:59:14.011079596 -0700
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/pre-push.sample mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/pre-push.sample
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/pre-push.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/pre-push.sample	2014-06-21 11:59:14.011079596 -0700
@@ -0,0 +1,54 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+IFS=' '
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/pre-rebase.sample mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/pre-rebase.sample
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/pre-rebase.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/pre-rebase.sample	2014-06-21 11:59:14.011079596 -0700
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up-to-date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+exit 0
+
+################################################################
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/prepare-commit-msg.sample mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/prepare-commit-msg.sample
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/prepare-commit-msg.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/prepare-commit-msg.sample	2014-06-21 11:59:14.011079596 -0700
@@ -0,0 +1,36 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples.  The first comments out the
+# "Conflicts:" part of a merge commit.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+case "$2,$3" in
+  merge,)
+    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
+
+# ,|template,)
+#   /usr/bin/perl -i.bak -pe '
+#      print "\n" . `git diff --cached --name-status -r`
+#	 if /^#/ && $first++ == 0' "$1" ;;
+
+  *) ;;
+esac
+
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/update.sample mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/update.sample
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/hooks/update.sample	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/hooks/update.sample	2014-06-21 11:59:14.011079596 -0700
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to blocks unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/index and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/index differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/info/exclude mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/info/exclude
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/info/exclude	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/info/exclude	2014-06-21 11:59:14.011079596 -0700
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/logs/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/logs/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/logs/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/logs/HEAD	2014-06-21 11:59:14.747745217 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 dece9f0136278dea5d263fcf163cdbf763256282 Daniel Bittman <danielbittman1@gmail.com> 1403377154 -0700	clone: from https://github.com/AndrewBelt/mruby-yaml.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/logs/refs/heads/master mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/logs/refs/heads/master
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/logs/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/logs/refs/heads/master	2014-06-21 11:59:14.747745217 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 dece9f0136278dea5d263fcf163cdbf763256282 Daniel Bittman <danielbittman1@gmail.com> 1403377154 -0700	clone: from https://github.com/AndrewBelt/mruby-yaml.git
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/logs/refs/remotes/origin/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/logs/refs/remotes/origin/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/logs/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/logs/refs/remotes/origin/HEAD	2014-06-21 11:59:14.747745217 -0700
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 dece9f0136278dea5d263fcf163cdbf763256282 Daniel Bittman <danielbittman1@gmail.com> 1403377154 -0700	clone: from https://github.com/AndrewBelt/mruby-yaml.git
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/06/6bf158dd0087cb117cce9bd8f7a642d0635f78 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/06/6bf158dd0087cb117cce9bd8f7a642d0635f78 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/07/31aac2f0935c3d2c01b5a6502d6d4097b350fb mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/07/31aac2f0935c3d2c01b5a6502d6d4097b350fb
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/07/31aac2f0935c3d2c01b5a6502d6d4097b350fb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/07/31aac2f0935c3d2c01b5a6502d6d4097b350fb	2014-06-21 11:59:14.737745231 -0700
@@ -0,0 +1,4 @@
+x­S=oÛ0íjıŠƒ;Èl!H
+Ğ½íĞ(ŠØ),¥©’T»èôuéÖã?Ò#eV-FšÁy¼w÷x÷/$‡³««‹WŞkøòæİÛ0,$K<iÊL|³‚)ÿél8°á‰ŸJIÁ(÷ÏCÑ‹NóQ—ûèË{9ˆ£&¦´À`ªñ["Æ=ôxDz.fÀ™j>ë±{Â{Ã|ºğİgí/†¨•¬ªr±Ü–g±©Y‘›b3š1u	!eë¹ z!u£6Ş*Œ&”ûİõƒèš†ÇÖMGå»3%û?¼Q[6‚6D'–%·›°ëiQ{dnÎ¦pœOáâôtq­Nşv.Ï£WÖ…Ég|eÚ}ôqtcÚ<şÚüü3nz›Çßt[sß™\ƒ?4¼'­'uYytz/†ğ)C…ÀìH¬È*©uÎ„;Väd£héî³<Î f8R…%
+TÌn5U²¤š²ô¡æ+ü–6PÚG	÷hQ¾8Ãø+)Qmké•Z˜•MüŒ±;#¡bJ#ä†ôCùlÉrL$@§+JÉ:m4äBdIğ‹íc».n%EJlÌÛ'gu‹´é'$âv{uÙtìÚ°-B=ûİöTzG¼ÿË¡kÕ
+ÇğÙì:µ—‹sytqÀq/ÈgÏš½¤ü£¬ö\ZÉoÄ
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/07/c04fb951333a377485f7199523f7463e7e2d8d and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/07/c04fb951333a377485f7199523f7463e7e2d8d differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/0a/41f17df7b6aa9b50769427dbc2c6b348437ca5 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/0a/41f17df7b6aa9b50769427dbc2c6b348437ca5 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/10/b5cac889ed015d72ebd1086ed26172c21dd76d and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/10/b5cac889ed015d72ebd1086ed26172c21dd76d differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/18/41fc62e5e907e0e9a494ff93e0064651449155 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/18/41fc62e5e907e0e9a494ff93e0064651449155 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/1b/c497f3012f8e4408c302ff7f9b49aed843a784 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/1b/c497f3012f8e4408c302ff7f9b49aed843a784 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/1c/4d9c33e827f26d5f0700fdcf067fe1f13ba88f mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/1c/4d9c33e827f26d5f0700fdcf067fe1f13ba88f
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/1c/4d9c33e827f26d5f0700fdcf067fe1f13ba88f	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/1c/4d9c33e827f26d5f0700fdcf067fe1f13ba88f	2014-06-21 11:59:14.731078574 -0700
@@ -0,0 +1,2 @@
+xÎQJÅ0…aŸ»Šy.“Lšv@D\¸ƒÉäT¯ÜŞ”6îßŠ;ğñ;pà÷¶®×N1M}¨*jòc°¬\
+/Z²Ë"y†Ì1d`©ÎÓ°Ù{§«…%››-‡‘Å&1wO#2JRX¡<Øwÿl;½Y»5zmz¿ÒÓöËKùãËŠ‹·õ™‚è(š%EzäÀ<œëYÙñßÿğn÷P+_ğ~Ğ™N;íêŞPK
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/1c/c7ca7a09cc9af586642b80bc2218752e5546d8 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/1c/c7ca7a09cc9af586642b80bc2218752e5546d8 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/1f/9ea036e233c45da4be25364cf86e9cc5fae16e and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/1f/9ea036e233c45da4be25364cf86e9cc5fae16e differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/1f/c813ab5a153b54e52a07686ba59760aa2ed3c1 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/1f/c813ab5a153b54e52a07686ba59760aa2ed3c1 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/24/948139106f2b2f7e8501f1724c9b7453249d01 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/24/948139106f2b2f7e8501f1724c9b7453249d01 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/25/f43b155d13d45951db3d2da9389e323801eb94 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/25/f43b155d13d45951db3d2da9389e323801eb94 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/28/92c34b7b97e647b30e5e013af057a5dcf2283f mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/28/92c34b7b97e647b30e5e013af057a5dcf2283f
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/28/92c34b7b97e647b30e5e013af057a5dcf2283f	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/28/92c34b7b97e647b30e5e013af057a5dcf2283f	2014-06-21 11:59:14.731078574 -0700
@@ -0,0 +1,3 @@
+xKN1DÙOá]V$m·í#„e6ÜÀm·“‘æyŒ·Çq–¯T%UU\çy¬QßÕÂ,‰8åŞiÔÀ&íÉºÁ%å"e¯´	ÙgGâ
+/-h*BÓgämàUêµµ£×Úb"C€?¿“|ó%Ÿ8ÇS`c‘b6L¯†`œõºy\RáOùÂS•ánÔàù2‡qÚÇu~’
+½õhPŞƒMm£*ÿ3.Î\.íŠ–x•;Ü	ñº.ycİD÷~:¾Oû9‰n+ñğæÖCt•·ú…Ä7H&fÌ
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/28/a607ac730b9f99ea17ac8ba9d7006cd56b39b1 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/28/a607ac730b9f99ea17ac8ba9d7006cd56b39b1 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/28/ad352ca4cd351aaddcadba276a428fd1cb9e13 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/28/ad352ca4cd351aaddcadba276a428fd1cb9e13 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/2c/982a639410a818b94a47804c52f9e27570a943 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/2c/982a639410a818b94a47804c52f9e27570a943 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/2d/55a74e38913cb7f61674c0a88f5ff04deb7735 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/2d/55a74e38913cb7f61674c0a88f5ff04deb7735 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/2d/73525145ee282a00ecb1cdf6abe7c1285f83a5 mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/2d/73525145ee282a00ecb1cdf6abe7c1285f83a5
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/2d/73525145ee282a00ecb1cdf6abe7c1285f83a5	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/2d/73525145ee282a00ecb1cdf6abe7c1285f83a5	2014-06-21 11:59:14.731078574 -0700
@@ -0,0 +1,2 @@
+xMNÄ0…Ù’SX³šæ§BˆŸ $ÖNì0‘Ú¦JÂŒ¸=™9ËïÉï=Û!¯kj &wÓ
+3Ø½XG§%ÎÑÏd&š‰iåUœKöƒØ±ğÖ@FÇ8(Ë£RABíy4ÊêgË.‘¥e?í˜¼nTøo¼4xÂ+ì¾ÃË÷Ši¹y}©œqã$wƒÑÕ¾dãÚÅŸ¸48Ä\ÎXˆÃ‚[Êû9BÍ+Ã	K…Ô¹P/jzë†¼ÁWÚ(ŸëAˆÏcªP®yõ2qyŞäÙ8š”ñ†­Sä8¡´ZjFšƒ´¤'©ìx/Ä{Şâ’B«â¶–ğğ‹k?Züñ»{[
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/30/13c23a3c817864467258ddc9120f7c14de0016 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/30/13c23a3c817864467258ddc9120f7c14de0016 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/31/78cc6af2ef1f550ab7fceb30232013a71f558f and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/31/78cc6af2ef1f550ab7fceb30232013a71f558f differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/35/631b347f0ab95ca091d72550fc92253db2caa0 mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/35/631b347f0ab95ca091d72550fc92253db2caa0
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/35/631b347f0ab95ca091d72550fc92253db2caa0	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/35/631b347f0ab95ca091d72550fc92253db2caa0	2014-06-21 11:59:14.731078574 -0700
@@ -0,0 +1 @@
+x­O¹NÄ0¥ÎWŒDÍâ#>"!tÔÔãx¼k)‰ÃØaÅßc„ÄĞÍ½s.ëšŒBŞ4&‚@BPLÎ*­Œ&ª)ëm”vi’jÄ4%†™¶^O6ê€>9-”U^;3c7À¨H*ô8’ÿã»@fŠN›`ÈN:D©J;Ê‘0úYÚ8:©­ğh—Âğ¼E¦+¼ĞÒàáüÜOG%®§­0íË×éœÛå§¹¬ õÔõR+w¢Oú·Olô/fÃñ™`?–˜>ªn%$.+ì¡Tj-ß¯X{Ü0¼¾"Gˆ4/ÈØrÙ $¨e%øD®;æØ›µ½æ‚ÎyÏ[,×úuVƒĞ
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/36/1f675443790f8dd6dab2db93da7f7ad34ea544 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/36/1f675443790f8dd6dab2db93da7f7ad34ea544 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/3c/7ef91d8a334d82a088db4536e6bcd648b04c43 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/3c/7ef91d8a334d82a088db4536e6bcd648b04c43 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/41/8a0fe10fec179d92d96f0d794afe4dedcdde76 mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/41/8a0fe10fec179d92d96f0d794afe4dedcdde76
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/41/8a0fe10fec179d92d96f0d794afe4dedcdde76	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/41/8a0fe10fec179d92d96f0d794afe4dedcdde76	2014-06-21 11:59:14.734411903 -0700
@@ -0,0 +1,2 @@
+xM
+Â0…]çs%IóW±b—n¼Ád2ÕbÓ–ñúàò{¼÷hÉy, MØ•‘'ô([¢œ3:Ik¼Õl­q)ˆ7°t¤ŒGl“OÑ*c¬(Fíä (¸ÚhHà»<—º9müOøƒ5V8?2Ó–|Õxã•×†½4RŠšÖ“…ÿÔE—'¸÷İõÖC…g¸ã‹‡qbñnN0
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/42/25d87a655256e90a72c04ac93f20ae874f2f4c and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/42/25d87a655256e90a72c04ac93f20ae874f2f4c differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/42/5b6ca3ddb3339a4a4af1fbc034cabdf9e1b39f and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/42/5b6ca3ddb3339a4a4af1fbc034cabdf9e1b39f differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/42/75328ba0f587d2347a52ac8a29240b4332eb7f mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/42/75328ba0f587d2347a52ac8a29240b4332eb7f
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/42/75328ba0f587d2347a52ac8a29240b4332eb7f	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/42/75328ba0f587d2347a52ac8a29240b4332eb7f	2014-06-21 11:59:14.731078574 -0700
@@ -0,0 +1 @@
+xAN1EYç¾@aâÌ$µT!Ê¢à‰íÀH“¤JSàøåûÒÓÜJY w£«‚8Ëè…2:çi!œ’ÕLv¦™3bá£¹Æ®u@ò4-â•‚¸E$ØY\ ¦(ùœñ¨Y•M¼Öá\¥ë¼ê6àÿàšvxy/qİ¹•g°î÷”<Z8Ló4™}İ#‡şS7oš#ÖUàÆq‹¸ÕOí·µU.[‹ãé²~×{1?âûV/
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/43/acd4073d39e9fa99819672e3ab38cd0929ab2e and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/43/acd4073d39e9fa99819672e3ab38cd0929ab2e differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/4f/e8c797ff40aba6d598d1e7ec4bcb664a300eca and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/4f/e8c797ff40aba6d598d1e7ec4bcb664a300eca differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/50/4d995c0bd9defc83d7c80e453bcf49b4718a46 mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/50/4d995c0bd9defc83d7c80e453bcf49b4718a46
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/50/4d995c0bd9defc83d7c80e453bcf49b4718a46	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/50/4d995c0bd9defc83d7c80e453bcf49b4718a46	2014-06-21 11:59:14.731078574 -0700
@@ -0,0 +1,3 @@
+xK
+1]ç}¥ó›$ âˆ.İ Iwt`~¯ïè„ÚTÁƒ—§aè*(­7ua«Rã|p2g/“.d´eJÅSl)P6Ù81Ç…Ç
+,¦bQ9ö>b!Wœ-A6D¬}(Vå/NÄW}N´#-ü†÷öñ'sZåøb×ïò4@ê`ƒF”lÑ Šµ®'+ÿ9÷™be‚Û¥=_/âZJ
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/51/ce60cebb16112960d39f4f51dec62cfa203412 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/51/ce60cebb16112960d39f4f51dec62cfa203412 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/52/272b03f02669ab8df66615bdca0f02009ca478 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/52/272b03f02669ab8df66615bdca0f02009ca478 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/52/b678971cc81b3fd435edbf8da60ed9dc4a0e47 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/52/b678971cc81b3fd435edbf8da60ed9dc4a0e47 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/57/3790ded51b607384fbf36ebb7ba1a84bde5acf and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/57/3790ded51b607384fbf36ebb7ba1a84bde5acf differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/5a/d4120f81107dee6e202f06db1d6df62cc150b6 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/5a/d4120f81107dee6e202f06db1d6df62cc150b6 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/5a/fa6f373fb2c7f92c9076d62e205ba4325d4744 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/5a/fa6f373fb2c7f92c9076d62e205ba4325d4744 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/5c/e71686a838b06ca16470a6fedba133fa27a2e2 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/5c/e71686a838b06ca16470a6fedba133fa27a2e2 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/62/5ba996f28d7c8a7abb95fe3cbc72c1b71d00c1 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/62/5ba996f28d7c8a7abb95fe3cbc72c1b71d00c1 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/68/ab10e4f941a8fb8d57d8ddcd43b3f83e1eb1ac and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/68/ab10e4f941a8fb8d57d8ddcd43b3f83e1eb1ac differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/68/c1a00c1520cd2ac0970f1b44eb4dcbdad29f6b and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/68/c1a00c1520cd2ac0970f1b44eb4dcbdad29f6b differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/6f/8db3c30a3ac3d7f000bb765518d088368cdd4e and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/6f/8db3c30a3ac3d7f000bb765518d088368cdd4e differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/73/ef899727daa79daabbd9ed6c2fa286d9db5eee and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/73/ef899727daa79daabbd9ed6c2fa286d9db5eee differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/73/f3019ac5e7c87728349233bb993fd81f19d920 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/73/f3019ac5e7c87728349233bb993fd81f19d920 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/79/10ddce687dae8bdfee29a8f86219b91b8901ba and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/79/10ddce687dae8bdfee29a8f86219b91b8901ba differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/7b/e59d735b5e693bd127a16414ead8c16d471362 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/7b/e59d735b5e693bd127a16414ead8c16d471362 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/7d/c981c9a247d910388eeb544934b2ab16162f7b and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/7d/c981c9a247d910388eeb544934b2ab16162f7b differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/7f/c571771c0aee1382abd0acc21d84a7f43d32b1 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/7f/c571771c0aee1382abd0acc21d84a7f43d32b1 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/80/e8f6d3ba8f7302628375ca762ad2e12a8a4e8b and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/80/e8f6d3ba8f7302628375ca762ad2e12a8a4e8b differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/85/2e60dfe14f0219066dceb8a1cca83cbdca6aff and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/85/2e60dfe14f0219066dceb8a1cca83cbdca6aff differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/89/38b7a3a0c8914d8db6a95688f478f35c370e3e and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/89/38b7a3a0c8914d8db6a95688f478f35c370e3e differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/89/d9fa22f9b3835b78ae17ce12475a463c11612e and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/89/d9fa22f9b3835b78ae17ce12475a463c11612e differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/8a/0a455d0c857ebee6c73814bf997a943168cab5 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/8a/0a455d0c857ebee6c73814bf997a943168cab5 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/90/134f8211b8426f66c3f5c0c02e8154cb19cad9 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/90/134f8211b8426f66c3f5c0c02e8154cb19cad9 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/93/198fed87a30805c27a0e4c8c925422e0953555 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/93/198fed87a30805c27a0e4c8c925422e0953555 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/97/5052497781da4e4735dc0eb2b92f3273a32e04 mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/97/5052497781da4e4735dc0eb2b92f3273a32e04
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/97/5052497781da4e4735dc0eb2b92f3273a32e04	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/97/5052497781da4e4735dc0eb2b92f3273a32e04	2014-06-21 11:59:14.737745231 -0700
@@ -0,0 +1 @@
+x•UQoÓ0æµù§ì!Cj¢uYÙZ© BB&¡I-{pRg1sìb;-âaâñÂÿf„³“ŒeM;ö°¸¾óİ}ş|ß-å2…ÑdtğÄÛÏ/ß¿›N¹$sÏ#ZSev»NTğæÒØS‘5ï¹”hœÍÀıò;pBµi‡F†¢*Sª “â’*Í¤è„ëàq×µæ¨ëˆ'‡Gãxrtğl<9ŠíR'èóxT¬İ‚~­¨ÈèÚ=üğ&‰!%ª^V¾»×©»ØtnYg=©K²X0qŞd&™©‡™#´¦ÊÇSÈÉ*˜jŠ…°‚7 ß43tg¿»R0{d’U]Ln‡ƒŞ M;ƒ6¬I&ËÔ>Š}©6`ÇéhûCˆÏşÍíÙ†…G#*+nX˜.MK|,GÊÍõ¯›Ÿá¸º¹ş›Í$ÕşOuü6ªn›|^•w¤¡S8)¨¢@ì4-+sXH­YÊ)\ÎPFák¸*XV@F¤3œSA±o˜+Yb§0èc•.A¦_ğ}£º@.Â[(+Ôˆ¢İLa“hCRÆ™ASnMîÅ€–Ì”‘°Pr^eÔ*I3m¨°42«‡ %fÈ	×ÔBf†]R%Á\YV©x?tÔ&ÂgœCVĞì³^iÒ`BC8_ºÔMœƒT»AÌİ‰L*…·lEÿ†‡e¹gxXóáá‡a#À(Šáw»ºÎÑ•n·ƒ\º^¥vfëXu¯i=Má[Ål’˜³MìËCRîƒÕN…¦ûİ¤xªÍÂ¿‡é4YÕìÛOœ­Éúat–Ä‘ıìÛOüXú¶Ïƒ{hƒ-:G¤îÎñëc»~*–8ö°÷MÑôğ•T/¬«˜8gë.pt'~3qü†uk°S'ACKş¦Ğ$©â½Ã=·¼ye#ÜØÂÎ1¾ãhSµm{¯»ş×Ğ\­
\ No newline at end of file
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/9d/50bf5027e88a0fd7f75f916dde389f52c52c57 mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/9d/50bf5027e88a0fd7f75f916dde389f52c52c57
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/9d/50bf5027e88a0fd7f75f916dde389f52c52c57	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/9d/50bf5027e88a0fd7f75f916dde389f52c52c57	2014-06-21 11:59:14.731078574 -0700
@@ -0,0 +1 @@
+xEÎÁj!…á®}Š»ÌUG…P’Ğ,¥Ğ¸ê5ã`,}ıÚvÑåwà‡k)KTóCoÌf¢ˆY¦œ]È³a´1Òì¬ãlv1*Yk±Qã[Ö(td6Î&TÚ’AŠĞ£–A+…<BAŸı£6x¥ºV8×;÷¾Àaûáşx,<ÅZ`¯¼QŞ:%a'÷RŠ±—œn©ñœyíp _laàx-´¬ÿ¹Gï¬„G©G.Ş·Dáírz~¹L%‰oçûKm
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/9e/dc4b2dc8904e4b4086d843bdd411332acc54d1 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/9e/dc4b2dc8904e4b4086d843bdd411332acc54d1 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/9e/ed8ce4eff0cedbbe0df4531744bd5c89bebeb0 mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/9e/ed8ce4eff0cedbbe0df4531744bd5c89bebeb0
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/9e/ed8ce4eff0cedbbe0df4531744bd5c89bebeb0	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/9e/ed8ce4eff0cedbbe0df4531744bd5c89bebeb0	2014-06-21 11:59:14.737745231 -0700
@@ -0,0 +1,7 @@
+x•TÍÓ0æÚ<Å(²HmÔV•
+B $$`%„„ĞfëlÌ:v±İm‡/Ä…oÓaì$Ë¶I»ì!q<ãùæËç™I…Jat|üôQğ¾¼|ÿn6Š,‚€Ã´=ŠÜ%‚èè	,TĞs§bg>Š2¥Ğ8Ÿƒÿ
+˜ÜÌøµ,‹và´
+›v… ´íˆˆ›˜¸+Ê°o%“”µÃ ËD %ºZÖ¡ç|êI÷!BGä—utÖA¨ Ë%—ç52¡¶$æ^¬J†Ì #ëD"Ôa† Ç®—ŒZ¶À³ß}*˜?G¡ÈºJ¦#¿ÇÃÑ ×ÀÎ¡	ë`BU‘:Áİ-4-§£>Œãq&ÃáÙ0Ú:_«ñ`fE),¤+Û\@=/Îææ×æçŸDzÍ67¿q³_¬Ê¿¥WH²ÛB^”Å2ÀİeÙ>åL3 î¬É”iP,•1<.‰àXèVãU¸Ê9Í	)C„s&™&î.3­
+0x
+ƒ>–é
+Túï9®dJ³>¼…¢44è–`sb,I¹àM™3ù›Vpk‘‹U°ÔjQRTIÃeÒ!TÖôÁ(DÈˆ0ÌQæ–_2A,JK£ÿ–‹ô¹@sF/0±ílÜ€T-bå¡‘š<¥knƒ¸ÿ.©Òÿ²!ÿNåáÌwD8ÔÇq"Ãíê®0¶[x»‚<\gÇnwšËãº¼Õó‰¬ßvÎ¾Vód5½çr_KwÑj¦C]ı~b<ˆÕş°Ãé4¹®»×$:kµõıìœˆ#÷»×ä¡ò;l£}LƒV÷Éë·~ÎW8ş°öm^×ğ•Ò/œ«œ8o«*ğr'a=qÂZugpS'AC#ş¾Ğ$)'ÃgC¿¼yå"üØÂï˜Şq4PMÙîT×_ı¶W»
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/a6/5c465da78b81991cdbb359a7f0b95fda6a6006 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/a6/5c465da78b81991cdbb359a7f0b95fda6a6006 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/aa/442a3292e89686f845c1b241ecfa970162a8d9 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/aa/442a3292e89686f845c1b241ecfa970162a8d9 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/b0/801c338a95719ca421ce6c2828e24bc7939c5e and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/b0/801c338a95719ca421ce6c2828e24bc7939c5e differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/b3/f79818130d0c023c853f3d887835e67d33e45d mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/b3/f79818130d0c023c853f3d887835e67d33e45d
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/b3/f79818130d0c023c853f3d887835e67d33e45d	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/b3/f79818130d0c023c853f3d887835e67d33e45d	2014-06-21 11:59:14.741078560 -0700
@@ -0,0 +1,2 @@
+xUR=oÂ0íÌ¯x		e¢KE…: µÊĞ©râKêÖ±‘Šúï{¾˜2Ä¹wï>Ş‹këk<n6½×gKøØ¿½Î€*g¨W'˜‡
+õ0êG«jKÌâDUQ3”wq8jj#½Ãó‡OrÌ«bÄv‹H¶PÖ¨}îOÇF;Üz¥O‡àäÒ)Ÿ<Bv,S²P¡[åÊFEÇ9¼ğtŞ:G^Ü’	e ÜÖûŒ»ÖM™¹˜lLbÇ'(Ãsö¡;÷ä†—|Xc.f}"|Hvy1&Î¯MD¤ô/$™„¬ÑşÏpÆ^E±Á… Ë¥dËoãôÑ·»âP­V7‹Ón‰W^‚(û:uçNC¶ıfÖèï¸Üøf‹é•˜ıAŠ›
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/b6/aac2f0dff8bf65e27cca6878ebb7f8cc3ecf44 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/b6/aac2f0dff8bf65e27cca6878ebb7f8cc3ecf44 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/b6/ff0a0a1b154de2a09b9d9ea79eeb03982e1284 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/b6/ff0a0a1b154de2a09b9d9ea79eeb03982e1284 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/ba/1624fe864dcad77bd92484db3cb3c0a8b9ef12 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/ba/1624fe864dcad77bd92484db3cb3c0a8b9ef12 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/bc/baed459011e84e8954fda6dc60147c4a70290b and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/bc/baed459011e84e8954fda6dc60147c4a70290b differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/bd/96905d6e97d35dd714d379c9b79b6ff28efeec mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/bd/96905d6e97d35dd714d379c9b79b6ff28efeec
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/bd/96905d6e97d35dd714d379c9b79b6ff28efeec	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/bd/96905d6e97d35dd714d379c9b79b6ff28efeec	2014-06-21 11:59:14.731078574 -0700
@@ -0,0 +1 @@
+x•[J1EıÎ*jJ^•t`ÇT’jètštâîƒğó8—[zk7ğI3èX´_sBãœ#£_p&%´n>8lëRÕAƒ÷ÖèĞ¢ñÈlKZsÉ¦Ô5PæXŒùâİå³¸îuğ7¼ó&p¡yÂÛG£ÛöRz{ã&«­	ğ¬½ÖjÚyRø?yÄàÿru­•+Ÿr‚t(}ÿâ!pÚh<Ô~oyÎËÏÁ§úpÒU€
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/be/00edf762325005d29b5686d16cbf9124af9f6b and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/be/00edf762325005d29b5686d16cbf9124af9f6b differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/bf/0e43bbad2af4f836ebc4b1f0f4932e859586c7 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/bf/0e43bbad2af4f836ebc4b1f0f4932e859586c7 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/bf/da6a869eebc624a126d4e150931d3fb7b4d4ef and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/bf/da6a869eebc624a126d4e150931d3fb7b4d4ef differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/c0/443cce5d887100b22a796603adf0fe35458402 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/c0/443cce5d887100b22a796603adf0fe35458402 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/c6/df986b93322f8c69012a6184a420cd4d93e320 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/c6/df986b93322f8c69012a6184a420cd4d93e320 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/cd/da667b924b6ca94ddabb96a376abf978a4597f and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/cd/da667b924b6ca94ddabb96a376abf978a4597f differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/d2/234c3b3eee7a47aaf46eb862c30758189e887d and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/d2/234c3b3eee7a47aaf46eb862c30758189e887d differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/d2/da1f6a31a8a61503a73accc45e6eb499709e90 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/d2/da1f6a31a8a61503a73accc45e6eb499709e90 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/d3/1c23d2d9f2333e295920b1ef91494cf227ddc8 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/d3/1c23d2d9f2333e295920b1ef91494cf227ddc8 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/d9/03909676b665cb40d618207cf47541ccb7ce97 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/d9/03909676b665cb40d618207cf47541ccb7ce97 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/d9/6b1bd5ff3b646528f20f4367d8b43c755da9a8 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/d9/6b1bd5ff3b646528f20f4367d8b43c755da9a8 differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/d9/ca3099fda93773a8b3dcb5243f707375c831ef and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/d9/ca3099fda93773a8b3dcb5243f707375c831ef differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/d9/ed4c4221a690bb0f9b6c3f368e38216eefdc07 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/d9/ed4c4221a690bb0f9b6c3f368e38216eefdc07 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/de/ce9f0136278dea5d263fcf163cdbf763256282 mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/de/ce9f0136278dea5d263fcf163cdbf763256282
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/de/ce9f0136278dea5d263fcf163cdbf763256282	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/de/ce9f0136278dea5d263fcf163cdbf763256282	2014-06-21 11:59:14.731078574 -0700
@@ -0,0 +1,2 @@
+x[
+Â0EıÎ*fJ’É£õÃ}L2-˜¶´]¾Å%øyîáÂÉS­C‹z×0%w)y2“wâ-éºÈ÷1h"+ŒÙ¨™`0%DïÆ^—90%Ë©G¦X"1:¡M+zµÇ´ÀeäEŞp•gƒ#ı`Nœï•†ç!OõÆi‹Ñyt°×Nkµ­[d“?ïê6|„¡ÉÚVõ?I.
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/df/c9e27d4130864789453f3f64d0f7d63c3a4648 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/df/c9e27d4130864789453f3f64d0f7d63c3a4648 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/e0/6c147aa9d7db514456fcbb183260f1c8606c3c mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/e0/6c147aa9d7db514456fcbb183260f1c8606c3c
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/e0/6c147aa9d7db514456fcbb183260f1c8606c3c	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/e0/6c147aa9d7db514456fcbb183260f1c8606c3c	2014-06-21 11:59:14.734411903 -0700
@@ -0,0 +1 @@
+xÎAjÃ0…á®uŠ¹@Š,G(%É¢÷I£Ö`GA(q7GÈò{ğàOu]çÇŞT!Q.<Qdï+S"¶ƒ&t6eÌìÕ;k®ÒôÒ!å,D!²ÃHIwÇÈ$>ÄÂa9#·şWœ.¹ég]:|É×¸ãø»Ê¼|¦º~Ãà‹a@8X´ÖìëÙõÍ»ù™šá?X Şµ•¥n ­ÕfÕ5O
\ No newline at end of file
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/e5/3544e56b9ddb13334a0e967bafbc88e46e17a8 mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/e5/3544e56b9ddb13334a0e967bafbc88e46e17a8
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/e5/3544e56b9ddb13334a0e967bafbc88e46e17a8	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/e5/3544e56b9ddb13334a0e967bafbc88e46e17a8	2014-06-21 11:59:14.737745231 -0700
@@ -0,0 +1,2 @@
+xm’O‹Ô@Å=çSÌe´ÃâaÁÛ¢ˆ+âEq;é2iíVWfÈ··*ÅUÌ!!©®Wï÷*CÈ\¿¾~q8@¤eX_­6†®;È_n>ŞÁ„¾g‚‡­üõ83—ú¦ï'Ïó2˜1Ç~«´û©ëşÈÀ…l©ğü ª­WZËª¯&ÓÔ_üOßßùAGÀ&<#¡Dé<V¸È(ıŞ]™+¨,G-9ï}@¸½_!e†º”’‰Ñ½[¥G>_òŒ„–,8,˜¦q…œ ë¸F®¤Õlèğ.KÄÄ–}N{êÑ„lİQí«L§ÇîmNg$®¢|¶Á»çÉ§	8Ké“$yø#–èú¤µÙÖ«X%²«>…_d¥T|VóãB$>Â
+.KŠh™1Va‘Òámfm°Táèš'™“»MŒJIõq!=û3îÄhxn‰å(Fÿ&{nãù/ª›ãÃWÛ§'ÙË0[«0XY-a!¬†N÷´ıh-²=!mÑ–¢¥ìÄ#Üo{j	6‰]ÄÑÚÖùö‹ù,Ä
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/e8/6c2f23d67f4bde90770b4eb4d62c0244b893e6 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/e8/6c2f23d67f4bde90770b4eb4d62c0244b893e6 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/e8/7774532530bc3087d7fe60b8e8cb8c247022e7 mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/e8/7774532530bc3087d7fe60b8e8cb8c247022e7
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/e8/7774532530bc3087d7fe60b8e8cb8c247022e7	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/e8/7774532530bc3087d7fe60b8e8cb8c247022e7	2014-06-21 11:59:14.734411903 -0700
@@ -0,0 +1,3 @@
+xM±nÂ0†»’§¸Íí€ºT²`€!‘XmçH,b;:; $84U§“şÿtßwªõ
+¾ŠòĞ«‡[´B;Ôæb´ŒÆ;îğşÉ,õü!mË¾ òğÃÎ3›¥Á[£Ñ„°rwb¿©ìcã)¤tí*Â;l°S{C
+ÃõÔ|Á‹)¯0h2]"§î¼.÷P£…‹'%¦ÅÆ[ìd=R›» ò¼6±é×Şæod"æÿÜ³ÙŸ²»"æŠ$°\ßËĞUÙô‹[v
\ No newline at end of file
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/eb/5d90a94f43137b134adef8dfc040a33e16830e and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/eb/5d90a94f43137b134adef8dfc040a33e16830e differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/f1/a71e13e47bf112c92c927fa4b6af8f5fc844fe and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/f1/a71e13e47bf112c92c927fa4b6af8f5fc844fe differ
Binary files mruby-1.0.0/build/mrbgems/mruby-yaml/.git/objects/fc/127760c7ebe0c5f3274d09f5c988d6f9c49371 and mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/objects/fc/127760c7ebe0c5f3274d09f5c988d6f9c49371 differ
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/packed-refs mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/packed-refs
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/packed-refs	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/packed-refs	2014-06-21 11:59:14.747745217 -0700
@@ -0,0 +1,2 @@
+# pack-refs with: peeled fully-peeled 
+dece9f0136278dea5d263fcf163cdbf763256282 refs/remotes/origin/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/refs/heads/master mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/refs/heads/master
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/refs/heads/master	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/refs/heads/master	2014-06-21 11:59:14.747745217 -0700
@@ -0,0 +1 @@
+dece9f0136278dea5d263fcf163cdbf763256282
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/.git/refs/remotes/origin/HEAD mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/refs/remotes/origin/HEAD
--- mruby-1.0.0/build/mrbgems/mruby-yaml/.git/refs/remotes/origin/HEAD	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/.git/refs/remotes/origin/HEAD	2014-06-21 11:59:14.747745217 -0700
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/README.md mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/README.md
--- mruby-1.0.0/build/mrbgems/mruby-yaml/README.md	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/README.md	2014-06-21 11:59:14.751078546 -0700
@@ -0,0 +1,13 @@
+## mruby-yaml
+
+#### YAML gem for [mruby](https://github.com/mruby/mruby)
+
+mruby-yaml wraps [libyaml](http://pyyaml.org/wiki/LibYAML) and therefore complies with the YAML 1.1 standard. File IO is not supported, as this would create a dependency on other mruby gems.
+
+### Documentation
+
+#### `YAML.load(yaml_str)`
+Converts a YAML 1.1 string to a Ruby object containing hashes, arrays, and strings. YAML scalars (i.e. strings) are converted to Fixnum or Floats if possible.
+
+#### `YAML.dump(obj)`
+Converts a Ruby object to a YAML 1.1 string. Arrays, Hashes, and their subclasses are represented as YAML sequences and mapping nodes. Other objects are converted to strings and represented as scalars.
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/mrbgem.rake mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/mrbgem.rake
--- mruby-1.0.0/build/mrbgems/mruby-yaml/mrbgem.rake	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/mrbgem.rake	2014-06-21 11:59:14.751078546 -0700
@@ -0,0 +1,9 @@
+MRuby::Gem::Specification.new('mruby-yaml') do |spec|
+	spec.license = 'MIT'
+	spec.authors = 'Andrew Belt'
+	spec.version = '0.1.0'
+	spec.description = 'YAML gem for mruby'
+	spec.homepage = 'https://github.com/AndrewBelt/mruby-yaml'
+	
+	spec.linker.libraries << 'yaml'
+end
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/src/yaml.c mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/src/yaml.c
--- mruby-1.0.0/build/mrbgems/mruby-yaml/src/yaml.c	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/src/yaml.c	2014-06-21 11:59:14.751078546 -0700
@@ -0,0 +1,303 @@
+
+#include <stdio.h>
+#include <yaml.h>
+#include <mruby.h>
+#include <mruby/compile.h>
+#include <mruby/string.h>
+#include <mruby/array.h>
+#include <mruby/hash.h>
+#include <inttypes.h>
+#include <errno.h>
+
+#if defined(_MSC_VER)
+#define strtoll _strtoi64
+#endif
+
+void mrb_mruby_yaml_gem_init(mrb_state *mrb);
+void mrb_mruby_yaml_gem_final(mrb_state *mrb);
+
+typedef struct yaml_write_data_t
+{
+  mrb_state *mrb;
+  mrb_value str;
+} yaml_write_data_t;
+
+int yaml_write_handler(void *data, unsigned char *buffer, size_t size);
+static void raise_parser_problem(mrb_state *mrb, yaml_parser_t *parser);
+
+static mrb_value node_to_value(mrb_state *mrb,
+  yaml_document_t *document, yaml_node_t *node);
+static int value_to_node(mrb_state *mrb,
+  yaml_document_t *document, mrb_value value);
+
+
+mrb_value
+mrb_yaml_load(mrb_state *mrb, mrb_value self)
+{
+  yaml_parser_t parser;
+  yaml_document_t document;
+  yaml_node_t *root;
+  
+  mrb_value yaml_str;
+  mrb_value result;
+  
+  /* Extract arguments */
+  mrb_get_args(mrb, "S", &yaml_str);
+  
+  /* Initialize the YAML parser */
+  yaml_parser_initialize(&parser);
+  yaml_parser_set_input_string(&parser,
+    (unsigned char *) RSTRING_PTR(yaml_str), RSTRING_LEN(yaml_str));
+  
+  /* Load the document */
+  yaml_parser_load(&parser, &document);
+  
+  /* Error handling */
+  if (parser.error != YAML_NO_ERROR)
+  {
+    raise_parser_problem(mrb, &parser);
+    return mrb_nil_value();
+  }
+  
+  /* Convert the root node to an MRuby value */
+  root = yaml_document_get_root_node(&document);
+  result = node_to_value(mrb, &document, root);
+  
+  /* Clean up */
+  yaml_document_delete(&document);
+  yaml_parser_delete(&parser);
+  
+  return result;
+}
+
+
+mrb_value
+mrb_yaml_dump(mrb_state *mrb, mrb_value self)
+{
+  yaml_emitter_t emitter;
+  yaml_document_t document;
+  
+  mrb_value root;
+  yaml_write_data_t write_data;
+  
+  /* Extract arguments */
+  mrb_get_args(mrb, "o", &root);
+  
+  /* Build the document */
+  yaml_document_initialize(&document, NULL, NULL, NULL, 0, 0);
+  value_to_node(mrb, &document, root);
+  
+  /* Initialize the emitter */
+  yaml_emitter_initialize(&emitter);
+  
+  write_data.mrb = mrb;
+  write_data.str = mrb_str_new(mrb, NULL, 0);
+  yaml_emitter_set_output(&emitter, &yaml_write_handler, &write_data);
+  
+  /* Dump the document */
+  yaml_emitter_open(&emitter);
+  yaml_emitter_dump(&emitter, &document);
+  yaml_emitter_close(&emitter);
+  
+  /* Clean up */
+  yaml_emitter_delete(&emitter);
+  yaml_document_delete(&document);
+  
+  return write_data.str;
+}
+
+
+int yaml_write_handler(void *data, unsigned char *buffer, size_t size)
+{
+  yaml_write_data_t *write_data = (yaml_write_data_t *) data;
+  mrb_str_buf_cat(write_data->mrb, write_data->str, (char *) buffer, size);
+  return 1;
+}
+
+
+void raise_parser_problem(mrb_state *mrb, yaml_parser_t *parser)
+{
+  mrb_value problem_line = mrb_fixnum_value(parser->problem_mark.line);
+  mrb_value problem_col = mrb_fixnum_value(parser->problem_mark.column);
+  mrb_value problem_str = mrb_str_new_cstr(mrb, parser->problem);
+  
+  mrb_raisef(mrb, E_RUNTIME_ERROR, "%S at line %S column %S",
+    problem_str, problem_line, problem_col);
+}
+
+
+mrb_value
+node_to_value(mrb_state *mrb,
+  yaml_document_t *document, yaml_node_t *node)
+{
+  switch (node->type)
+  {
+    case YAML_SCALAR_NODE:
+    {
+      const char *str = (char *) node->data.scalar.value;
+      char *endptr;
+      long long ll;
+      double dd;
+      
+      /* Check if it is a Fixnum */
+      ll = strtoll(str, &endptr, 0);
+      if (str != endptr && *endptr == '\0')
+        return mrb_fixnum_value(ll);
+      
+      /* Check if it is a Float */
+      dd = strtod(str, &endptr);
+      if (str != endptr && *endptr == '\0')
+        return mrb_float_value(mrb, dd);
+      
+      /* Otherwise it is a String */      
+      return mrb_str_new(mrb, str, node->data.scalar.length);
+    }
+    
+    case YAML_SEQUENCE_NODE:
+    {
+      /* Sequences are arrays in Ruby */
+      mrb_value result = mrb_ary_new(mrb);
+      yaml_node_item_t *item;
+      
+      int ai = mrb_gc_arena_save(mrb);
+      
+      for (item = node->data.sequence.items.start;
+        item < node->data.sequence.items.top; item++)
+      {
+        yaml_node_t *child_node = yaml_document_get_node(document, *item);
+        mrb_value child = node_to_value(mrb, document, child_node);
+        
+        mrb_ary_push(mrb, result, child);
+        mrb_gc_arena_restore(mrb, ai);
+      }
+      
+      return result;
+    }
+    
+    case YAML_MAPPING_NODE:
+    {
+      /* Mappings are hashes in Ruby */
+      mrb_value result = mrb_hash_new(mrb);
+      yaml_node_t *key_node;
+      yaml_node_t *value_node;
+      yaml_node_pair_t *pair;
+      mrb_value key, value;
+      
+      int ai = mrb_gc_arena_save(mrb);
+      
+      for (pair = node->data.mapping.pairs.start;
+        pair < node->data.mapping.pairs.top; pair++)
+      {
+        key_node = yaml_document_get_node(document, pair->key);
+        value_node = yaml_document_get_node(document, pair->value);
+        
+        key = node_to_value(mrb, document, key_node);
+        value = node_to_value(mrb, document, value_node);
+        
+        mrb_hash_set(mrb, result, key, value);
+        mrb_gc_arena_restore(mrb, ai);
+      }
+      
+      return result;
+    }
+    
+    default:
+      return mrb_nil_value();
+  }
+}
+
+
+int value_to_node(mrb_state *mrb,
+  yaml_document_t *document, mrb_value value)
+{
+  int node;
+  
+  switch (mrb_type(value))
+  {
+    case MRB_TT_ARRAY:
+    {
+      mrb_int len = mrb_ary_len(mrb, value);
+      mrb_int i;
+      int ai = mrb_gc_arena_save(mrb);
+      
+      node = yaml_document_add_sequence(document, NULL,
+        YAML_ANY_SEQUENCE_STYLE);
+      
+      for (i = 0; i < len; i++)
+      {
+        mrb_value child = mrb_ary_ref(mrb, value, i);
+        int child_node = value_to_node(mrb, document, child);
+        
+        /* Add the child to the sequence */
+        yaml_document_append_sequence_item(document, node, child_node);
+        mrb_gc_arena_restore(mrb, ai);
+      }
+      
+      break;
+    }
+    
+    case MRB_TT_HASH:
+    {
+      /* Iterating a list of keys is slow, but it only
+       * requires use of the interface defined in `hash.h`.
+       */
+      
+      mrb_value keys = mrb_hash_keys(mrb, value);
+      mrb_int len = mrb_ary_len(mrb, keys);
+      mrb_int i;
+      int ai = mrb_gc_arena_save(mrb);
+      
+      node = yaml_document_add_mapping(document, NULL,
+        YAML_ANY_MAPPING_STYLE);
+      
+      for (i = 0; i < len; i++)
+      {
+        mrb_value key = mrb_ary_ref(mrb, keys, i);
+        mrb_value child = mrb_hash_get(mrb, value, key);
+        
+        int key_node = value_to_node(mrb, document, key);
+        int child_node = value_to_node(mrb, document, child);
+        
+        /* Add the key/value pair to the mapping */
+        yaml_document_append_mapping_pair(document, node,
+          key_node, child_node);
+        mrb_gc_arena_restore(mrb, ai);
+      }
+      
+      break;
+    }
+    
+    default:
+    {
+      /* Equivalent to `obj = obj#to_s` */
+      value = mrb_obj_as_string(mrb, value);
+      
+      /* Fallthrough */
+    }
+    
+    case MRB_TT_STRING:
+    {
+      yaml_char_t *value_chars = (unsigned char *) RSTRING_PTR(value);
+      node = yaml_document_add_scalar(document, NULL,
+        value_chars, RSTRING_LEN(value), YAML_ANY_SCALAR_STYLE);
+      break;
+    }
+  }
+  
+  return node;
+}
+
+
+void
+mrb_mruby_yaml_gem_init(mrb_state *mrb)
+{
+  struct RClass *klass = mrb_define_module(mrb, "YAML");
+  mrb_define_class_method(mrb, klass, "load", mrb_yaml_load, ARGS_REQ(1));
+  mrb_define_class_method(mrb, klass, "dump", mrb_yaml_dump, ARGS_REQ(1));
+}
+
+
+void
+mrb_mruby_yaml_gem_final(mrb_state *mrb)
+{
+}
diff -uprN mruby-1.0.0/build/mrbgems/mruby-yaml/test/yaml.rb mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/test/yaml.rb
--- mruby-1.0.0/build/mrbgems/mruby-yaml/test/yaml.rb	1969-12-31 16:00:00.000000000 -0800
+++ mruby-1.0.0-seaos/build/mrbgems/mruby-yaml/test/yaml.rb	2014-06-21 11:59:14.751078546 -0700
@@ -0,0 +1,74 @@
+
+# YAML::load
+
+assert('YAML load scalar') do
+	YAML.load('foo') == 'foo'
+end
+
+assert('YAML load fixnum') do
+	YAML.load('5') == 5
+end
+
+assert('YAML load float') do
+	YAML.load('5.5') == 5.5
+end
+
+assert('YAML load sequence') do
+	YAML.load("- foo\n- bar\n- baz") == ['foo', 'bar', 'baz']
+end
+
+assert('YAML load mapping') do
+	actual = YAML.load("foo: faz\nbar: baz")
+	expected = {'foo' => 'faz', 'bar' => 'baz'}
+	actual == expected
+end
+
+assert('YAML load combo') do
+	actual = YAML.load("foo: [1, 2.2, 300]\nbar: baz")
+	expected = {'foo' => [1, 2.2, 300], 'bar' => 'baz'}
+	actual == expected
+end
+
+assert('YAML load multi-byte') do
+	actual = YAML.load("bar: ã°ãƒ¼\nfoo: ãµãƒ¼")
+	expected = {'foo' => 'ãµãƒ¼', 'bar' => 'ã°ãƒ¼'}
+	actual == expected
+end
+
+
+# YAML::dump
+
+# Note: There are a number of possible valid strings which can be
+# generated from a single Ruby object.
+# So we can't check for string equality.
+# We have to parse it back again and compare the Ruby objects instead.
+
+assert('YAML dump scalar') do
+	expected = 'foo'
+	actual = YAML.load(YAML.dump(expected))
+	actual == expected
+end
+
+assert('YAML dump sequence') do
+	expected = ['foo', 'bar', 'baz']
+	actual = YAML.load(YAML.dump(expected))
+	actual == expected
+end
+
+assert('YAML dump mapping') do
+	expected = {'foo' => 'faz', 'bar' => 'baz'}
+	actual = YAML.load(YAML.dump(expected))
+	actual == expected
+end
+
+assert('YAML dump combo') do
+	expected = {'foo' => [1, 2, 3], 'bar' => 'baz'}
+	actual = YAML.load(YAML.dump(expected))
+	actual == expected
+end
+
+assert('YAML dump multi-byte') do
+	expected = {'foo' => 'ãµãƒ¼', 'bar' => 'ã°ãƒ¼'}
+	actual = YAML.load(YAML.dump(expected))
+	actual == expected
+end
diff -uprN mruby-1.0.0/build_config.rb mruby-1.0.0-seaos/build_config.rb
--- mruby-1.0.0/build_config.rb	2014-01-10 04:49:57.000000000 -0800
+++ mruby-1.0.0-seaos/build_config.rb	2014-06-21 11:59:55.764353427 -0700
@@ -1,94 +1,20 @@
 MRuby::Build.new do |conf|
-  # load specific toolchain settings
-
-  # Gets set by the VS command prompts.
-  if ENV['VisualStudioVersion']
-    toolchain :visualcpp
-  else
     toolchain :gcc
-  end
-
-  # Use mrbgems
-  # conf.gem 'examples/mrbgems/ruby_extension_example'
-  # conf.gem 'examples/mrbgems/c_extension_example' do |g|
-  #   g.cc.flags << '-g' # append cflags in this gem
-  # end
-  # conf.gem 'examples/mrbgems/c_and_ruby_extension_example'
-  # conf.gem :github => 'masuidrive/mrbgems-example', :branch => 'master'
-  # conf.gem :git => 'git@github.com:masuidrive/mrbgems-example.git', :branch => 'master', :options => '-v'
-
-  # include the default GEMs
-  conf.gembox 'default'
-
-  # C compiler settings
-  # conf.cc do |cc|
-  #   cc.command = ENV['CC'] || 'gcc'
-  #   cc.flags = [ENV['CFLAGS'] || %w()]
-  #   cc.include_paths = ["#{root}/include"]
-  #   cc.defines = %w(DISABLE_GEMS)
-  #   cc.option_include_path = '-I%s'
-  #   cc.option_define = '-D%s'
-  #   cc.compile_options = "%{flags} -MMD -o %{outfile} -c %{infile}"
-  # end
-
-  # mrbc settings
-  # conf.mrbc do |mrbc|
-  #   mrbc.compile_options = "-g -B%{funcname} -o-" # The -g option is required for line numbers
-  # end
-
-  # Linker settings
-  # conf.linker do |linker|
-  #   linker.command = ENV['LD'] || 'gcc'
-  #   linker.flags = [ENV['LDFLAGS'] || []]
-  #   linker.flags_before_libraries = []
-  #   linker.libraries = %w()
-  #   linker.flags_after_libraries = []
-  #   linker.library_paths = []
-  #   linker.option_library = '-l%s'
-  #   linker.option_library_path = '-L%s'
-  #   linker.link_options = "%{flags} -o %{outfile} %{objs} %{libs}"
-  # end
-
-  # Archiver settings
-  # conf.archiver do |archiver|
-  #   archiver.command = ENV['AR'] || 'ar'
-  #   archiver.archive_options = 'rs %{outfile} %{objs}'
-  # end
-
-  # Parser generator settings
-  # conf.yacc do |yacc|
-  #   yacc.command = ENV['YACC'] || 'bison'
-  #   yacc.compile_options = '-o %{outfile} %{infile}'
-  # end
-
-  # gperf settings
-  # conf.gperf do |gperf|
-  #   gperf.command = 'gperf'
-  #   gperf.compile_options = '-L ANSI-C -C -p -j1 -i 1 -g -o -t -N mrb_reserved_word -k"1,3,$" %{infile} > %{outfile}'
-  # end
-
-  # file extensions
-  # conf.exts do |exts|
-  #   exts.object = '.o'
-  #   exts.executable = '' # '.exe' if Windows
-  #   exts.library = '.a'
-  # end
-
-  # file separetor
-  # conf.file_separator = '/'
 end
 
 # Define cross build settings
-# MRuby::CrossBuild.new('32bit') do |conf|
-#   toolchain :gcc
-#
-#   conf.cc.flags << "-m32"
-#   conf.linker.flags << "-m32"
-#
-#   conf.build_mrbtest_lib_only
-#
-#   conf.gem 'examples/mrbgems/c_and_ruby_extension_example'
-#
-#   conf.test_runner.command = 'env'
-#
-# end
+MRuby::CrossBuild.new("sea") do |conf|
+  toolchain :gcc
+  conf.cc.command = "x86_64-pc-seaos-gcc" 
+  conf.linker.command = "x86_64-pc-seaos-gcc"
+  conf.gembox "full-core"
+
+  conf.gem :git => 'https://github.com/iij/mruby-io.git', :branch => 'master'
+  conf.gem :git => 'https://github.com/mattn/mruby-dir.git', :branch => 'master'
+  conf.gem :git => 'https://github.com/mattn/mruby-require.git', :branch => 'master'
+  conf.gem :git => 'https://github.com/iij/mruby-tempfile.git', :branch => 'master'
+  #conf.gem :github => 'iij/mruby-digest', :branch => 'master'
+  #conf.gem :github => 'mattn/mruby-http', :branch => 'master'
+  #conf.gem :github => 'mattn/mruby-thread', :branch => 'master'
+  #conf.gem :github => 'AndrewBelt/mruby-yaml', :branch => 'master'
+end
